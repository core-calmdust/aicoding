<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    
    <title>ã€å¼·åŠ›AIæ­è¼‰ã€‘ç„¡æ–™ã§éŠã¹ã‚‹ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ  - ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ãå¯¾æˆ¦ï¼</title>
    <meta name="description" content="8æ®µéšã®å¼·ã•ã‹ã‚‰é¸ã¹ã‚‹å¼·åŠ›ãªAIã‚’æ­è¼‰ã—ãŸç„¡æ–™ã®ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ ã§ã™ã€‚ç™»éŒ²ä¸è¦ã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸è¦ã§ãƒ–ãƒ©ã‚¦ã‚¶ã§ã™ãã«ãƒ—ãƒ¬ã‚¤å¯èƒ½ã€‚CPUã¨ã®å¯¾æˆ¦ã‚„æ£‹è­œå†ç”Ÿæ©Ÿèƒ½ã‚‚å……å®Ÿã€‚ã‚ãªãŸã®æŒ‘æˆ¦ã‚’ãŠå¾…ã¡ã—ã¦ã„ã¾ã™ï¼">
    <meta name="keywords" content="ãƒªãƒãƒ¼ã‚·, ã‚ªã‚»ãƒ­, ã‚²ãƒ¼ãƒ , ç„¡æ–™, AI, CPU, å¯¾æˆ¦, ãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ , ã‚ªãƒ³ãƒ©ã‚¤ãƒ³, æ€è€ƒã‚¨ãƒ³ã‚¸ãƒ³, å®šçŸ³, æ£‹è­œ">
    <link rel="canonical" href="https://core-calmdust.github.io/aicoding/reversi_v3.html">
    <link rel="icon" href="https://core-calmdust.github.io/aicoding/images/reversi_favicon.ico" type="image/x-icon">

    <meta property="og:title" content="ã€å¼·åŠ›AIæ­è¼‰ã€‘ç„¡æ–™ã§éŠã¹ã‚‹ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ ">
    <meta property="og:description" content="8æ®µéšã®å¼·ã•ã‹ã‚‰é¸ã¹ã‚‹å¼·åŠ›AIæ­è¼‰ï¼ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ããƒ—ãƒ¬ã‚¤ã§ãã‚‹ç„¡æ–™ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ ã€‚">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://core-calmdust.github.io/aicoding/reversi_v3.html">
    <meta property="og:image" content="https://core-calmdust.github.io/aicoding/images/reversi-ogp.png">
    <meta property="og:site_name" content="ç„¡æ–™ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ ">
    <meta property="og:locale" content="ja_JP">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ã€å¼·åŠ›AIæ­è¼‰ã€‘ç„¡æ–™ã§éŠã¹ã‚‹ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ ">
    <meta name="twitter:description" content="8æ®µéšã®å¼·ã•ã‹ã‚‰é¸ã¹ã‚‹å¼·åŠ›AIæ­è¼‰ï¼ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ããƒ—ãƒ¬ã‚¤ã§ãã‚‹ç„¡æ–™ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ ã€‚">
    <meta name="twitter:image" content="https://core-calmdust.github.io/aicoding/images/reversi-ogp.png"> 
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1e2a38;
            --surface-color: #2c3e50;
            --board-bg: #008080;
            --border-color: #1a2531;
            --text-color: #ecf0f1;
            --text-muted-color: #bdc3c7;
            --accent-color: #3498db;
            --accent-hover-color: #2980b9;
            --danger-color: #e74c3c;
            --highlight-color: rgba(255, 255, 0, 0.7);
            --board-size-pc: 600px;
            --board-size-sp: 90vw;
            --graph-inner-bg-color: #3b526a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans JP', sans-serif; background-color: var(--bg-color); color: var(--text-color);
            display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; padding: 10px;
        }

        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        
        main {
            width: 100%;
            max-width: 850px;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 20px;
        }
        
        .top-container {
            display: flex;
            gap: 20px;
            width: 100%;
            align-items: flex-start;
        }

        .sidebar {
            width: 240px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-shrink: 0;
        }

        .game-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%;
            background-color: var(--board-bg); border: 5px solid var(--surface-color); border-radius: 8px; padding: 5px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3), inset 0 2px 5px rgba(0, 0, 0, 0.2); aspect-ratio: 1 / 1;
        }

        .cell {
            width: 100%; height: 100%; border: 1px solid rgba(0, 0, 0, 0.2);
            display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative;
        }

        .disc {
            width: 85%; height: 85%; border-radius: 50%;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }

        .disc.black { background: radial-gradient(circle at 30% 30%, #444, #111); }
        .disc.white { background: radial-gradient(circle at 70% 70%, #fff, #ccc); box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 -2px 4px rgba(0, 0, 0, 0.2); }
        .last-move { outline: 3px solid var(--highlight-color); outline-offset: -3px; border-radius: 2px; }

        .valid-move-hint::after {
            content: ''; display: block; width: 35%; height: 35%;
            background-color: rgba(255, 255, 255, 0.3); border-radius: 50%;
            pointer-events: none; transition: background-color 0.2s;
        }
        .valid-move-hint:hover::after { background-color: rgba(255, 255, 255, 0.5); }

        .controls, .game-info, #evaluation-graph-container, .test-controls {
            background-color: var(--surface-color); padding: 20px;
            border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); width: 100%;
        }
        
        #message-area { font-size: 18px; font-weight: bold; color: var(--danger-color); height: 25px; text-align: center; margin-top: 20px; }
        
        .controls label,
        .test-controls label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-muted-color);
            font-size: 14px;
            font-weight: bold;
        }
        
        .test-controls h2 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--text-color);
            font-size: 1.1em;
        }
        
        .controls select, .test-controls select {
            width: 100%; padding: 12px; border-radius: 6px; border: 1px solid var(--border-color);
            background-color: var(--bg-color); color: var(--text-color); font-size: 16px;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23bdc3c7%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.3-5.5-12.8z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat; background-position: right 12px center; background-size: 12px; cursor: pointer;
        }

        .controls button, .test-controls button {
            width: 100%; padding: 12px; margin-top: 10px; border-radius: 6px; border: none;
            background-color: var(--accent-color); color: white; font-size: 16px; font-weight: bold;
            cursor: pointer; transition: background-color 0.2s ease-in-out;
        }
        
        .controls button:hover, .test-controls button:hover { background-color: var(--accent-hover-color); }
        
        .start-controls-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }
        
        .radio-group { display: flex; gap: 10px; justify-content: flex-start; }
        
        .radio-group label {
            position: relative; width: 48px; height: 48px;
            display: flex; justify-content: center; align-items: center;
            padding: 0; border: 3px solid var(--border-color);
            border-radius: 50%; cursor: pointer; transition: all 0.2s;
            background-color: transparent;
        }
        .radio-group label:hover { border-color: var(--text-muted-color); }
        .radio-group input { display: none; }
        .radio-group label:has(input:checked) {
            border-color: var(--accent-color);
            box-shadow: 0 0 8px var(--accent-color);
        }
        .radio-group label:has(input:disabled) { cursor: not-allowed; opacity: 0.5; }
        
        .radio-group .disc {
            width: 85%; height: 85%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 2px rgba(255,255,255,0.2);
        }
        .radio-group .disc.white { box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 -1px 2px rgba(0,0,0,0.2); }
        
        #start-button {
            background: #cccccc; border: none; padding: 0;
            border-radius: 8px; width: 48px; height: 48px;
            cursor: pointer; transition: all 0.2s ease;
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0; margin: 0;
        }
        #start-button:hover:not(:disabled) { background-color: #b0b0b0; }
        #start-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #6a6a6a; }
        #start-button img { width: 70%; height: 70%; opacity: 0.9; }

        .controls button:disabled, .test-controls button:disabled { background-color: #555; cursor: not-allowed; }
        
        .game-info {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 15px 20px; flex-grow: 1; gap: 15px;
        }
        #turn-info { display: flex; align-items: baseline; gap: 0.5em; font-family: 'Roboto', sans-serif; }
        #turn-count-label { font-size: 1em; font-weight: 700; color: var(--text-muted-color); }
        #turn-count-number { font-size: 1.8em; font-weight: 700; min-width: 2ch; text-align: left; }
        #score-info {
            display: flex; align-items: center; justify-content: center; gap: 8px;
            font-size: 1.6em; font-weight: 700; font-family: 'Roboto', sans-serif;
        }
        #score-info .disc { width: 28px; height: 28px; }
        #black-score, #white-score { min-width: 2.5ch; text-align: center; display: inline-block; }
        
        #evaluation-graph-container { padding: 10px 15px; height: auto; }

        #current-evaluation-display {
            text-align: center;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 700;
            color: var(--text-muted-color);
            margin-bottom: 10px;
            height: 20px;
        }

        #evaluation-graph-wrapper-outer { display: flex; width: 100%; height: 80px; }
        #evaluation-y-axis {
            display: flex; flex-direction: column; justify-content: space-between; align-items: flex-start;
            height: 100%; font-size: 10px; color: var(--text-muted-color);
            margin-right: 8px; width: 25px; flex-shrink: 0; font-family: 'Roboto', sans-serif;
        }
        #evaluation-graph-wrapper { flex-grow: 1; position: relative; overflow: hidden; cursor: default; }
        body.game-over #evaluation-graph-wrapper { cursor: grab; }
        body.graph-dragging #evaluation-graph-wrapper { cursor: grabbing; }

        #evaluation-graph {
            display: flex; height: 100%; position: relative; background-color: var(--graph-inner-bg-color);
            border-left: 1px solid var(--border-color); border-right: 1px solid var(--border-color);
        }
        #evaluation-graph::before {
            content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 1px;
            background-color: var(--border-color); transform: translateY(-50%); z-index: 1;
        }
        .bar-container { flex: 1; height: 100%; position: relative; transition: background-color 0.2s; }
        .bar-container:hover { background-color: rgba(52, 152, 219, 0.1); }
        .bar-container.current-turn-highlight { background-color: rgba(255, 255, 0, 0.2); }
        
        .bar {
            width: 70%; position: absolute; left: 15%; transition: height 0.3s ease, background-color 0.2s; z-index: 2;
        }
        .bar.black { background-color: #444; bottom: 50%; }
        .bar.white { background-color: #eee; top: 50%; }
        .bar-container:hover .bar.black { background-color: #666; }
        .bar-container:hover .bar.white { background-color: #fff; }
        #evaluation-tooltip {
            position: absolute; display: none; background-color: var(--accent-color); color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;
            pointer-events: none; transform: translate(-50%, -130%); white-space: nowrap; z-index: 10;
        }

        .kifu-buttons { display: flex; gap: 10px; margin-top: 10px; }
        .kifu-buttons button {
            flex: 1; margin-top: 0; padding: 6px; font-size: 16px;
            background-color: #cccccc; border-radius: 8px;
        }
        .kifu-buttons button:hover { background-color: #b0b0b0; }
        .kifu-buttons button:disabled { background-color: #6a6a6a; cursor: not-allowed; }
        .kifu-buttons button img {
            height: 1.2em; vertical-align: middle; opacity: 0.8; transition: opacity 0.2s;
        }
        .kifu-buttons button:hover img { opacity: 1; }
        .kifu-buttons button:disabled img { opacity: 0.4; }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .action-buttons button {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-muted-color);
            border: 2px solid var(--border-color);
            border-radius: 6px;
        }
        .action-buttons button:not(:disabled):hover {
            border-color: var(--accent-color);
            color: var(--text-color);
        }
        .action-buttons button:disabled {
            opacity: 0.5;
            background-color: var(--bg-color);
            cursor: not-allowed;
        }
        .action-buttons button.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .research-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(12px, 3.5vw, 24px);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 3px black, -1px -1px 3px black;
            pointer-events: none;
        }
        .research-value.plus { color: #87CEEB; }
        .research-value.minus { color: #F08080; }
        
        .test-cpu-selectors { display: flex; gap: 20px; justify-content: center; }
        .test-cpu-selector { flex: 1; }

        #modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #custom-modal {
            background: var(--surface-color);
            padding: 25px 35px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        #modal-overlay.visible #custom-modal {
            transform: scale(1);
        }
        #modal-message {
            margin: 0;
            font-size: 1.1em;
            color: var(--text-color);
            line-height: 1.6;
        }
        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            justify-content: center;
        }
        .modal-buttons button {
            padding: 10px 24px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        #modal-confirm-btn {
            background: var(--accent-color);
            color: white;
        }
        #modal-confirm-btn:hover {
            background: var(--accent-hover-color);
        }
        #modal-cancel-btn {
            background: var(--bg-color);
            color: var(--text-muted-color);
            border: 2px solid var(--border-color);
        }
        #modal-cancel-btn:hover {
            border-color: var(--text-muted-color);
            color: var(--text-color);
        }

        /* PCç‰ˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’Gridã§å†æ§‹ç¯‰ */
        @media (min-width: 901px) {
            .game-wrapper {
                display: grid;
                grid-template-columns: 240px 1fr;
                grid-template-areas:
                    "sidebar game"
                    "eval    game"
                    "message message"
                    "test    test";
                align-items: start;
            }
            .top-container {
                display: contents;
            }
            .sidebar {
                grid-area: sidebar;
                width: 100%;
            }
            .game-area {
                grid-area: game;
                grid-row: game-start / span 2;
            }
            #evaluation-graph-container {
                grid-area: eval;
                width: 100%;
            }
            #message-area {
                grid-area: message;
                margin-top: 0;
            }
            .test-controls {
                grid-area: test;
            }
        }

        /* =============== ã“ã“ã‹ã‚‰ãŒã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ç‰ˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ä¿®æ­£ç®‡æ‰€ =============== */
        @media (max-width: 900px) {
            .top-container {
                flex-direction: column;
            }
            
            /* --- sidebar: 2ã¤ã®ãƒœãƒƒã‚¯ã‚¹ã‚’å›²ã‚€è¦ªã‚³ãƒ³ãƒ†ãƒŠ --- */
            .sidebar {
                flex-direction: row;     /* ãƒœãƒƒã‚¯ã‚¹ã‚’æ¨ªä¸¦ã³ã« */
                flex-wrap: nowrap;       /* â˜…é‡è¦: æŠ˜ã‚Šè¿”ã—ã‚’ç¦æ­¢ã—ã¦å¸¸ã«ä¸€è¡Œã« */
                width: 100%;
                gap: 10px;
                align-items: stretch;    /* ãƒœãƒƒã‚¯ã‚¹ã®é«˜ã•ã‚’æƒãˆã¦è¦‹ãŸç›®ã‚’ç¶ºéº—ã« */
            }
            
            /* --- .controls: å·¦å´ã®è¨­å®šãƒœãƒƒã‚¯ã‚¹ --- */
            .controls {
                flex: 4; /* æ¨ªå¹…ã®æ¯”ç‡ã‚’èª¿æ•´ */
                display: flex;
                flex-direction: column;
                justify-content: center; /* ä¸­èº«ã‚’ä¸Šä¸‹ä¸­å¤®ã« */
                padding: 10px;
                gap: 5px;
            }
            
            /* --- .game-info: å³å´ã®æƒ…å ±ãƒœãƒƒã‚¯ã‚¹ --- */
            .game-info {
                flex: 5; /* æ¨ªå¹…ã®æ¯”ç‡ã‚’èª¿æ•´ */
                display: flex;
                flex-direction: row; /* â˜…é‡è¦: ä¸­èº«ã‚’æ¨ªä¸¦ã³ã«å¤‰æ›´ */
                flex-wrap: wrap;     /* ç”»é¢ãŒéå¸¸ã«ç‹­ã„å ´åˆã¯æŠ˜ã‚Šè¿”ã™ */
                justify-content: space-around; /* ä¸­èº«ã‚’å‡ç­‰ã«é…ç½® */
                align-items: center;
                gap: 8px;
                padding: 10px;
            }

            /* --- å„ãƒœãƒƒã‚¯ã‚¹å†…ã®è¦ç´ ã‚’ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆåŒ– --- */
            .controls label {
                font-size: 11px;
                text-align: center;
                margin-bottom: 0;
            }
            .controls select {
                font-size: 13px;
                padding: 6px 10px;
            }
            .start-controls-wrapper {
                padding-top: 6px;
                margin-top: 6px;
                justify-content: center;
            }
            .radio-group label, #start-button {
                width: 36px;
                height: 36px;
            }

            #turn-info, #score-info, .action-buttons {
                flex-grow: 0; /* è‡ªå‹•ã§é«˜ã•ãŒä¼¸ã³ã‚‹ã®ã‚’ç„¡åŠ¹åŒ– */
                display: flex;
                align-items: center;
                justify-content: center;
                margin-top: 0;
            }

            #turn-info { font-size: 0.9em; gap: 0.3em; }
            #turn-count-number { font-size: 1.5em; }
            #score-info { font-size: 1.1em; gap: 5px; }
            #score-info .disc { width: 20px; height: 20px; }
            #black-score, #white-score { font-size: 1.3em; }
            
            .action-buttons { gap: 6px; }
            .action-buttons button { padding: 6px; font-size: 11px; }

            /* --- ä»¥ä¸‹ã®éƒ¨åˆ†ã¯å¤‰æ›´ãªã— --- */
            .game-area {
                width: 100%;
            }
            #board {
                width: var(--board-size-sp);
                margin: 0 auto;
            }
            #message-area {
                width: 100%;
                margin: 0; /* PCãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç”¨ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ */
            }
            #evaluation-graph-container {
                display: block; /* SPç‰ˆã§è¡¨ç¤º */
            }
        }
        
        @media (max-width: 600px) {
             .sidebar {
                /* å…ƒã€…ã“ã“ã«ã‚ã£ãŸ flex-wrap: wrap; ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚ */
                /* ã“ã‚Œã«ã‚ˆã‚Šã€ç‹­ã„ç”»é¢ã§ã‚‚ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ãŒä¸€è¡Œã«ä¿ãŸã‚Œã¾ã™ã€‚ */
            }
        }
        /* =============== ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ç‰ˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ä¿®æ­£ã¯ã“ã“ã¾ã§ =============== */
    </style>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org", "@type": "VideoGame", "name": "å¼·åŠ›AIæ­è¼‰ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ ",
      "description": "8æ®µéšã®å¼·ã•ã‹ã‚‰é¸ã¹ã‚‹å¼·åŠ›ãªAIã‚’æ­è¼‰ã—ãŸç„¡æ–™ã®ãƒ–ãƒ©ã‚¦ã‚¶ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ ã§ã™ã€‚ç™»éŒ²ä¸è¦ã§ã™ãã«ãƒ—ãƒ¬ã‚¤ã§ãã¾ã™ã€‚",
      "gamePlatform": "Web-based game", "applicationCategory": "Game", "operatingSystem": "All",
      "author": { "@type": "Person", "name": "Your Name or Company" }, "offers": { "@type": "Offer", "price": "0", "priceCurrency": "JPY" }
    }
    </script>
</head>
<body>
    <main>
        <div class="game-wrapper">
            <div class="top-container">
                <div class="sidebar">
                    <section class="controls" aria-labelledby="game-settings-heading">
                        <h2 id="game-settings-heading" class="visually-hidden">å¯¾æˆ¦è¨­å®š</h2>
                        <label for="cpu-level">ã‚ãªãŸã®å¯¾æˆ¦ç›¸æ‰‹:</label>
                        <select id="cpu-level">
                            <option value="1">ãƒ¬ãƒ™ãƒ«1 (ãƒ©ãƒ³ãƒ€ãƒ )</option>
                            <option value="2">ãƒ¬ãƒ™ãƒ«2 (æœ€å¤§åè»¢)</option>
                            <option value="3">ãƒ¬ãƒ™ãƒ«3 (å ´æ‰€è©•ä¾¡)</option>
                            <option value="4">ãƒ¬ãƒ™ãƒ«4 (Î±-Î²æ³• å¼±)</option>
                            <option value="5">ãƒ¬ãƒ™ãƒ«5 (Î±-Î²æ³• å¼·)</option>
                            <option value="6">ãƒ¬ãƒ™ãƒ«6 (æ€è€ƒå¼·åŒ–)</option>
                            <option value="7">ãƒ¬ãƒ™ãƒ«7 (å®šçŸ³+æ¢ç´¢)</option>
                            <option value="8" selected>ãƒ¬ãƒ™ãƒ«8 (è¤‡åˆå‹AI)</option>
                            <option value="9">ãƒ¬ãƒ™ãƒ«8+ (ãƒ¬ãƒ™ãƒ«8ï¼‹å¤šæ§˜æ€§)</option>
                            <option value="10">ãƒ¬ãƒ™ãƒ«9 (æœªå®Œæˆ)</option>
                        </select>
                        
                        <div class="start-controls-wrapper">
                            <div class="radio-group" role="radiogroup" aria-label="æ‰‹ç•ªé¸æŠ">
                                <label title="å…ˆæ”» (é»’)">
                                    <input type="radio" name="player_color" value="1" checked>
                                    <span class="disc black"></span>
                                </label>
                                <label title="å¾Œæ”» (ç™½)">
                                    <input type="radio" name="player_color" value="2">
                                    <span class="disc white"></span>
                                </label>
                            </div>
                            <button id="start-button" aria-label="ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™">
                                <img src="https://core-calmdust.github.io/aicoding/images/reversi/play.png" alt="é–‹å§‹">
                            </button>
                        </div>
                    </section>
    
                    <section class="game-info" aria-labelledby="game-status-heading">
                        <h2 id="game-status-heading" class="visually-hidden">ã‚²ãƒ¼ãƒ çŠ¶æ³</h2>
                        <div id="turn-info">
                            <span id="turn-count-label">TURN</span>
                            <span id="turn-count-number">0</span>
                        </div>
                        <div id="score-info">
                            <span class="disc black"></span>
                            <span id="black-score">2</span>
                            <span class="disc white"></span>
                            <span id="white-score">2</span>
                        </div>
                        <div class="action-buttons">
                            <button id="undo-button" disabled>UNDO</button>
                            <button id="research-button" disabled>RESEARCH</button>
                        </div>
                    </section>
    
                    <!-- â˜…â˜…â˜… è©•ä¾¡å€¤ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒ†ãƒŠã¯ã“ã“ã‹ã‚‰ç§»å‹•ã—ã¾ã—ãŸ â˜…â˜…â˜… -->
                </div>
                <div class="game-area">
                    <div id="board"></div>
                </div>
            </div>
            <div id="message-area" role="status" aria-live="polite"></div>

            <!-- â˜…â˜…â˜… è©•ä¾¡å€¤ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒ†ãƒŠã‚’ã“ã“ã«ç§»å‹•ã—ã¾ã—ãŸ â˜…â˜…â˜… -->
            <section id="evaluation-graph-container">
                <div id="current-evaluation-display">
                    <span>è©•ä¾¡å€¤: </span>
                    <span id="evaluation-value-text">N/A</span>
                </div>
                 <div id="evaluation-graph-wrapper-outer">
                    <div id="evaluation-y-axis"></div>
                    <div id="evaluation-graph-wrapper">
                        <div id="evaluation-graph"></div>
                        <div id="evaluation-tooltip"></div>
                    </div>
                </div>
                <div class="kifu-buttons">
                    <button id="kifu-start" disabled aria-label="æœ€åˆã¸"><img src="https://core-calmdust.github.io/aicoding/images/reversi/<<.png" alt="æœ€åˆã¸"></button>
                    <button id="kifu-prev" disabled aria-label="å‰ã¸"><img src="https://core-calmdust.github.io/aicoding/images/reversi/<.png" alt="å‰ã¸"></button>
                    <button id="kifu-next" disabled aria-label="æ¬¡ã¸"><img src="https://core-calmdust.github.io/aicoding/images/reversi/>.png" alt="æ¬¡ã¸"></button>
                    <button id="kifu-end" disabled aria-label="æœ€å¾Œã¸"><img src="https://core-calmdust.github.io/aicoding/images/reversi/>>.png" alt="æœ€å¾Œã¸"></button>
                </div>
            </section>

            <section class="test-controls" aria-labelledby="test-heading">
                <h2 id="test-heading">CPUå¯¾æˆ¦ãƒ†ã‚¹ãƒˆ</h2>
                <div class="test-cpu-selectors">
                    <div class="test-cpu-selector">
                        <label for="cpu1-level">CPU 1 (å…ˆæ”»/é»’)</label>
                        <select id="cpu1-level">
                            <option value="1">ãƒ¬ãƒ™ãƒ«1</option> <option value="2">ãƒ¬ãƒ™ãƒ«2</option> <option value="3">ãƒ¬ãƒ™ãƒ«3</option>
                            <option value="4">ãƒ¬ãƒ™ãƒ«4</option> <option value="5">ãƒ¬ãƒ™ãƒ«5</option> <option value="6">ãƒ¬ãƒ™ãƒ«6</option>
                            <option value="7">ãƒ¬ãƒ™ãƒ«7</option>
                            <option value="8" selected>ãƒ¬ãƒ™ãƒ«8</option>
                            <option value="9">ãƒ¬ãƒ™ãƒ«8+</option>
                            <option value="10">ãƒ¬ãƒ™ãƒ«9</option>
                        </select>
                    </div>
                    <div class="test-cpu-selector">
                        <label for="cpu2-level">CPU 2 (å¾Œæ”»/ç™½)</label>
                        <select id="cpu2-level">
                            <option value="1">ãƒ¬ãƒ™ãƒ«1</option> <option value="2">ãƒ¬ãƒ™ãƒ«2</option> <option value="3">ãƒ¬ãƒ™ãƒ«3</option>
                            <option value="4">ãƒ¬ãƒ™ãƒ«4</option> <option value="5">ãƒ¬ãƒ™ãƒ«5</option> <option value="6">ãƒ¬ãƒ™ãƒ«6</option>
                            <option value="7">ãƒ¬ãƒ™ãƒ«7</option>
                            <option value="8">ãƒ¬ãƒ™ãƒ«8</option>
                            <option value="9" selected>ãƒ¬ãƒ™ãƒ«8+</option>
                            <option value="10">ãƒ¬ãƒ™ãƒ«9</option>
                        </select>
                    </div>
                </div>
                <button id="cpu-vs-cpu-button" aria-label="é¸æŠã—ãŸãƒ¬ãƒ™ãƒ«ã®CPUåŒå£«ã‚’å¯¾æˆ¦ã•ã›ã¾ã™">CPU VS CPU é–‹å§‹</button>
            </section>
        </div>
    </main>

    <div id="modal-overlay">
        <div id="custom-modal">
            <p id="modal-message"></p>
            <div class="modal-buttons">
                <button id="modal-confirm-btn"></button>
                <button id="modal-cancel-btn"></button>
            </div>
        </div>
    </div>

    <script id="research-worker-script" type="javascript/worker">
        const EMPTY = 0, BLACK = 1, WHITE = 2;
        const DIRECTIONS = [ { r: -1, c: -1 }, { r: -1, c: 0 }, { r: -1, c: 1 }, { r: 0, c: -1 }, { r: 0, c: 1 }, { r: 1, c: -1 }, { r: 1, c: 0 }, { r: 1, c: 1 } ];
        const POSITIONAL_SCORE_TABLE = [
            [120, -20,  20,   5,   5,  20, -20, 120],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[  5,  -5,   3,   3,   3,   3,  -5,   5],
            [  5,  -5,   3,   3,   3,   3,  -5,   5],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[120, -20,  20,   5,   5,  20, -20, 120]
        ];
        let continueThinking = false;

        function getFlippableDiscs(currentBoard, r, c, player) {
            const flippable = [];
            if (currentBoard[r][c] !== EMPTY) return flippable;
            const opponent = (player === BLACK) ? WHITE : BLACK;
            for (const dir of DIRECTIONS) {
                const line = []; let currR = r + dir.r, currC = c + dir.c;
                while (currR >= 0 && currR < 8 && currC >= 0 && currC < 8) {
                    if (currentBoard[currR][currC] === opponent) line.push({r: currR, c: currC});
                    else if (currentBoard[currR][currC] === player) { flippable.push(...line); break; } 
                    else break;
                    currR += dir.r; currC += dir.c;
                }
            }
            return flippable;
        }

        function getValidMoves(currentBoard, player) {
            const moves = [];
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                if (currentBoard[r][c] === EMPTY && getFlippableDiscs(currentBoard, r, c, player).length > 0) {
                    moves.push({r, c});
                }
            }
            return moves;
        }
        
        function placeDiscInBoard(b, r, c, player, flippable) {
            b[r][c] = player;
            flippable.forEach(p => { b[p.r][p.c] = player; });
        }

        function evaluateBoard(board, player, level, currentTurn) {
            let score = 0;
            const opponent = (player === BLACK) ? WHITE : BLACK;
            for (let r=0; r<8; r++) for(let c=0; c<8; c++) {
                if(board[r][c]===player) score+=POSITIONAL_SCORE_TABLE[r][c];
                else if(board[r][c]===opponent) score-=POSITIONAL_SCORE_TABLE[r][c];
            }
            if (level < 6) return score;

            const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
            if (level < 8) return score + (mobilityScore * 50);

            let cornerPenalty = 0;
            const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
            const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
            for (let i = 0; i < 4; i++) {
                if (board[corners[i].r][corners[i].c] === EMPTY) {
                    if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 250;
                    if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 250;
                }
            }
            let positionalWeight = 1, mobilityWeight = 80;
            if (currentTurn >= 48) { positionalWeight = 0.5; mobilityWeight = 40; }
            return (score*positionalWeight) + (mobilityScore*mobilityWeight) + cornerPenalty;
        }

        function evaluateByStoneCount(board, player) {
            let score = 0;
            board.flat().forEach(c => { if (c === player) score++; else if (c !== EMPTY) score--; });
            return score * 1000;
        }
        
        function getDepthForLevel(level) {
            if (level <= 4) return 3;
            if (level === 5) return 4;
            if (level === 6) return 5;
            if (level === 7) return 6;
            if (level === 8 || level === 9) return 7;
            return 8;
        }

        function alphaBetaSearch(currentBoard, depth, alpha, beta, isMaximizingNode, maximizingPlayer, level, turnCount) {
            if (depth === 0) return { score: evaluateBoard(currentBoard, maximizingPlayer, level, turnCount) };
            
            const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
            const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
            let validMoves = getValidMoves(currentBoard, playerForThisNode);
            
            if (validMoves.length === 0) {
                if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer) };
                return alphaBetaSearch(currentBoard, depth, alpha, beta, !isMaximizingNode, maximizingPlayer, level, turnCount);
            }
            
            let bestResult = { move: null, score: isMaximizingNode ? -Infinity : Infinity };
            bestResult.move = validMoves[0];

            for (const move of validMoves) {
                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
                const result = alphaBetaSearch(newBoard, depth - 1, alpha, beta, !isMaximizingNode, maximizingPlayer, level, turnCount + 1);
                if (isMaximizingNode) {
                    if (result.score > bestResult.score) bestResult = { move, score: result.score };
                    alpha = Math.max(alpha, bestResult.score);
                } else {
                    if (result.score < bestResult.score) bestResult = { move, score: result.score };
                    beta = Math.min(beta, bestResult.score);
                }
                if (beta <= alpha) break; 
            }
            return bestResult;
        }

        self.onmessage = (e) => {
            const { type, board, playerColor, turnCount, currentEval, maxAiLevel } = e.data;
            if (type === 'stop') {
                continueThinking = false;
                return;
            }
            
            continueThinking = true;
            const validMoves = getValidMoves(board, playerColor);
            
            (async () => {
                for (let level = 5; level <= maxAiLevel; level++) {
                    if (!continueThinking) break;
                    
                    const moveEvals = {};
                    const depth = getDepthForLevel(level);

                    for (const move of validMoves) {
                        if (!continueThinking) break;
                        const tempBoard = JSON.parse(JSON.stringify(board));
                        const flippable = getFlippableDiscs(tempBoard, move.r, move.c, playerColor);
                        placeDiscInBoard(tempBoard, move.r, move.c, playerColor, flippable);
                        
                        const result = alphaBetaSearch(tempBoard, depth, -Infinity, Infinity, false, BLACK, level, turnCount + 1);
                        let diff = result.score - currentEval;
                        if (playerColor === WHITE) diff = -diff;
                        
                        moveEvals[`${move.r},${move.c}`] = diff;
                    }
                    
                    if (continueThinking) {
                        self.postMessage({ type: 'evalUpdate', evaluations: moveEvals });
                    }
                }
            })();
        };
    </script>
    <script>
// ================================================================= //
//                             å®šæ•°ã¨å¤‰æ•°å®šç¾©                         //
// ================================================================= //

const BOARD_SIZE = 8, EMPTY = 0, BLACK = 1, WHITE = 2;
const DIRECTIONS = [ { r: -1, c: -1 }, { r: -1, c: 0 }, { r: -1, c: 1 }, { r: 0, c: -1 }, { r: 0, c: 1 }, { r: 1, c: -1 }, { r: 1, c: 0 }, { r: 1, c: 1 } ];
const MAX_TURNS = 60;
const EVAL_GRAPH_INITIAL_SCALE = 500;
const POSITIONAL_SCORE_TABLE = [
    [120, -20,  20,   5,   5,  20, -20, 120],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[  5,  -5,   3,   3,   3,   3,  -5,   5],
    [  5,  -5,   3,   3,   3,   3,  -5,   5],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[120, -20,  20,   5,   5,  20, -20, 120]
];
const OPENING_BOOK = {
    "0000000000000000000000000001200000021000000000000000000000000000": {r:4, c:5},"0000000000000000000000000012100000012000000000000000000000000000": {r:5, c:5},
    "0000000000000000000000000002100000012100000000000000000000000000": {r:2, c:3},"0000000000000000000001000001210000021100000000000000000000000000": {r:2, c:2},
    "0000000000000000000000000011200000012000000000000000000000000000": {r:5, c:2},"000000000000000000000000000210000001110000000000000000000000000": {r:5, c:3},
};

const boardEl = document.getElementById('board');
const blackScoreEl = document.getElementById('black-score');
const whiteScoreEl = document.getElementById('white-score');
const turnCountNumberEl = document.getElementById('turn-count-number');
const messageAreaEl = document.getElementById('message-area');
const cpuLevelSelect = document.getElementById('cpu-level');
const startButton = document.getElementById('start-button');
const playerColorRadios = document.querySelectorAll('input[name="player_color"]');
const cpu1LevelSelect = document.getElementById('cpu1-level');
const cpu2LevelSelect = document.getElementById('cpu2-level');
const cpuVsCpuButton = document.getElementById('cpu-vs-cpu-button');
const kifuStartBtn = document.getElementById('kifu-start');
const kifuPrevBtn = document.getElementById('kifu-prev');
const kifuNextBtn = document.getElementById('kifu-next');
const kifuEndBtn = document.getElementById('kifu-end');
const evaluationValueTextEl = document.getElementById('evaluation-value-text');
const undoButton = document.getElementById('undo-button');
const researchButton = document.getElementById('research-button');
const modalOverlay = document.getElementById('modal-overlay');
const modalMessage = document.getElementById('modal-message');
const modalConfirmBtn = document.getElementById('modal-confirm-btn');
const modalCancelBtn = document.getElementById('modal-cancel-btn');

let board, currentPlayer, turnCount, lastMove, playerColor, cpuColor;
let isCpuVsCpuMode = false, isGameOver = false, isPlaybackMode = false;
let isGameInProgress = false;
let wasUndo = false;
let gameHistory = [], playbackIndex = 0, evaluationHistory = [];
let isDraggingGraph = false, lastHoveredTurn = -1;
let undoCount = 0;
let isResearchMode = false;
let researchEvaluations = {};
const maxAiLevel = 10;

const workerScript = document.getElementById('research-worker-script').textContent;
const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
const researchWorker = new Worker(URL.createObjectURL(workerBlob));

researchWorker.onmessage = (e) => {
    if (isResearchMode && e.data.type === 'evalUpdate') {
        researchEvaluations = { ...researchEvaluations, ...e.data.evaluations };
        renderBoard();
    }
};

// ================================================================= //
//                      ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ (ã‚²ãƒ¼ãƒ é€²è¡Œç®¡ç†)                 //
// ================================================================= //

function resetGame() {
    isGameInProgress = false;
    isCpuVsCpuMode = false;
    isPlaybackMode = false;
    isGameOver = false;
    researchWorker.postMessage({ type: 'stop' });
    if(isResearchMode) researchButton.click();

    undoCount = 0;
    document.body.classList.remove('game-over', 'graph-dragging');

    board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
    board[3][3] = WHITE; board[3][4] = BLACK;
    board[4][3] = BLACK; board[4][4] = WHITE;
    
    currentPlayer = BLACK;
    turnCount = 0;
    lastMove = null;
    gameHistory = [{ move: null, boardState: JSON.parse(JSON.stringify(board)) }];
    evaluationHistory = [];
    playbackIndex = 0;
    
    renderBoard();
    renderEvaluationGraph();
    updateEvaluationDisplay(null);
    updateUiState();
    updateGameInfo();
}

function startGame(isTestMode) {
    isGameInProgress = true;
    isCpuVsCpuMode = isTestMode;
    isGameOver = false;
    
    gameController();
}

function interruptGame() {
    isGameInProgress = false;
    isCpuVsCpuMode = false;
    researchWorker.postMessage({ type: 'stop' });
    messageAreaEl.textContent = 'ã‚²ãƒ¼ãƒ ã‚’ä¸­æ–­ã—ã¾ã—ãŸ';
    updateUiState();
}

function resumeGame() {
    isGameInProgress = true;
    gameController();
}

function startCpuVsCpuFromCurrentState() {
    isGameInProgress = true;
    isCpuVsCpuMode = true;
    isGameOver = false;
    gameController();
}

async function gameController() {
    if (!isGameInProgress || isGameOver) return;
    
    updateUiState();
    updateGameInfo();
    
    const isPlayerTurn = !isCpuVsCpuMode && currentPlayer === playerColor;
    if (isResearchMode && isPlayerTurn) {
        runShallowResearch();
        renderBoard();
        const currentEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : 0;
        researchWorker.postMessage({
            type: 'start', board, playerColor, turnCount, currentEval, maxAiLevel
        });
    } else {
        renderBoard();
    }

    const canCurrentPlayerMove = getValidMoves(board, currentPlayer).length > 0;
    if (!canCurrentPlayerMove) {
        const opponent = (currentPlayer === BLACK) ? WHITE : BLACK;
        const canOpponentMove = getValidMoves(board, opponent).length > 0;
        
        if (!canOpponentMove) {
            endGame();
            return;
        }
        
        messageAreaEl.textContent = `${currentPlayer === BLACK ? 'é»’' : 'ç™½'}ã¯ãƒ‘ã‚¹ã—ã¾ã™ã€‚`;
        await new Promise(resolve => setTimeout(resolve, 1000));
        currentPlayer = opponent;
        gameController();
        return;
    }

    const isCpuTurnNow = isCpuVsCpuMode || (currentPlayer === cpuColor);
    if (isCpuTurnNow) {
        await executeCpuTurn();
    }
}

function endGame() {
    isGameOver = true;
    isGameInProgress = false;
    researchWorker.postMessage({ type: 'stop' });
    document.body.classList.add('game-over');
    
    const blackScore = board.flat().filter(c => c === BLACK).length;
    const whiteScore = board.flat().filter(c => c === WHITE).length;
    const winner = (blackScore > whiteScore) ? BLACK : ((whiteScore > blackScore) ? WHITE : EMPTY);
    
    let message = "å¼•ãåˆ†ã‘ã§ã™ï¼";
    if (winner !== EMPTY) {
        if (isCpuVsCpuMode) message = `CPU ${(winner === BLACK ? '1' : '2')} ã®å‹ã¡ã§ã™ã€‚`;
        else message = (winner === playerColor) ? "ğŸ‰ ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ ğŸ‰" : "CPUã®å‹ã¡ã§ã™ã€‚";
    }
    if (!isCpuVsCpuMode && undoCount > 0) {
        message += ` (å¾…ã£ãŸã®ä½¿ç”¨å›æ•°: ${undoCount}å›)`;
    }
    messageAreaEl.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ ${message}`;
    updateUiState();
    updateGameInfo();
    renderEvaluationGraph();
}

// ================================================================= //
//                         UIãƒ»æç”»é–¢é€£                             //
// ================================================================= //

function renderBoard() {
    boardEl.innerHTML = '';
    const validMoves = (isGameInProgress && !isCpuVsCpuMode && !isPlaybackMode && currentPlayer === playerColor && !isGameOver) 
        ? getValidMoves(board, currentPlayer) : [];
    
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';

            if (board[r][c] !== EMPTY) {
                const disc = document.createElement('div');
                disc.className = `disc ${board[r][c] === BLACK ? 'black' : 'white'}`;
                cell.appendChild(disc);
            } else {
                const validMove = validMoves.find(m => m.r === r && m.c === c);
                if (validMove) {
                    const evalForMove = researchEvaluations[`${r},${c}`];
                    if (isResearchMode && evalForMove !== undefined) {
                        const valueSpan = document.createElement('span');
                        valueSpan.className = 'research-value';
                        valueSpan.textContent = (evalForMove > 0 ? '+' : '') + Math.round(evalForMove);
                        valueSpan.classList.add(evalForMove >= 0 ? 'plus' : 'minus');
                        cell.appendChild(valueSpan);
                    } else {
                        cell.classList.add('valid-move-hint');
                    }
                }
            }
            if (lastMove && lastMove.r === r && lastMove.c === c) {
                cell.classList.add('last-move');
            }
            cell.addEventListener('click', () => handleCellClick(r, c));
            boardEl.appendChild(cell);
        }
    }
}

function updateGameInfo() {
    let blackScore = 0, whiteScore = 0;
    const currentBoard = isPlaybackMode ? JSON.parse(JSON.stringify(gameHistory[playbackIndex].boardState)) : board;
    currentBoard.flat().forEach(cell => {
        if (cell === BLACK) blackScore++;
        if (cell === WHITE) whiteScore++;
    });
    blackScoreEl.textContent = blackScore;
    whiteScoreEl.textContent = whiteScore;
    
    const displayTurn = isPlaybackMode ? playbackIndex : turnCount;
    turnCountNumberEl.textContent = displayTurn;
    
    if (isGameOver) return;

    let message = '';
    if (isPlaybackMode) {
         message = `æ£‹è­œå†ç”Ÿä¸­ (${displayTurn}æ‰‹ç›®)`;
    } else if (isGameInProgress) {
        if (isCpuVsCpuMode) {
             message = `${turnCount + 1}æ‰‹ç›®: CPU ${currentPlayer === BLACK ? '1' : '2'}ã®ã‚¿ãƒ¼ãƒ³ã§ã™`;
        } else {
             message = `${turnCount + 1}æ‰‹ç›®: ${currentPlayer === playerColor ? 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™' : 'CPUã®ã‚¿ãƒ¼ãƒ³ã§ã™'}`;
        }
    } else if (turnCount > 0) {
        message = 'ä¸­æ–­ä¸­...';
    } else {
         message = 'å¯¾æˆ¦è¨­å®šã‚’é¸ã‚“ã§é–‹å§‹ã—ã¦ãã ã•ã„';
    }

    if (wasUndo) {
        messageAreaEl.textContent = 'å¾…ã£ãŸï¼ ' + message;
        wasUndo = false;
    } else {
        messageAreaEl.textContent = message;
    }
}

function updateUiState() {
    playerColor = parseInt(document.querySelector('input[name="player_color"]:checked').value, 10);
    cpuColor = (playerColor === BLACK) ? WHITE : BLACK;
    
    const startButtonImg = startButton.querySelector('img');

    if (isGameInProgress && !isGameOver) {
        startButtonImg.src = 'https://core-calmdust.github.io/aicoding/images/reversi/stop.png';
        startButtonImg.alt = 'ä¸­æ–­';
        startButton.setAttribute('aria-label', 'ã‚²ãƒ¼ãƒ ã‚’ä¸­æ–­ã—ã¾ã™');
    } else {
        startButtonImg.src = 'https://core-calmdust.github.io/aicoding/images/reversi/play.png';
        startButtonImg.alt = 'é–‹å§‹';
        startButton.setAttribute('aria-label', 'ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™');
    }
    
    // â˜…â˜…â˜… ä¿®æ­£ç‚¹1: UIãƒ­ãƒƒã‚¯ã®æ¡ä»¶ã‚’å¤‰æ›´ â˜…â˜…â˜…
    // ã‚²ãƒ¼ãƒ ãŒé€²è¡Œä¸­ã§ãªã„é™ã‚Šã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
    const controlsLocked = isGameInProgress && !isGameOver;
    cpuLevelSelect.disabled = controlsLocked;
    playerColorRadios.forEach(radio => { radio.disabled = controlsLocked; });
    cpuVsCpuButton.disabled = controlsLocked;
    
    const isPlayerTurn = isGameInProgress && !isCpuVsCpuMode && currentPlayer === playerColor;
    undoButton.disabled = !isPlayerTurn || turnCount < 2;
    // researchButtonã¯ã‚²ãƒ¼ãƒ ä¸­ã§ãªã„ã¨æŠ¼ã›ãªã„ã‚ˆã†ã«ã™ã‚‹
    researchButton.disabled = isCpuVsCpuMode || !(isGameInProgress && !isGameOver);
    
    const kifuActive = isGameOver || isPlaybackMode;
    kifuStartBtn.disabled = !kifuActive || playbackIndex === 0;
    kifuPrevBtn.disabled = !kifuActive || playbackIndex === 0;
    kifuNextBtn.disabled = !kifuActive || playbackIndex >= gameHistory.length - 1;
    kifuEndBtn.disabled = !kifuActive || playbackIndex >= gameHistory.length - 1;
}

function updateEvaluationDisplay(score) {
    if (score === null || score === undefined) {
        evaluationValueTextEl.textContent = "N/A";
    } else {
        const scoreText = (score > 0 ? '+' : '') + score.toFixed(0);
        evaluationValueTextEl.textContent = scoreText;
    }
}

function renderEvaluationGraph() {
    const graphEl = document.getElementById('evaluation-graph');
    const yAxisEl = document.getElementById('evaluation-y-axis');
    const tooltipEl = document.getElementById('evaluation-tooltip');
    if (!graphEl || !yAxisEl || !tooltipEl) return;

    graphEl.innerHTML = '';
    const maxAbsValue = evaluationHistory.length > 0 ? Math.max(...evaluationHistory.map(v => Math.abs(v))) : 0;
    const scale = Math.max(EVAL_GRAPH_INITIAL_SCALE, Math.ceil(maxAbsValue / 100) * 100);
    yAxisEl.innerHTML = `<span>+${scale}</span><span>-${scale}</span>`;

    for (let i = 0; i < MAX_TURNS; i++) {
        const barContainer = document.createElement('div');
        barContainer.className = 'bar-container';

        if (isPlaybackMode && i === playbackIndex - 1) {
            barContainer.classList.add('current-turn-highlight');
        }

        if (i < evaluationHistory.length) {
            const value = evaluationHistory[i];
            const bar = document.createElement('div');
            bar.className = 'bar';
            const heightPercentage = Math.min((Math.abs(value) / scale) * 100, 100);
            bar.style.height = `${heightPercentage / 2}%`;
            if (value > 0) bar.classList.add('black');
            else if (value < 0) bar.classList.add('white');
            barContainer.appendChild(bar);

            barContainer.addEventListener('mouseover', () => {
                tooltipEl.style.display = 'block';
                tooltipEl.textContent = `Turn ${i + 1}: ${value > 0 ? '+' : ''}${value.toFixed(0)}`;
                const wrapperRect = graphEl.parentElement.getBoundingClientRect();
                const barRect = barContainer.getBoundingClientRect();
                tooltipEl.style.left = `${barRect.left - wrapperRect.left + barRect.width / 2}px`;
                tooltipEl.style.top = `${barRect.top - wrapperRect.top}px`;
            });
            barContainer.addEventListener('mouseleave', () => {
                tooltipEl.style.display = 'none';
            });
        }
        graphEl.appendChild(barContainer);
    }
}

function runShallowResearch() {
    researchEvaluations = {};
    const isPlayerTurn = isGameInProgress && !isCpuVsCpuMode && currentPlayer === playerColor;
    if (!isPlayerTurn) return;

    const validMoves = getValidMoves(board, playerColor);
    const currentEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : 0;
    
    for (const move of validMoves) {
        const tempBoard = JSON.parse(JSON.stringify(board));
        const flippable = getFlippableDiscs(tempBoard, move.r, move.c, playerColor);
        placeDiscInBoard(tempBoard, move.r, move.c, playerColor, flippable);
        
        const result = alphaBetaSearch(tempBoard, 3, -Infinity, Infinity, false, BLACK, 4, turnCount + 1);
        let diff = result.score - currentEval;
        if (playerColor === WHITE) diff = -diff;
        researchEvaluations[`${move.r},${c}`] = diff;
    }
}

// ================================================================= //
//                        ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ»ãƒªã‚¹ãƒŠãƒ¼                   //
// ================================================================= //

function handleCellClick(r, c) {
    if (!isGameInProgress || isCpuVsCpuMode || isPlaybackMode || currentPlayer !== playerColor || board[r][c] !== EMPTY) return;
    
    const flippable = getFlippableDiscs(board, r, c, playerColor);
    if (flippable.length === 0) return;
    
    researchWorker.postMessage({ type: 'stop' });
    researchEvaluations = {};

    placeDisc(r, c, playerColor, flippable);
    currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
    gameController();
}

function renderPlayback(index) {
    isPlaybackMode = true;
    isGameInProgress = false;
    researchWorker.postMessage({ type: 'stop' });
    playbackIndex = Math.max(0, Math.min(index, gameHistory.length - 1));
    const record = gameHistory[playbackIndex];
    board = JSON.parse(JSON.stringify(record.boardState));
    lastMove = record.move;
    
    const score = playbackIndex > 0 ? evaluationHistory[playbackIndex - 1] : null;
    updateEvaluationDisplay(score);
    
    updateUiState();
    updateGameInfo();
    renderBoard();
    renderEvaluationGraph();
}

function handleGraphScrub(event) {
    event.preventDefault();
    if (!isGameOver || !isDraggingGraph) return;

    // â˜…â˜…â˜… ä¿®æ­£ç‚¹2: åº§æ¨™è¨ˆç®—ã®åŸºæº–ã‚’ã‚°ãƒ©ãƒ•æœ¬ä½“ã«å¤‰æ›´ â˜…â˜…â˜…
    const graphEl = document.getElementById('evaluation-graph');
    const graphRect = graphEl.getBoundingClientRect();
    
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const relativeX = clientX - graphRect.left;
    
    let progress = relativeX / graphRect.width;
    progress = Math.max(0, Math.min(1, progress));

    const maxTurn = gameHistory.length - 1;
    let turn = Math.round(progress * maxTurn);
    turn = Math.max(0, Math.min(turn, maxTurn));

    if (turn !== lastHoveredTurn) {
        lastHoveredTurn = turn;
        renderPlayback(turn);
    }
}

// â˜…â˜…â˜… ä¿®æ­£ç‚¹2: ã‚°ãƒ©ãƒ•ã®ã‚¹ãƒ©ã‚¤ãƒ‰æ“ä½œé–¢é€£ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ä¿®æ­£ãƒ»é›†ç´„ â˜…â˜…â˜…
const graphEl = document.getElementById('evaluation-graph'); // å¯¾è±¡ã‚’ã‚°ãƒ©ãƒ•æœ¬ä½“ã«å¤‰æ›´

const onGraphMove = (event) => {
    if (isDraggingGraph) {
        handleGraphScrub(event);
    }
};

const stopGraphScrub = () => {
    if (!isDraggingGraph) return;
    isDraggingGraph = false;
    document.body.classList.remove('graph-dragging');
    lastHoveredTurn = -1;
    
    window.removeEventListener('mousemove', onGraphMove);
    window.removeEventListener('mouseup', stopGraphScrub);
    
    window.removeEventListener('touchmove', onGraphMove);
    window.removeEventListener('touchend', stopGraphScrub);
};

// ãƒã‚¦ã‚¹æ“ä½œç”¨ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
graphEl.addEventListener('mousedown', (event) => {
    if (!isGameOver) return;
    isDraggingGraph = true;
    document.body.classList.add('graph-dragging');
    handleGraphScrub(event);
    window.addEventListener('mousemove', onGraphMove);
    window.addEventListener('mouseup', stopGraphScrub);
});

// ã‚¿ãƒƒãƒæ“ä½œç”¨ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
graphEl.addEventListener('touchstart', (event) => {
    if (!isGameOver) return;
    isDraggingGraph = true;
    document.body.classList.add('graph-dragging');
    handleGraphScrub(event);
    // passive: false ã§ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æŠ‘åˆ¶ã—ã€ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œã‚’å„ªå…ˆ
    window.addEventListener('touchmove', onGraphMove, { passive: false });
    window.addEventListener('touchend', stopGraphScrub);
}, { passive: false });


function showModal(message, confirmText, cancelText, onConfirm, onCancel) {
    modalMessage.innerHTML = message;
    modalConfirmBtn.textContent = confirmText;
    modalCancelBtn.textContent = cancelText;

    modalConfirmBtn.onclick = () => {
        hideModal();
        onConfirm();
    };
    modalCancelBtn.onclick = () => {
        hideModal();
        onCancel();
    };

    modalOverlay.classList.add('visible');
}

function hideModal() {
    modalOverlay.classList.remove('visible');
}

startButton.addEventListener('click', () => {
    if (isGameInProgress) {
        interruptGame();
    } else {
        if(turnCount > 0 && !isGameOver) {
            showModal('ã‚²ãƒ¼ãƒ ã‚’å†é–‹ã—ã¾ã™ã‹ï¼Ÿ<br>ãã‚Œã¨ã‚‚æœ€åˆã‹ã‚‰å§‹ã‚ã¾ã™ã‹ï¼Ÿ', 'å†é–‹', 'æœ€åˆã‹ã‚‰', 
                () => resumeGame(), 
                () => { resetGame(); startGame(false); }
            );
        } else {
            resetGame();
            startGame(false);
        }
    }
});

cpuVsCpuButton.addEventListener('click', () => {
    if (isGameInProgress || isPlaybackMode) return;
    if(turnCount > 0 && !isGameOver) {
         showModal('CPUæˆ¦ã‚’æœ€åˆã‹ã‚‰å§‹ã‚ã¾ã™ã‹ï¼Ÿ<br>ãã‚Œã¨ã‚‚ä»Šã®å±€é¢ã‹ã‚‰è¡Œã„ã¾ã™ã‹ï¼Ÿ', 'æœ€åˆã‹ã‚‰', 'ã“ã®å±€é¢ã‹ã‚‰',
            () => { resetGame(); startGame(true); },
            () => startCpuVsCpuFromCurrentState()
        );
    } else {
        resetGame();
        startGame(true);
    }
});

kifuStartBtn.addEventListener('click', () => { if (!kifuStartBtn.disabled) renderPlayback(0); });
kifuPrevBtn.addEventListener('click', () => { if (!kifuPrevBtn.disabled) renderPlayback(playbackIndex - 1); });
kifuNextBtn.addEventListener('click', () => { if (!kifuNextBtn.disabled) renderPlayback(playbackIndex + 1); });
kifuEndBtn.addEventListener('click', () => { if (!kifuEndBtn.disabled) renderPlayback(gameHistory.length - 1); });

undoButton.addEventListener('click', () => {
    if (undoButton.disabled) return;
    gameHistory.splice(-2, 2);
    evaluationHistory.splice(-2, 2);
    turnCount -= 2;
    undoCount++;
    wasUndo = true;

    const lastState = gameHistory[gameHistory.length - 1];
    board = JSON.parse(JSON.stringify(lastState.boardState));
    lastMove = lastState.move;
    currentPlayer = playerColor;
    
    const lastEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : null;
    updateEvaluationDisplay(lastEval);

    gameController();
});

researchButton.addEventListener('click', () => {
    if (researchButton.disabled) return;
    isResearchMode = !isResearchMode;
    researchButton.classList.toggle('active', isResearchMode);
    researchEvaluations = {};

    if (isResearchMode) {
        const isPlayerTurn = isGameInProgress && !isCpuVsCpuMode && currentPlayer === playerColor;
        if (isPlayerTurn) {
            runShallowResearch();
            const currentEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : 0;
            researchWorker.postMessage({
                type: 'start', board, playerColor, turnCount, currentEval, maxAiLevel
            });
        }
    } else {
        researchWorker.postMessage({ type: 'stop' });
    }
    renderBoard();
});

playerColorRadios.forEach(radio => {
    radio.addEventListener('change', () => {
        if (!isGameInProgress) updateUiState();
    });
});

document.addEventListener('keydown', (event) => {
    if (isPlaybackMode || isGameOver) {
        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(event.key)) {
            event.preventDefault();
        }
        if (event.key === 'ArrowLeft' && !kifuPrevBtn.disabled) kifuPrevBtn.click();
        else if (event.key === 'ArrowRight' && !kifuNextBtn.disabled) kifuNextBtn.click();
        else if (event.key === 'ArrowDown' && !kifuStartBtn.disabled) kifuStartBtn.click();
        else if (event.key === 'ArrowUp' && !kifuEndBtn.disabled) kifuEndBtn.click();
    }
});

// ================================================================= //
//                         AIæ€è€ƒãƒ­ã‚¸ãƒƒã‚¯ (ã‚³ã‚¢)                      //
// ================================================================= //

async function executeCpuTurn() {
    if (!isGameInProgress) return;

    const currentAiPlayer = isCpuVsCpuMode ? currentPlayer : cpuColor;
    const currentAiLevel = isCpuVsCpuMode 
        ? (currentAiPlayer === BLACK ? parseInt(cpu1LevelSelect.value, 10) : parseInt(cpu2LevelSelect.value, 10))
        : parseInt(cpuLevelSelect.value, 10);

    messageAreaEl.textContent = 'CPUãŒæ€è€ƒä¸­ã§ã™...';
    await new Promise(resolve => setTimeout(resolve, 50));
    
    const move = findBestMove(currentAiPlayer, currentAiLevel);
    
    if (!isGameInProgress) return;

    if (move) {
        const flippable = getFlippableDiscs(board, move.r, move.c, currentAiPlayer);
        placeDisc(move.r, move.c, currentAiPlayer, flippable);
    }
    currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
    
    gameController();
}

function findBestMove(aiPlayer, aiLevel) {
    const validMoves = getValidMoves(board, aiPlayer);
    if (validMoves.length === 0) return null;
    if (aiLevel >= 7) {
        const bookMove = OPENING_BOOK[boardToString(board)];
        if (bookMove && validMoves.some(m => m.r === bookMove.r && m.c === bookMove.c)) {
            if ((aiLevel === 9 || aiLevel === 10) && Math.random() < 0.5) {} else { return bookMove; }
        }
    }
    const emptyCells = MAX_TURNS - turnCount;
    switch (aiLevel) {
        case 1: return validMoves[Math.floor(Math.random() * validMoves.length)];
        case 2: return validMoves.reduce((best, move) => { const count = getFlippableDiscs(board, move.r, move.c, aiPlayer).length; return count > best.count ? { move, count } : best; }, { move: validMoves[0], count: 0 }).move;
        case 3: return validMoves.reduce((best, move) => { const score = POSITIONAL_SCORE_TABLE[move.r][move.c]; return score > best.score ? { move, score } : best; }, { move: null, score: -Infinity }).move;
        case 4: return alphaBetaSearch(board, 3, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
        case 5: return alphaBetaSearch(board, 4, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
        case 6: return alphaBetaSearch(board, 5, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
        case 7: { let d = (emptyCells > 24) ? 5 : ((emptyCells > 14) ? 6 : 8); return alphaBetaSearch(board, d, -Infinity, Infinity, true, aiPlayer, aiLevel).move; }
        case 8: {
            if (emptyCells <= 12) { messageAreaEl.textContent = 'CPUãŒå®Œå…¨èª­ã¿ã«ç§»è¡Œ...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
            let depth = (emptyCells > 22) ? 6 : 7; return alphaBetaSearch(board, depth, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
        }
        case 9: {
            if (emptyCells <= 12) { messageAreaEl.textContent = 'CPUãŒå®Œå…¨èª­ã¿ã«ç§»è¡Œ...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
            let depth = (emptyCells > 22) ? 6 : 7; return findBestMoveWithVariety(board, depth, aiPlayer, 8);
        }
        case 10: {
            if (emptyCells <= 14) { messageAreaEl.textContent = 'CPUãŒå®Œå…¨èª­ã¿ã«ç§»è¡Œ...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
            let depth = (emptyCells > 24) ? 8 : 9; return findBestMoveWithVariety(board, depth, aiPlayer, 10);
        }
        default: return validMoves[0];
    }
}

function findBestMoveWithVariety(currentBoard, depth, aiPlayer, level) {
    const validMoves = getValidMoves(currentBoard, aiPlayer);
    const moveEvals = [];
    for (const move of validMoves) {
        const newBoard = JSON.parse(JSON.stringify(currentBoard));
        placeDiscInBoard(newBoard, move.r, move.c, aiPlayer, getFlippableDiscs(newBoard, move.r, move.c, aiPlayer));
        const result = alphaBetaSearch(newBoard, depth - 1, -Infinity, Infinity, false, aiPlayer, level);
        moveEvals.push({ move, score: result.score });
    }
    if (moveEvals.length === 0) return null;
    const bestScore = Math.max(...moveEvals.map(e => e.score));
    const threshold = 50; 
    const bestMoves = moveEvals.filter(e => e.score >= bestScore - threshold);
    if (bestMoves.length > 0) return bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
    return moveEvals.reduce((best, current) => current.score > best.score ? current : best).move;
}

function alphaBetaSearch(currentBoard, depth, alpha, beta, isMaximizingNode, maximizingPlayer, currentLevel) {
    const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
    if (depth === 0 || emptyCells === 0) return { score: evaluateBoard(currentBoard, maximizingPlayer, currentLevel, 60 - emptyCells) };
    const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
    const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
    let validMoves = getValidMoves(currentBoard, playerForThisNode);
    
    if (validMoves.length === 0) {
        if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, true) };
        return alphaBetaSearch(currentBoard, depth, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel);
    }
    
    let bestResult = { move: null, score: isMaximizingNode ? -Infinity : Infinity };
    if (depth >= 4 && currentLevel >= 8) {
        const moveScores = validMoves.map(move => {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
            return { move, score: evaluateBoard(newBoard, maximizingPlayer, currentLevel, 60 - emptyCells + 1) };
        });
        if (isMaximizingNode) moveScores.sort((a, b) => b.score - a.score);
        else moveScores.sort((a, b) => a.score - b.score);
        validMoves = moveScores.map(ms => ms.move);
    }
    bestResult.move = validMoves[0]; 

    for (const move of validMoves) {
        const newBoard = JSON.parse(JSON.stringify(currentBoard));
        placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
        const result = alphaBetaSearch(newBoard, depth - 1, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel);
        if (isMaximizingNode) {
            if (result.score > bestResult.score) bestResult = { move, score: result.score };
            alpha = Math.max(alpha, bestResult.score);
        } else {
            if (result.score < bestResult.score) bestResult = { move, score: result.score };
            beta = Math.min(beta, bestResult.score);
        }
        if (beta <= alpha) break; 
    }
    return bestResult;
}

function perfectSearch(currentBoard, alpha, beta, isMaximizingNode, maximizingPlayer) {
    const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
    if (emptyCells === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, false) };
    const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
    const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
    const validMoves = getValidMoves(currentBoard, playerForThisNode);
    if (validMoves.length === 0) {
        if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, false) };
        return perfectSearch(currentBoard, alpha, beta, !isMaximizingNode, maximizingPlayer);
    }
    let bestResult = { move: validMoves[0], score: isMaximizingNode ? -Infinity : Infinity };
    for (const move of validMoves) {
        const newBoard = JSON.parse(JSON.stringify(currentBoard));
        placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
        const result = perfectSearch(newBoard, alpha, beta, !isMaximizingNode, maximizingPlayer);
        if (isMaximizingNode) {
            if (result.score > bestResult.score) bestResult = { move, score: result.score };
            alpha = Math.max(alpha, bestResult.score);
        } else {
            if (result.score < bestResult.score) bestResult = { move, score: result.score };
            beta = Math.min(beta, bestResult.score);
        }
        if (beta <= alpha) break;
    }
    return bestResult;
}

// ================================================================= //
//                           AIè©•ä¾¡é–¢æ•°                             //
// ================================================================= //

function evaluateBoard(board, player, level, currentTurn) {
    if (level >= 8) return evaluateBoardForLevel8(board, player, currentTurn);
    if (level >= 6) return advancedPositionalEvaluation(board, player);
    return simplePositionalEvaluation(board, player);
}

function simplePositionalEvaluation(board, player) {
    let score = 0;
    const opponent = (player === BLACK) ? WHITE : BLACK;
    for (let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) {
        if(board[r][c]===player) score+=POSITIONAL_SCORE_TABLE[r][c];
        else if(board[r][c]===opponent) score-=POSITIONAL_SCORE_TABLE[r][c];
    }
    return score;
}

function advancedPositionalEvaluation(board, player) {
    const opponent = (player === BLACK) ? WHITE : BLACK;
    const positionalScore = simplePositionalEvaluation(board, player);
    const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
    const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
    return positionalScore + (mobilityScore * 50) + (fixedDiscScore * 150);
}

function evaluateBoardForLevel8(board, player, currentTurn) {
    const opponent = (player === BLACK) ? WHITE : BLACK;
    const positionalScore = simplePositionalEvaluation(board, player);
    const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
    const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
    let cornerPenalty = 0;
    const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
    const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
    for (let i = 0; i < 4; i++) {
        if (board[corners[i].r][corners[i].c] === EMPTY) {
            if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 250;
            if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 250;
        }
    }
    let positionalWeight, mobilityWeight, fixedDiscWeight;
    if (currentTurn < 20) { positionalWeight=1; mobilityWeight=80; fixedDiscWeight=120; } 
    else if (currentTurn < 48) { positionalWeight=1; mobilityWeight=60; fixedDiscWeight=180; } 
    else { positionalWeight=0.5; mobilityWeight=40; fixedDiscWeight=250; }
    return (positionalScore*positionalWeight) + (mobilityScore*mobilityWeight) + (fixedDiscScore*fixedDiscWeight) + cornerPenalty;
}

function evaluateByStoneCount(board, player, isFromAlphaBeta) {
    let score = 0;
    board.flat().forEach(c => { if (c === player) score++; else if (c !== EMPTY) score--; });
    return isFromAlphaBeta ? score * 1000 : score;
}

// ================================================================= //
//                       ãƒ«ãƒ¼ãƒ«ãƒ»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°                      //
// ================================================================= //

function placeDisc(r, c, player, flippable) {
    board[r][c] = player;
    flippable.forEach(pos => { board[pos.r][pos.c] = player; });
    lastMove = { r, c };
    turnCount++;
    gameHistory.push({ move: { r, c }, boardState: JSON.parse(JSON.stringify(board)) });
    
    if (!isPlaybackMode) {
        const score = evaluateBoard(board, BLACK, parseInt(cpuLevelSelect.value, 10), turnCount);
        evaluationHistory.push(score);
        updateEvaluationDisplay(score);
        renderEvaluationGraph();
    }
    playbackIndex = gameHistory.length - 1;
}

function placeDiscInBoard(b, r, c, player, flippable) {
    b[r][c] = player;
    flippable.forEach(p => { b[p.r][p.c] = player; });
}

function getFlippableDiscs(currentBoard, r, c, player) {
    const flippable = [];
    if (currentBoard[r][c] !== EMPTY) return flippable;
    const opponent = (player === BLACK) ? WHITE : BLACK;
    for (const dir of DIRECTIONS) {
        const line = [];
        let currR = r + dir.r, currC = c + dir.c;
        while (currR >= 0 && currR < BOARD_SIZE && currC >= 0 && currC < BOARD_SIZE) {
            if (currentBoard[currR][currC] === opponent) line.push({r: currR, c: currC});
            else if (currentBoard[currR][currC] === player) { flippable.push(...line); break; } 
            else break;
            currR += dir.r; currC += dir.c;
        }
    }
    return flippable;
}

function getValidMoves(currentBoard, player) {
    const moves = [];
    for (let r=0; r<BOARD_SIZE; r++) for (let c=0; c<BOARD_SIZE; c++) {
        if (currentBoard[r][c] === EMPTY && getFlippableDiscs(currentBoard, r, c, player).length > 0) {
            moves.push({r, c});
        }
    }
    return moves;
}

function getStableDiscs(board, player) {
    const stable = Array.from({length: 8}, () => Array(8).fill(false));
    const directions = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]];
    if (board[0][0] === player) stable[0][0] = true; if (board[0][7] === player) stable[0][7] = true;
    if (board[7][0] === player) stable[7][0] = true; if (board[7][7] === player) stable[7][7] = true;
    let changed = true;
    while(changed) {
        changed = false;
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
            if(board[r][c] === player && !stable[r][c]) {
                let isStable = true;
                for(let i=0; i<4; i++) {
                    const [d1r,d1c]=directions[i*2], [d2r,d2c]=directions[i*2+1];
                    let line1_filled = true, line2_filled = true;
                    let nr = r + d1r, nc = c + d1c;
                    while(nr>=0&&nr<8&&nc>=0&&nc<8) { if(board[nr][nc]!==player&&!stable[nr][nc]){line1_filled=false;break;} nr+=d1r; nc+=d1c; }
                    nr = r + d2r, nc = c + d2c;
                    while(nr>=0&&nr<8&&nc>=0&&nc<8) { if(board[nr][nc]!==player&&!stable[nr][nc]){line2_filled=false;break;} nr+=d2r; nc+=d2c; }
                    if (!line1_filled && !line2_filled) { isStable=false; break; }
                }
                if(isStable) { stable[r][c] = true; changed = true; }
            }
        }
    }
    const stableDiscs = [];
    for (let r=0; r<8; r++) for(let c=0; c<8; c++) if(stable[r][c]) stableDiscs.push({r,c});
    return stableDiscs;
}

function boardToString(b) {
    return b.flat().join('');
}

// --- ã‚²ãƒ¼ãƒ ã®åˆå›èµ·å‹• ---
resetGame();
    </script>
</body>
</html>
