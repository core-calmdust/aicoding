<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    
    <title>【強力AI搭載】無料で遊べるリバーシ（オセロ）ゲーム - ブラウザで今すぐ対戦！</title>
    <meta name="description" content="8段階の強さから選べる強力なAIを搭載した無料のリバーシ（オセロ）ゲームです。登録不要、インストール不要でブラウザですぐにプレイ可能。CPUとの対戦や棋譜再生機能も充実。あなたの挑戦をお待ちしています！">
    <meta name="keywords" content="リバーシ, オセロ, ゲーム, 無料, AI, CPU, 対戦, ブラウザゲーム, オンライン, 思考エンジン, 定石, 棋譜">
    <link rel="canonical" href="https://core-calmdust.github.io/aicoding/reversi_v3.html">
    <link rel="icon" href="https://core-calmdust.github.io/aicoding/images/reversi_favicon.ico" type="image/x-icon">

    <meta property="og:title" content="【強力AI搭載】無料で遊べるリバーシ（オセロ）ゲーム">
    <meta property="og:description" content="8段階の強さから選べる強力AI搭載！ブラウザで今すぐプレイできる無料リバーシゲーム。">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://core-calmdust.github.io/aicoding/reversi_v3.html">
    <meta property="og:image" content="https://core-calmdust.github.io/aicoding/images/reversi-ogp.png">
    <meta property="og:site_name" content="無料リバーシゲーム">
    <meta property="og:locale" content="ja_JP">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="【強力AI搭載】無料で遊べるリバーシ（オセロ）ゲーム">
    <meta name="twitter:description" content="8段階の強さから選べる強力AI搭載！ブラウザで今すぐプレイできる無料リバーシゲーム。">
    <meta name="twitter:image" content="https://core-calmdust.github.io/aicoding/images/reversi-ogp.png"> 
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1e2a38;
            --surface-color: #2c3e50;
            --board-bg: #008080;
            --border-color: #1a2531;
            --text-color: #ecf0f1;
            --text-muted-color: #bdc3c7;
            --accent-color: #3498db;
            --accent-hover-color: #2980b9;
            --danger-color: #e74c3c;
            --highlight-color: rgba(255, 255, 0, 0.7);
            --board-size-pc: 600px;
            --board-size-sp: 90vw;
            --graph-inner-bg-color: #3b526a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans JP', sans-serif; background-color: var(--bg-color); color: var(--text-color);
            display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; padding: 10px;
        }

        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        
        main {
            width: 100%;
            max-width: 850px;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 20px;
        }
        
        .top-container {
            display: flex;
            gap: 20px;
            width: 100%;
            align-items: flex-start;
        }

        .sidebar {
            width: 240px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-shrink: 0;
        }

        .game-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%;
            background-color: var(--board-bg); border: 5px solid var(--surface-color); border-radius: 8px; padding: 5px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3), inset 0 2px 5px rgba(0, 0, 0, 0.2); aspect-ratio: 1 / 1;
        }

        .cell {
            width: 100%; height: 100%; border: 1px solid rgba(0, 0, 0, 0.2);
            display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative;
        }

        .disc {
            width: 85%; height: 85%; border-radius: 50%;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }

        .disc.black { background: radial-gradient(circle at 30% 30%, #444, #111); }
        .disc.white { background: radial-gradient(circle at 70% 70%, #fff, #ccc); box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 -2px 4px rgba(0, 0, 0, 0.2); }
        .last-move { outline: 3px solid var(--highlight-color); outline-offset: -3px; border-radius: 2px; }

        .valid-move-hint::after {
            content: ''; display: block; width: 35%; height: 35%;
            background-color: rgba(255, 255, 255, 0.3); border-radius: 50%;
            pointer-events: none; transition: background-color 0.2s;
        }
        .valid-move-hint:hover::after { background-color: rgba(255, 255, 255, 0.5); }

        .controls, .game-info, #evaluation-graph-container, .test-controls {
            background-color: var(--surface-color); padding: 20px;
            border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); width: 100%;
        }
        
        #message-area { font-size: 18px; font-weight: bold; color: var(--danger-color); height: 25px; text-align: center; margin-top: 20px; }
        
        .controls label,
        .test-controls label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-muted-color);
            font-size: 14px;
            font-weight: bold;
        }
        
        .test-controls h2 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--text-color);
            font-size: 1.1em;
        }
        
        .controls select, .test-controls select {
            width: 100%; padding: 12px; border-radius: 6px; border: 1px solid var(--border-color);
            background-color: var(--bg-color); color: var(--text-color); font-size: 16px;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23bdc3c7%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.3-5.5-12.8z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat; background-position: right 12px center; background-size: 12px; cursor: pointer;
        }

        .controls button, .test-controls button {
            width: 100%; padding: 12px; margin-top: 10px; border-radius: 6px; border: none;
            background-color: var(--accent-color); color: white; font-size: 16px; font-weight: bold;
            cursor: pointer; transition: background-color 0.2s ease-in-out;
        }
        
        .controls button:hover, .test-controls button:hover { background-color: var(--accent-hover-color); }
        
        .start-controls-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }
        
        .radio-group { display: flex; gap: 10px; justify-content: flex-start; }
        
        .radio-group label {
            position: relative; width: 48px; height: 48px;
            display: flex; justify-content: center; align-items: center;
            padding: 0; border: 3px solid var(--border-color);
            border-radius: 50%; cursor: pointer; transition: all 0.2s;
            background-color: transparent;
        }
        .radio-group label:hover { border-color: var(--text-muted-color); }
        .radio-group input { display: none; }
        .radio-group label:has(input:checked) {
            border-color: var(--accent-color);
            box-shadow: 0 0 8px var(--accent-color);
        }
        .radio-group label:has(input:disabled) { cursor: not-allowed; opacity: 0.5; }
        
        .radio-group .disc {
            width: 85%; height: 85%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 2px rgba(255,255,255,0.2);
        }
        .radio-group .disc.white { box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 -1px 2px rgba(0,0,0,0.2); }
        
        #start-button {
            background: #cccccc; border: none; padding: 0;
            border-radius: 8px; width: 48px; height: 48px;
            cursor: pointer; transition: all 0.2s ease;
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0; margin: 0;
        }
        #start-button:hover:not(:disabled) { background-color: #b0b0b0; }
        #start-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #6a6a6a; }
        #start-button img { width: 70%; height: 70%; opacity: 0.9; }

        .controls button:disabled, .test-controls button:disabled { background-color: #555; cursor: not-allowed; }
        
        .game-info {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 15px 20px; flex-grow: 1; gap: 15px;
        }
        #turn-info { display: flex; align-items: baseline; gap: 0.5em; font-family: 'Roboto', sans-serif; }
        #turn-count-label { font-size: 1em; font-weight: 700; color: var(--text-muted-color); }
        #turn-count-number { font-size: 1.8em; font-weight: 700; min-width: 2ch; text-align: left; }
        #score-info {
            display: flex; align-items: center; justify-content: center; gap: 8px;
            font-size: 1.6em; font-weight: 700; font-family: 'Roboto', sans-serif;
        }
        #score-info .disc { width: 28px; height: 28px; }
        #black-score, #white-score { min-width: 2.5ch; text-align: center; display: inline-block; }
        
        #evaluation-graph-container { padding: 10px 15px; height: auto; }

        #current-evaluation-display {
            text-align: center;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 700;
            color: var(--text-muted-color);
            margin-bottom: 10px;
            height: 20px;
        }

        #evaluation-graph-wrapper-outer { display: flex; width: 100%; height: 80px; }
        #evaluation-y-axis {
            display: flex; flex-direction: column; justify-content: space-between; align-items: flex-start;
            height: 100%; font-size: 10px; color: var(--text-muted-color);
            margin-right: 8px; width: 25px; flex-shrink: 0; font-family: 'Roboto', sans-serif;
        }
        #evaluation-graph-wrapper { flex-grow: 1; position: relative; overflow: hidden; cursor: default; touch-action: pan-y; }
        body.game-over #evaluation-graph-wrapper, body.game-interrupted #evaluation-graph-wrapper { cursor: grab; }
        body.graph-dragging #evaluation-graph-wrapper { cursor: grabbing; }

        #evaluation-graph {
            display: flex; height: 100%; position: relative; background-color: var(--graph-inner-bg-color);
            border-left: 1px solid var(--border-color); border-right: 1px solid var(--border-color);
        }
        #evaluation-graph::before {
            content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 1px;
            background-color: var(--border-color); transform: translateY(-50%); z-index: 1;
        }
        .bar-container { flex: 1; height: 100%; position: relative; transition: background-color 0.2s; }
        .bar-container:hover { background-color: rgba(52, 152, 219, 0.1); }
        .bar-container.current-turn-highlight { background-color: rgba(255, 255, 0, 0.2); }
        
        .bar {
            width: 70%; position: absolute; left: 15%; transition: height 0.3s ease, background-color 0.2s; z-index: 2;
        }
        .bar.black { background-color: #444; bottom: 50%; }
        .bar.white { background-color: #eee; top: 50%; }
        .bar-container:hover .bar.black { background-color: #666; }
        .bar-container:hover .bar.white { background-color: #fff; }
        #evaluation-tooltip {
            position: absolute; display: none; background-color: var(--accent-color); color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;
            pointer-events: none; transform: translate(-50%, -130%); white-space: nowrap; z-index: 10;
        }

        .kifu-buttons { display: flex; gap: 10px; margin-top: 10px; }
        .kifu-buttons button {
            flex: 1; margin-top: 0; padding: 6px; font-size: 16px;
            background-color: #cccccc; border-radius: 8px;
        }
        .kifu-buttons button:hover { background-color: #b0b0b0; }
        .kifu-buttons button:disabled { background-color: #6a6a6a; cursor: not-allowed; }
        .kifu-buttons button img {
            height: 1.2em; vertical-align: middle; opacity: 0.8; transition: opacity 0.2s;
        }
        .kifu-buttons button:hover img { opacity: 1; }
        .kifu-buttons button:disabled img { opacity: 0.4; }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .action-buttons button {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-muted-color);
            border: 2px solid var(--border-color);
            border-radius: 6px;
        }
        .action-buttons button:not(:disabled):hover {
            border-color: var(--accent-color);
            color: var(--text-color);
        }
        .action-buttons button:disabled {
            opacity: 0.5;
            background-color: var(--bg-color);
            cursor: not-allowed;
        }
        .action-buttons button.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .research-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(12px, 3.5vw, 24px);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 3px black, -1px -1px 3px black;
            pointer-events: none;
        }
        .research-value.plus { color: #87CEEB; }
        .research-value.minus { color: #F08080; }
        
        .test-cpu-selectors { display: flex; gap: 20px; justify-content: center; }
        .test-cpu-selector { flex: 1; }

        #modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #custom-modal {
            background: var(--surface-color);
            padding: 25px 35px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        #modal-overlay.visible #custom-modal {
            transform: scale(1);
        }
        #modal-message {
            margin: 0;
            font-size: 1.1em;
            color: var(--text-color);
            line-height: 1.6;
        }
        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            justify-content: center;
        }
        .modal-buttons button {
            padding: 10px 24px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        #modal-confirm-btn {
            background: var(--accent-color);
            color: white;
        }
        #modal-confirm-btn:hover {
            background: var(--accent-hover-color);
        }
        #modal-cancel-btn {
            background: var(--bg-color);
            color: var(--text-muted-color);
            border: 2px solid var(--border-color);
        }
        #modal-cancel-btn:hover {
            border-color: var(--text-muted-color);
            color: var(--text-color);
        }

        /* PC版レイアウトをGridで再構築 */
        @media (min-width: 901px) {
            .game-wrapper {
                display: grid;
                grid-template-columns: 240px 1fr;
                grid-template-areas:
                    "sidebar game"
                    "eval    game"
                    "message message"
                    "test    test";
                align-items: start;
            }
            .top-container {
                display: contents;
            }
            .sidebar {
                grid-area: sidebar;
                width: 100%;
            }
            .game-area {
                grid-area: game;
                grid-row: game-start / span 2;
            }
            #evaluation-graph-container {
                grid-area: eval;
                width: 100%;
            }
            #message-area {
                grid-area: message;
                margin-top: 0;
            }
            .test-controls {
                grid-area: test;
            }
        }

        @media (max-width: 900px) {
            .top-container {
                flex-direction: column;
            }
            
            .sidebar {
                flex-direction: row;
                flex-wrap: nowrap;
                width: 100%;
                gap: 10px;
                align-items: stretch;
            }
            
            .controls {
                flex: 1;
                display: flex;
                flex-direction: column;
                justify-content: center;
                padding: 10px;
                gap: 5px;
            }
            
            .game-info {
                flex: 1;
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: space-around;
                align-items: center;
                gap: 8px;
                padding: 10px;
            }

            .controls label {
                font-size: 11px;
                text-align: center;
                margin-bottom: 0;
            }
            .controls select {
                font-size: 13px;
                padding: 6px 10px;
            }
            .start-controls-wrapper {
                padding-top: 6px;
                margin-top: 6px;
                justify-content: center;
            }
            .radio-group label, #start-button {
                width: 36px;
                height: 36px;
            }

            #turn-info, #score-info, .action-buttons {
                flex-grow: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-top: 0;
            }

            #turn-info { font-size: 0.9em; gap: 0.3em; }
            #turn-count-number { font-size: 1.5em; }
            #score-info { font-size: 1.1em; gap: 5px; }
            #score-info .disc { width: 20px; height: 20px; }
            #black-score, #white-score { font-size: 1.3em; }
            
            .action-buttons { gap: 6px; }
            .action-buttons button { padding: 6px; font-size: 11px; }

            .game-area {
                width: 100%;
            }
            #board {
                width: var(--board-size-sp);
                margin: 0 auto;
            }
            #message-area {
                width: 100%;
                margin: 0;
            }
            #evaluation-graph-container {
                display: block;
            }
        }
    </style>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org", "@type": "VideoGame", "name": "強力AI搭載リバーシゲーム",
      "description": "8段階の強さから選べる強力なAIを搭載した無料のブラウザリバーシ（オセロ）ゲームです。登録不要ですぐにプレイできます。",
      "gamePlatform": "Web-based game", "applicationCategory": "Game", "operatingSystem": "All",
      "author": { "@type": "Person", "name": "Your Name or Company" }, "offers": { "@type": "Offer", "price": "0", "priceCurrency": "JPY" }
    }
    </script>
</head>
<body>
    <main>
        <div class="game-wrapper">
            <div class="top-container">
                <div class="sidebar">
                    <section class="controls" aria-labelledby="game-settings-heading">
                        <h2 id="game-settings-heading" class="visually-hidden">対戦設定</h2>
                        <label for="cpu-level">あなたの対戦相手:</label>
                        <select id="cpu-level">
                            <option value="1">レベル1 (ランダム)</option>
                            <option value="2">レベル2 (最大反転)</option>
                            <option value="3">レベル3 (場所評価)</option>
                            <option value="4">レベル4 (α-β法 弱)</option>
                            <option value="5">レベル5 (α-β法 強)</option>
                            <option value="6">レベル6 (思考強化)</option>
                            <option value="7">レベル7 (定石+探索)</option>
                            <option value="8" selected>レベル8 (複合型AI)</option>
                            <option value="9">レベル8+ (多様性)</option>
                            <option value="10">レベル9 (戦略的評価型AI)</option>
                        </select>
                        
                        <div class="start-controls-wrapper">
                            <div class="radio-group" role="radiogroup" aria-label="手番選択">
                                <label title="先攻 (黒)">
                                    <input type="radio" name="player_color" value="1" checked>
                                    <span class="disc black"></span>
                                </label>
                                <label title="後攻 (白)">
                                    <input type="radio" name="player_color" value="2">
                                    <span class="disc white"></span>
                                </label>
                            </div>
                            <button id="start-button" aria-label="ゲームを開始します">
                                <img src="https://core-calmdust.github.io/aicoding/images/reversi/play.png" alt="開始">
                            </button>
                        </div>
                    </section>
    
                    <section class="game-info" aria-labelledby="game-status-heading">
                        <h2 id="game-status-heading" class="visually-hidden">ゲーム状況</h2>
                        <div id="turn-info">
                            <span id="turn-count-label">TURN</span>
                            <span id="turn-count-number">0</span>
                        </div>
                        <div id="score-info">
                            <span class="disc black"></span>
                            <span id="black-score">2</span>
                            <span class="disc white"></span>
                            <span id="white-score">2</span>
                        </div>
                        <div class="action-buttons">
                            <button id="undo-button" disabled>UNDO</button>
                            <button id="research-button" disabled>RESEARCH</button>
                        </div>
                    </section>
                </div>
                <div class="game-area">
                    <div id="board"></div>
                </div>
            </div>
            <div id="message-area" role="status" aria-live="polite"></div>
            
            <section id="evaluation-graph-container">
                <div id="current-evaluation-display">
                    <span>対戦相手のAI評価値: </span>
                    <span id="evaluation-value-text">N/A</span>
                </div>
                 <div id="evaluation-graph-wrapper-outer">
                    <div id="evaluation-y-axis"></div>
                    <div id="evaluation-graph-wrapper">
                        <div id="evaluation-graph"></div>
                        <div id="evaluation-tooltip"></div>
                    </div>
                </div>
                <div class="kifu-buttons">
                    <button id="kifu-start" disabled aria-label="最初へ"><img src="https://core-calmdust.github.io/aicoding/images/reversi/<<.png" alt="最初へ"></button>
                    <button id="kifu-prev" disabled aria-label="前へ"><img src="https://core-calmdust.github.io/aicoding/images/reversi/<.png" alt="前へ"></button>
                    <button id="kifu-next" disabled aria-label="次へ"><img src="https://core-calmdust.github.io/aicoding/images/reversi/>.png" alt="次へ"></button>
                    <button id="kifu-end" disabled aria-label="最後へ"><img src="https://core-calmdust.github.io/aicoding/images/reversi/>>.png" alt="最後へ"></button>
                </div>
            </section>

            <section class="test-controls" aria-labelledby="test-heading">
                <h2 id="test-heading">CPU対戦テスト</h2>
                <div class="test-cpu-selectors">
                    <div class="test-cpu-selector">
                        <label for="cpu1-level">CPU 1 (先攻/黒)</label>
                        <select id="cpu1-level">
                            <option value="1">レベル1</option> <option value="2">レベル2</option> <option value="3">レベル3</option>
                            <option value="4">レベル4</option> <option value="5">レベル5</option> <option value="6">レベル6</option>
                            <option value="7">レベル7</option>
                            <option value="8" selected>レベル8</option>
                            <option value="9">レベル8+</option>
                            <option value="10">レベル9</option>
                        </select>
                    </div>
                    <div class="test-cpu-selector">
                        <label for="cpu2-level">CPU 2 (後攻/白)</label>
                        <select id="cpu2-level">
                            <option value="1">レベル1</option> <option value="2">レベル2</option> <option value="3">レベル3</option>
                            <option value="4">レベル4</option> <option value="5">レベル5</option> <option value="6">レベル6</option>
                            <option value="7">レベル7</option>
                            <option value="8">レベル8</option>
                            <option value="9" selected>レベル8+</option>
                            <option value="10">レベル9</option>
                        </select>
                    </div>
                </div>
                <button id="cpu-vs-cpu-button" aria-label="選択したレベルのCPU同士を対戦させます">CPU VS CPU 開始</button>
            </section>
        </div>
    </main>

    <div id="modal-overlay">
        <div id="custom-modal">
            <p id="modal-message"></p>
            <div class="modal-buttons">
                <button id="modal-confirm-btn"></button>
                <button id="modal-cancel-btn"></button>
            </div>
        </div>
    </div>

    <script id="research-worker-script" type="javascript/worker">
        // --- 定数定義 ---
        const EMPTY = 0, BLACK = 1, WHITE = 2;
        const BOARD_SIZE = 8;
        const MAX_TURNS = 60;
        const DIRECTIONS = [ { r: -1, c: -1 }, { r: -1, c: 0 }, { r: -1, c: 1 }, { r: 0, c: -1 }, { r: 0, c: 1 }, { r: 1, c: -1 }, { r: 1, c: 0 }, { r: 1, c: 1 } ];
        const POSITIONAL_SCORE_TABLE = [
            [120, -20,  20,   5,   5,  20, -20, 120],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[  5,  -5,   3,   3,   3,   3,  -5,   5],
            [  5,  -5,   3,   3,   3,   3,  -5,   5],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[120, -20,  20,   5,   5,  20, -20, 120]
        ];
        let continueThinking = false;

        // --- ユーティリティ関数 ---
        function getFlippableDiscs(currentBoard, r, c, player) {
            const flippable = [];
            if (currentBoard[r][c] !== EMPTY) return flippable;
            const opponent = (player === BLACK) ? WHITE : BLACK;
            for (const dir of DIRECTIONS) {
                const line = []; let currR = r + dir.r, currC = c + dir.c;
                while (currR >= 0 && currR < 8 && currC >= 0 && currC < 8) {
                    if (currentBoard[currR][currC] === opponent) line.push({r: currR, c: currC});
                    else if (currentBoard[currR][currC] === player) { flippable.push(...line); break; } 
                    else break;
                    currR += dir.r; currC += dir.c;
                }
            }
            return flippable;
        }

        function getValidMoves(currentBoard, player) {
            const moves = [];
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                if (currentBoard[r][c] === EMPTY && getFlippableDiscs(currentBoard, r, c, player).length > 0) {
                    moves.push({r, c});
                }
            }
            return moves;
        }
        
        function placeDiscInBoard(b, r, c, player, flippable) {
            b[r][c] = player;
            flippable.forEach(p => { b[p.r][p.c] = player; });
        }

        function getStableDiscs(board, player) {
            const stable = Array.from({length: 8}, () => Array(8).fill(false));
            const directions = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]];
            if (board[0][0] === player) stable[0][0] = true; if (board[0][7] === player) stable[0][7] = true;
            if (board[7][0] === player) stable[7][0] = true; if (board[7][7] === player) stable[7][7] = true;
            let changed = true;
            while(changed) {
                changed = false;
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    if(board[r][c] === player && !stable[r][c]) {
                        let isStable = true;
                        for(let i=0; i<4; i++) {
                            const [d1r,d1c]=directions[i*2], [d2r,d2c]=directions[i*2+1];
                            let line1_filled = true, line2_filled = true;
                            let nr = r + d1r, nc = c + d1c;
                            while(nr>=0&&nr<8&&nc>=0&&nc<8) { if(board[nr][nc]!==player&&!stable[nr][nc]){line1_filled=false;break;} nr+=d1r; nc+=d1c; }
                            nr = r + d2r, nc = c + d2c;
                            while(nr>=0&&nr<8&&nc>=0&&nc<8) { if(board[nr][nc]!==player&&!stable[nr][nc]){line2_filled=false;break;} nr+=d2r; nc+=d2c; }
                            if (!line1_filled && !line2_filled) { isStable=false; break; }
                        }
                        if(isStable) { stable[r][c] = true; changed = true; }
                    }
                }
            }
            const stableDiscs = [];
            for (let r=0; r<8; r++) for(let c=0; c<8; c++) if(stable[r][c]) stableDiscs.push({r,c});
            return stableDiscs;
        }
        
        // --- 評価関数群 ---
        function simplePositionalEvaluation(board, player) {
            let score = 0;
            const opponent = (player === BLACK) ? WHITE : BLACK;
            for (let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) {
                if(board[r][c]===player) score+=POSITIONAL_SCORE_TABLE[r][c];
                else if(board[r][c]===opponent) score-=POSITIONAL_SCORE_TABLE[r][c];
            }
            return score;
        }

        function advancedPositionalEvaluation(board, player) {
            const opponent = (player === BLACK) ? WHITE : BLACK;
            const positionalScore = simplePositionalEvaluation(board, player);
            const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
            const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
            return positionalScore + (mobilityScore * 50) + (fixedDiscScore * 150);
        }

        function evaluateBoardForLevel8(board, player, currentTurn) {
            const opponent = (player === BLACK) ? WHITE : BLACK;
            const positionalScore = simplePositionalEvaluation(board, player);
            const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
            const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
            let cornerPenalty = 0;
            const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
            const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
            for (let i = 0; i < 4; i++) {
                if (board[corners[i].r][corners[i].c] === EMPTY) {
                    if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 250;
                    if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 250;
                }
            }
            let positionalWeight, mobilityWeight, fixedDiscWeight;
            if (currentTurn < 20) { positionalWeight=1; mobilityWeight=80; fixedDiscWeight=120; } 
            else if (currentTurn < 48) { positionalWeight=1; mobilityWeight=60; fixedDiscWeight=180; } 
            else { positionalWeight=0.5; mobilityWeight=40; fixedDiscWeight=250; }
            return (positionalScore*positionalWeight) + (mobilityScore*mobilityWeight) + (fixedDiscScore*fixedDiscWeight) + cornerPenalty;
        }

        function evaluateBoardForLevel9(board, player, currentTurn) {
            const opponent = (player === BLACK) ? WHITE : BLACK;
            const positionalScore = simplePositionalEvaluation(board, player);
            const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
            const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
            let cornerPenalty = 0;
            const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
            const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
            for (let i = 0; i < 4; i++) {
                if (board[corners[i].r][corners[i].c] === EMPTY) {
                    if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 300;
                    if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 300;
                }
            }
            let positionalWeight, mobilityWeight, fixedDiscWeight;
            if (currentTurn < 20) { positionalWeight = 1.0; mobilityWeight = 90; fixedDiscWeight = 130; } 
            else if (currentTurn < 45) { positionalWeight = 1.0; mobilityWeight = 65; fixedDiscWeight = 220; } 
            else { positionalWeight = 0.5; mobilityWeight = 45; fixedDiscWeight = 350; }

            let edgeControlScore = 0;
            const edges = [
                {line: board[0], corners: [board[0][0], board[0][7]]}, {line: board[7], corners: [board[7][0], board[7][7]]},
                {line: board.map(row => row[0]), corners: [board[0][0], board[7][0]]}, {line: board.map(row => row[7]), corners: [board[0][7], board[7][7]]},
            ];
            for (const edge of edges) {
                if (edge.corners[0] === EMPTY || edge.corners[1] === EMPTY) {
                    let myStones = 0, oppStones = 0;
                    for(let i = 1; i < 7; i++) {
                        if (edge.line[i] === player) myStones++;
                        else if (edge.line[i] === opponent) oppStones++;
                    }
                    edgeControlScore += (oppStones - myStones);
                }
            }
            const edgeControlWeight = 35;
            return (positionalScore * positionalWeight) + (mobilityScore * mobilityWeight) + (fixedDiscScore * fixedDiscWeight) + cornerPenalty + (edgeControlScore * edgeControlWeight);
        }
        
        function evaluateBoard(board, player, level, currentTurn) {
            if (level >= 10) return evaluateBoardForLevel9(board, player, currentTurn);
            if (level >= 8) return evaluateBoardForLevel8(board, player, currentTurn);
            if (level >= 6) return advancedPositionalEvaluation(board, player);
            return simplePositionalEvaluation(board, player);
        }

        function evaluateByStoneCount(board, player, isFromAlphaBeta) {
            let score = 0;
            board.flat().forEach(c => { if (c === player) score++; else if (c !== EMPTY) score--; });
            return isFromAlphaBeta ? score * 1000 : score;
        }
        
        // --- 探索関連 ---
        function getDepthForLevel(level, turnCount) {
            const emptyCells = MAX_TURNS - turnCount;
            if (level <= 4) return 3;
            if (level === 5) return 4;
            if (level === 6) return 5;
            if (level === 7) return (emptyCells > 24) ? 5 : 6;
            if (level === 8) return (emptyCells > 22) ? 6 : 7;
            if (level === 9) return (emptyCells > 22) ? 6 : 7;
            if (level === 10) return (emptyCells > 24) ? 7 : 8;
            return 3;
        }

        function alphaBetaSearch(currentBoard, depth, alpha, beta, isMaximizingNode, maximizingPlayer, currentLevel, turnCount) {
            const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
            if (depth === 0 || emptyCells === 0) return { score: evaluateBoard(currentBoard, maximizingPlayer, currentLevel, turnCount) };
            
            const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
            const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
            let validMoves = getValidMoves(currentBoard, playerForThisNode);
            
            if (validMoves.length === 0) {
                if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, true) };
                return alphaBetaSearch(currentBoard, depth, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel, turnCount);
            }
            
            let bestResult = { move: null, score: isMaximizingNode ? -Infinity : Infinity };
            if (depth >= 4 && currentLevel >= 8) {
                const moveScores = validMoves.map(move => {
                    const newBoard = JSON.parse(JSON.stringify(currentBoard));
                    placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
                    return { move, score: evaluateBoard(newBoard, maximizingPlayer, currentLevel, turnCount + 1) };
                });
                if (isMaximizingNode) moveScores.sort((a, b) => b.score - a.score);
                else moveScores.sort((a, b) => a.score - b.score);
                validMoves = moveScores.map(ms => ms.move);
            }
            bestResult.move = validMoves[0];

            for (const move of validMoves) {
                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
                const result = alphaBetaSearch(newBoard, depth - 1, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel, turnCount + 1);
                if (isMaximizingNode) {
                    if (result.score > bestResult.score) bestResult = { move, score: result.score };
                    alpha = Math.max(alpha, bestResult.score);
                } else {
                    if (result.score < bestResult.score) bestResult = { move, score: result.score };
                    beta = Math.min(beta, bestResult.score);
                }
                if (beta <= alpha) break; 
            }
            return bestResult;
        }

        // --- メインロジック ---
        self.onmessage = async (e) => {
            const { type, board, playerColor, turnCount, currentEval, maxAiLevel, validMoves } = e.data;
            if (type === 'stop') {
                continueThinking = false;
                return;
            }
            
            continueThinking = true;
            let cumulativeEvals = {};

            for (let level = 4; level <= maxAiLevel; level++) {
                if (!continueThinking) break;
                
                const depth = getDepthForLevel(level, turnCount);
                const currentLevelEvals = {};

                for (const move of validMoves) {
                    if (!continueThinking) break;
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    const flippable = getFlippableDiscs(tempBoard, move.r, move.c, playerColor);
                    placeDiscInBoard(tempBoard, move.r, move.c, playerColor, flippable);
                    
                    const result = alphaBetaSearch(tempBoard, depth, -Infinity, Infinity, false, BLACK, level, turnCount + 1);
                    
                    let diff = result.score - currentEval;
                    if (playerColor === WHITE) {
                        diff = -diff;
                    }
                    
                    currentLevelEvals[`${move.r},${move.c}`] = diff;
                }
                
                if (continueThinking) {
                    cumulativeEvals = {...cumulativeEvals, ...currentLevelEvals };
                    self.postMessage({ type: 'evalUpdate', evaluations: cumulativeEvals, level });
                    await new Promise(r => setTimeout(r, 10)); // UIの応答性を保つためのわずかな待機
                }
            }
        };
    </script>
    <script>
// ================================================================= //
//                             定数と変数定義                         //
// ================================================================= //

const BOARD_SIZE = 8, EMPTY = 0, BLACK = 1, WHITE = 2;
const DIRECTIONS = [ { r: -1, c: -1 }, { r: -1, c: 0 }, { r: -1, c: 1 }, { r: 0, c: -1 }, { r: 0, c: 1 }, { r: 1, c: -1 }, { r: 1, c: 0 }, { r: 1, c: 1 } ];
const MAX_TURNS = 60;
const EVAL_GRAPH_INITIAL_SCALE = 500;
const POSITIONAL_SCORE_TABLE = [
    [120, -20,  20,   5,   5,  20, -20, 120],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[  5,  -5,   3,   3,   3,   3,  -5,   5],
    [  5,  -5,   3,   3,   3,   3,  -5,   5],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[120, -20,  20,   5,   5,  20, -20, 120]
];
const OPENING_BOOK = {
    "0000000000000000000000000001200000021000000000000000000000000000": {r:4, c:5},"0000000000000000000000000012100000012000000000000000000000000000": {r:5, c:5},
    "0000000000000000000000000002100000012100000000000000000000000000": {r:2, c:3},"0000000000000000000001000001210000021100000000000000000000000000": {r:2, c:2},
    "0000000000000000000000000011200000012000000000000000000000000000": {r:5, c:2},"000000000000000000000000000210000001110000000000000000000000000": {r:5, c:3},
};

const boardEl = document.getElementById('board');
const blackScoreEl = document.getElementById('black-score');
const whiteScoreEl = document.getElementById('white-score');
const turnCountNumberEl = document.getElementById('turn-count-number');
const messageAreaEl = document.getElementById('message-area');
const cpuLevelSelect = document.getElementById('cpu-level');
const startButton = document.getElementById('start-button');
const playerColorRadios = document.querySelectorAll('input[name="player_color"]');
const cpu1LevelSelect = document.getElementById('cpu1-level');
const cpu2LevelSelect = document.getElementById('cpu2-level');
const cpuVsCpuButton = document.getElementById('cpu-vs-cpu-button');
const kifuStartBtn = document.getElementById('kifu-start');
const kifuPrevBtn = document.getElementById('kifu-prev');
const kifuNextBtn = document.getElementById('kifu-next');
const kifuEndBtn = document.getElementById('kifu-end');
const evaluationValueTextEl = document.getElementById('evaluation-value-text');
const undoButton = document.getElementById('undo-button');
const researchButton = document.getElementById('research-button');
const modalOverlay = document.getElementById('modal-overlay');
const modalMessage = document.getElementById('modal-message');
const modalConfirmBtn = document.getElementById('modal-confirm-btn');
const modalCancelBtn = document.getElementById('modal-cancel-btn');

let board, currentPlayer, turnCount, lastMove, playerColor, cpuColor;
let isCpuVsCpuMode = false, isGameOver = false, isPlaybackMode = false;
let isGameInProgress = false;
let wasUndo = false;
let gameHistory = [], playbackIndex = 0, evaluationHistory = [];
let isDraggingGraph = false, lastHoveredTurn = -1;
let undoCount = 0;
let isResearchMode = false;
let researchEvaluations = {};
let currentResearchLevel = 0;
const maxAiLevel = 10;

const workerScript = document.getElementById('research-worker-script').textContent;
const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
const researchWorker = new Worker(URL.createObjectURL(workerBlob));

function updateResearchValues(evaluations) {
    Object.keys(evaluations).forEach(key => {
        const [r, c] = key.split(',').map(Number);
        const cellIndex = r * BOARD_SIZE + c;
        const cell = boardEl.children[cellIndex];
        if (!cell || cell.querySelector('.disc')) return;

        cell.classList.remove('valid-move-hint');
        
        let valueSpan = cell.querySelector('.research-value');
        if (!valueSpan) {
            valueSpan = document.createElement('span');
            valueSpan.className = 'research-value';
            cell.appendChild(valueSpan);
        }
        
        const roundedEval = Math.round(evaluations[key]);
        valueSpan.textContent = (roundedEval > 0 ? '+' : '') + roundedEval;
        valueSpan.classList.toggle('plus', roundedEval >= 0);
        valueSpan.classList.toggle('minus', roundedEval < 0);
    });
}

researchWorker.onmessage = (e) => {
    if (isResearchMode && e.data.type === 'evalUpdate') {
        const { evaluations, level } = e.data;
        currentResearchLevel = level;
        researchEvaluations = { ...researchEvaluations, ...evaluations };
        updateResearchValues(evaluations);
        updateGameInfo();
    }
};

// ================================================================= //
//                      メインロジック (ゲーム進行管理)                 //
// ================================================================= //

function resetGame() {
    isGameInProgress = false;
    isCpuVsCpuMode = false;
    isPlaybackMode = false;
    isGameOver = false;
    if(isResearchMode) researchButton.click();
    undoCount = 0;
    document.body.classList.remove('game-over', 'game-interrupted', 'graph-dragging');
    board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
    board[3][3] = WHITE; board[3][4] = BLACK;
    board[4][3] = BLACK; board[4][4] = WHITE;
    currentPlayer = BLACK;
    turnCount = 0;
    lastMove = null;
    gameHistory = [{ move: null, boardState: JSON.parse(JSON.stringify(board)) }];
    evaluationHistory = [];
    playbackIndex = 0;
    renderBoard();
    renderEvaluationGraph();
    updateEvaluationDisplay(null);
    updateUiState();
    updateGameInfo();
}

function setupAndStartGame(isTestMode, fromCurrentState) {
    if (fromCurrentState) {
        const blackCount = board.flat().filter(c => c === BLACK).length;
        const whiteCount = board.flat().filter(c => c === WHITE).length;
        turnCount = blackCount + whiteCount - 4;
        currentPlayer = (turnCount % 2 === 0) ? BLACK : WHITE;
        gameHistory.splice(turnCount + 1);
        evaluationHistory.splice(turnCount);
    } else {
        resetGame();
    }
    isCpuVsCpuMode = isTestMode;
    startGame();
}

function startGame() {
    isPlaybackMode = false;
    isGameInProgress = true;
    isGameOver = false;
    document.body.classList.remove('game-interrupted', 'game-over');
    gameController();
}

function interruptGame() {
    isGameInProgress = false;
    if (isResearchMode) researchButton.click();
    document.body.classList.add('game-interrupted');
    updateUiState();
    updateGameInfo();
}


async function gameController() {
    if (!isGameInProgress || isGameOver) return;
    
    updateUiState();
    updateGameInfo();
    
    const isPlayerTurn = !isCpuVsCpuMode && currentPlayer === playerColor;
    if (isResearchMode && isPlayerTurn) {
        researchEvaluations = {};
        renderBoard();
        const currentEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : 0;
        const validMoves = getValidMoves(board, playerColor);
        researchWorker.postMessage({
            type: 'start', board, playerColor, turnCount, currentEval, maxAiLevel, validMoves
        });
    } else {
        renderBoard();
    }

    const canCurrentPlayerMove = getValidMoves(board, currentPlayer).length > 0;
    if (!canCurrentPlayerMove) {
        const opponent = (currentPlayer === BLACK) ? WHITE : BLACK;
        const canOpponentMove = getValidMoves(board, opponent).length > 0;
        if (!canOpponentMove) {
            endGame();
            return;
        }
        messageAreaEl.textContent = `${currentPlayer === BLACK ? '黒' : '白'}はパスします。`;
        await new Promise(resolve => setTimeout(resolve, 1000));
        turnCount++;
        gameHistory.push({ move: {r: -1, c: -1}, boardState: JSON.parse(JSON.stringify(board)) });
        evaluationHistory.push(evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length-1] : 0);
        currentPlayer = opponent;
        gameController();
        return;
    }

    const isCpuTurnNow = isCpuVsCpuMode || (currentPlayer === cpuColor);
    if (isCpuTurnNow) {
        await executeCpuTurn();
    }
}

function endGame() {
    isGameOver = true;
    isGameInProgress = false;
    if(isResearchMode) researchButton.click();
    document.body.classList.add('game-over');
    document.body.classList.remove('game-interrupted');
    
    const blackScore = board.flat().filter(c => c === BLACK).length;
    const whiteScore = board.flat().filter(c => c === WHITE).length;
    const winner = (blackScore > whiteScore) ? BLACK : ((whiteScore > blackScore) ? WHITE : EMPTY);
    
    let message = "引き分けです！";
    if (winner !== EMPTY) {
        if (isCpuVsCpuMode) message = `CPU ${(winner === BLACK ? '1' : '2')} の勝ちです。`;
        else message = (winner === playerColor) ? "🎉 あなたの勝ちです！ 🎉" : "CPUの勝ちです。";
    }
    if (!isCpuVsCpuMode && undoCount > 0) message += ` (待ったの使用回数: ${undoCount}回)`;
    messageAreaEl.textContent = `ゲーム終了！ ${message}`;
    updateUiState();
    updateGameInfo();
    renderEvaluationGraph();
}

// ================================================================= //
//                         UI・描画関連                             //
// ================================================================= //

function renderBoard() {
    boardEl.innerHTML = '';
    const validMoves = (isGameInProgress && !isCpuVsCpuMode && !isPlaybackMode && currentPlayer === playerColor && !isGameOver) 
        ? getValidMoves(board, currentPlayer) : [];
    
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            if (board[r][c] !== EMPTY) {
                const disc = document.createElement('div');
                disc.className = `disc ${board[r][c] === BLACK ? 'black' : 'white'}`;
                cell.appendChild(disc);
            } else {
                if (validMoves.find(m => m.r === r && m.c === c)) {
                    cell.classList.add('valid-move-hint');
                }
            }
            if (lastMove && lastMove.r === r && lastMove.c === c) {
                cell.classList.add('last-move');
            }
            cell.addEventListener('click', () => handleCellClick(r, c));
            boardEl.appendChild(cell);
        }
    }
}

function updateGameInfo() {
    let blackScore = 0, whiteScore = 0;
    const currentBoard = board; 
    currentBoard.flat().forEach(cell => {
        if (cell === BLACK) blackScore++;
        if (cell === WHITE) whiteScore++;
    });
    blackScoreEl.textContent = blackScore;
    whiteScoreEl.textContent = whiteScore;
    turnCountNumberEl.textContent = isPlaybackMode ? playbackIndex : turnCount;
    
    if (isGameOver) {
        const blackFinal = board.flat().filter(c => c === BLACK).length;
        const whiteFinal = board.flat().filter(c => c === WHITE).length;
        const winner = (blackFinal > whiteFinal) ? '黒' : (whiteFinal > blackFinal ? '白' : '引き分け');
        messageAreaEl.textContent = `ゲーム終了！ ${winner === '引き分け' ? '引き分けです！' : winner + 'の勝ちです。'}`;
        return;
    }
    
    let message = '';
    if (isPlaybackMode) {
         message = `棋譜再生中 (${playbackIndex}手目)`;
    } else if (isGameInProgress) {
        if (isCpuVsCpuMode) {
             message = `${turnCount + 1}手目: CPU ${currentPlayer === BLACK ? '1' : '2'}のターンです`;
        } else {
             const playerTurnMsg = currentPlayer === playerColor ? 'あなたのターンです' : 'CPUのターンです';
             const researchLvlText = currentResearchLevel >= 9 ? (currentResearchLevel === 9 ? '8+' : '9') : currentResearchLevel.toString();
             message = isResearchMode && currentPlayer === playerColor ? `RESEARCHモード (レベル${researchLvlText} 思考中...)` : `${turnCount + 1}手目: ${playerTurnMsg}`;
        }
    } else if (gameHistory.length > 1) {
        message = '中断中...';
    } else {
         message = '対戦設定を選んで開始してください';
    }

    if (wasUndo) {
        messageAreaEl.textContent = '待った！ ' + message;
        wasUndo = false;
    } else {
        messageAreaEl.textContent = message;
    }
}

function updateUiState() {
    playerColor = parseInt(document.querySelector('input[name="player_color"]:checked').value, 10);
    cpuColor = (playerColor === BLACK) ? WHITE : BLACK;
    
    const startButtonImg = startButton.querySelector('img');
    if (isGameInProgress && !isGameOver) {
        startButtonImg.src = 'https://core-calmdust.github.io/aicoding/images/reversi/stop.png';
        startButtonImg.alt = '中断';
        startButton.setAttribute('aria-label', 'ゲームを中断します');
    } else {
        startButtonImg.src = 'https://core-calmdust.github.io/aicoding/images/reversi/play.png';
        startButtonImg.alt = '開始';
        startButton.setAttribute('aria-label', 'ゲームを開始します');
    }
    
    const controlsLocked = isGameInProgress && !isGameOver;
    cpuLevelSelect.disabled = controlsLocked;
    playerColorRadios.forEach(radio => { radio.disabled = controlsLocked; });
    cpuVsCpuButton.disabled = controlsLocked;
    
    const isPlayerTurn = isGameInProgress && !isCpuVsCpuMode && currentPlayer === playerColor;
    undoButton.disabled = !isPlayerTurn || turnCount < 2;
    researchButton.disabled = !isPlayerTurn;
    
    const kifuActive = isGameOver || isPlaybackMode || (!isGameInProgress && gameHistory.length > 1);
    const currentKifuIndex = isPlaybackMode ? playbackIndex : turnCount;
    kifuStartBtn.disabled = !kifuActive || currentKifuIndex === 0;
    kifuPrevBtn.disabled = !kifuActive || currentKifuIndex === 0;
    kifuNextBtn.disabled = !kifuActive || currentKifuIndex >= gameHistory.length - 1;
    kifuEndBtn.disabled = !kifuActive || currentKifuIndex >= gameHistory.length - 1;
}

function updateEvaluationDisplay(score) {
    if (score === null || score === undefined) {
        evaluationValueTextEl.textContent = "N/A";
    } else {
        const scoreText = (score > 0 ? '+' : '') + score.toFixed(0);
        evaluationValueTextEl.textContent = scoreText;
    }
}

function renderEvaluationGraph() {
    const graphEl = document.getElementById('evaluation-graph');
    const yAxisEl = document.getElementById('evaluation-y-axis');
    const tooltipEl = document.getElementById('evaluation-tooltip');
    if (!graphEl || !yAxisEl || !tooltipEl) return;
    graphEl.innerHTML = '';
    const maxAbsValue = evaluationHistory.length > 0 ? Math.max(...evaluationHistory.map(v => Math.abs(v))) : 0;
    const scale = Math.max(EVAL_GRAPH_INITIAL_SCALE, Math.ceil(maxAbsValue / 100) * 100);
    yAxisEl.innerHTML = `<span>+${scale}</span><span>-${scale}</span>`;
    for (let i = 0; i < MAX_TURNS; i++) {
        const barContainer = document.createElement('div');
        barContainer.className = 'bar-container';
        if (isPlaybackMode && i === playbackIndex) {
            barContainer.classList.add('current-turn-highlight');
        }
        if (i < evaluationHistory.length) {
            const value = evaluationHistory[i];
            const bar = document.createElement('div');
            bar.className = 'bar';
            const heightPercentage = Math.min((Math.abs(value) / scale) * 100, 100);
            bar.style.height = `${heightPercentage / 2}%`;
            if (value > 0) bar.classList.add('black');
            else if (value < 0) bar.classList.add('white');
            barContainer.appendChild(bar);
            barContainer.addEventListener('mouseover', () => {
                tooltipEl.style.display = 'block';
                tooltipEl.textContent = `Turn ${i + 1}: ${value > 0 ? '+' : ''}${value.toFixed(0)}`;
                const wrapperRect = graphEl.parentElement.getBoundingClientRect();
                const barRect = barContainer.getBoundingClientRect();
                tooltipEl.style.left = `${barRect.left - wrapperRect.left + barRect.width / 2}px`;
                tooltipEl.style.top = `${barRect.top - wrapperRect.top}px`;
            });
            barContainer.addEventListener('mouseleave', () => { tooltipEl.style.display = 'none'; });
        }
        graphEl.appendChild(barContainer);
    }
}

// ================================================================= //
//                        イベントハンドラ・リスナー                   //
// ================================================================= //

function handleCellClick(r, c) {
    if (isPlaybackMode) return;
    if (!isGameInProgress || isCpuVsCpuMode || currentPlayer !== playerColor || board[r][c] !== EMPTY) return;
    const flippable = getFlippableDiscs(board, r, c, playerColor);
    if (flippable.length === 0) return;
    if (isResearchMode) researchWorker.postMessage({ type: 'stop' });
    placeDisc(r, c, playerColor, flippable);
    currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
    gameController();
}

function renderPlayback(index) {
    if (isGameInProgress) interruptGame();
    isPlaybackMode = true;
    
    playbackIndex = Math.max(0, Math.min(index, gameHistory.length - 1));
    const record = gameHistory[playbackIndex];
    if (record) {
        board = JSON.parse(JSON.stringify(record.boardState));
        lastMove = record.move;
    }
    const score = playbackIndex > 0 ? evaluationHistory[playbackIndex - 1] : null;
    updateEvaluationDisplay(score);
    updateUiState();
    updateGameInfo();
    renderBoard();
    renderEvaluationGraph();
}

const graphWrapperEl = document.getElementById('evaluation-graph-wrapper');

function handleGraphScrub(event) {
    if ((!isGameOver && !document.body.classList.contains('game-interrupted')) || !isDraggingGraph) return;
    const graphRect = graphWrapperEl.getBoundingClientRect();
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const relativeX = clientX - graphRect.left;
    let progress = Math.max(0, Math.min(1, relativeX / graphRect.width));
    const maxTurn = gameHistory.length - 1;
    let turn = Math.round(progress * maxTurn);
    turn = Math.max(0, Math.min(turn, maxTurn));
    if (turn !== lastHoveredTurn) {
        lastHoveredTurn = turn;
        renderPlayback(turn);
    }
}

const onMouseMove = (e) => handleGraphScrub(e);
const onMouseUp = () => {
    if (!isDraggingGraph) return;
    isDraggingGraph = false;
    document.body.classList.remove('graph-dragging');
    lastHoveredTurn = -1;
    window.removeEventListener('mousemove', onMouseMove);
    window.removeEventListener('mouseup', onMouseUp);
};
graphWrapperEl.addEventListener('mousedown', (event) => {
    if ((!isGameOver && !document.body.classList.contains('game-interrupted')) || event.button !== 0) return;
    isDraggingGraph = true;
    document.body.classList.add('graph-dragging');
    handleGraphScrub(event);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
});
const onTouchMove = (e) => {
    if (isDraggingGraph) {
        e.preventDefault();
        handleGraphScrub(e);
    }
};
const onTouchEnd = () => {
    if (!isDraggingGraph) return;
    isDraggingGraph = false;
    document.body.classList.remove('graph-dragging');
    lastHoveredTurn = -1;
    window.removeEventListener('touchmove', onTouchMove);
    window.removeEventListener('touchend', onTouchEnd);
};
graphWrapperEl.addEventListener('touchstart', (event) => {
    if (!isGameOver && !document.body.classList.contains('game-interrupted')) return;
    isDraggingGraph = true;
    document.body.classList.add('graph-dragging');
    handleGraphScrub(event);
    window.addEventListener('touchmove', onTouchMove, { passive: false });
    window.addEventListener('touchend', onTouchEnd);
}, { passive: true });


function showModal(message, confirmText, cancelText, onConfirm, onCancel) {
    modalMessage.innerHTML = message;
    modalConfirmBtn.textContent = confirmText;
    modalCancelBtn.textContent = cancelText;
    modalConfirmBtn.onclick = () => { hideModal(); onConfirm(); };
    modalCancelBtn.onclick = () => { hideModal(); onCancel(); };
    modalOverlay.classList.add('visible');
}

function hideModal() {
    modalOverlay.classList.remove('visible');
}

startButton.addEventListener('click', () => {
    if (isGameInProgress) {
        interruptGame();
    } else {
        // ★★★ 変更点: isGameOverのチェックを外す ★★★
        if (gameHistory.length > 1) {
            showModal('最初から始めますか？<br>それとも現在の局面から再開しますか？', '最初から', 'この局面から再開',
                () => setupAndStartGame(false, false),
                () => setupAndStartGame(false, true)
            );
        } else {
            setupAndStartGame(false, false);
        }
    }
});

cpuVsCpuButton.addEventListener('click', () => {
    if (isGameInProgress) return;
    // ★★★ 変更点: isGameOverのチェックを外す ★★★
    if (gameHistory.length > 1) {
         showModal('CPU戦を最初から始めますか？<br>それとも現在の局面から開始しますか？', '最初から', 'この局面から',
            () => setupAndStartGame(true, false),
            () => setupAndStartGame(true, true)
        );
    } else {
        setupAndStartGame(true, false);
    }
});

kifuStartBtn.addEventListener('click', () => { if (!kifuStartBtn.disabled) renderPlayback(0); });
kifuPrevBtn.addEventListener('click', () => { if (!kifuPrevBtn.disabled) renderPlayback(isPlaybackMode ? playbackIndex - 1 : turnCount - 1); });
kifuNextBtn.addEventListener('click', () => { if (!kifuNextBtn.disabled) renderPlayback(isPlaybackMode ? playbackIndex + 1 : turnCount + 1); });
kifuEndBtn.addEventListener('click', () => { if (!kifuEndBtn.disabled) renderPlayback(gameHistory.length - 1); });

undoButton.addEventListener('click', () => {
    if (undoButton.disabled) return;
    if (isResearchMode) researchButton.click();
    gameHistory.splice(-2, 2);
    evaluationHistory.splice(-2, 2);
    turnCount -= 2;
    undoCount++;
    wasUndo = true;
    const lastState = gameHistory[gameHistory.length - 1];
    board = JSON.parse(JSON.stringify(lastState.boardState));
    lastMove = lastState.move;
    currentPlayer = playerColor;
    const lastEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : null;
    updateEvaluationDisplay(lastEval);
    gameController();
});

researchButton.addEventListener('click', () => {
    if (researchButton.disabled) return;
    isResearchMode = !isResearchMode;
    researchButton.classList.toggle('active', isResearchMode);

    if (isResearchMode) {
        researchEvaluations = {};
        currentResearchLevel = 4;
        renderBoard();
        const isPlayerTurn = isGameInProgress && !isCpuVsCpuMode && currentPlayer === playerColor;
        if (isPlayerTurn) {
            updateGameInfo();
            const currentEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : 0;
            const validMoves = getValidMoves(board, playerColor);
            researchWorker.postMessage({
                type: 'start', board, playerColor, turnCount, currentEval, maxAiLevel, validMoves
            });
        }
    } else {
        researchWorker.postMessage({ type: 'stop' });
        researchEvaluations = {};
        currentResearchLevel = 0;
        renderBoard();
        updateGameInfo();
    }
});

playerColorRadios.forEach(radio => { radio.addEventListener('change', () => { if (!isGameInProgress) updateUiState(); }); });

document.addEventListener('keydown', (event) => {
    const kifuActive = isGameOver || isPlaybackMode || (!isGameInProgress && gameHistory.length > 1);
    if (kifuActive) {
        // ↓キーと↑キーをブラウザのデフォルト動作（スクロール）防止対象に追加
        if (['ArrowLeft', 'ArrowRight', 'Home', 'End', 'ArrowDown', 'ArrowUp'].includes(event.key)) {
            event.preventDefault();
        }

        const currentKifuIndex = isPlaybackMode ? playbackIndex : turnCount;
        
        // キーに応じた処理を実行
        if (event.key === 'ArrowLeft' && !kifuPrevBtn.disabled) {
            renderPlayback(currentKifuIndex - 1);
        } else if (event.key === 'ArrowRight' && !kifuNextBtn.disabled) {
            renderPlayback(currentKifuIndex + 1);
        // ↓キーまたはHomeキーで棋譜の最初へ移動
        } else if ((event.key === 'ArrowDown' || event.key === 'Home') && !kifuStartBtn.disabled) {
            renderPlayback(0);
        // ↑キーまたはEndキーで棋譜の最後へ移動
        } else if ((event.key === 'ArrowUp' || event.key === 'End') && !kifuEndBtn.disabled) {
            renderPlayback(gameHistory.length - 1);
        }
    }
});

// ================================================================= //
//                         AI思考ロジック (コア)                      //
// ================================================================= //

async function executeCpuTurn() {
    if (!isGameInProgress) return;
    const currentAiPlayer = isCpuVsCpuMode ? currentPlayer : cpuColor;
    const currentAiLevel = isCpuVsCpuMode 
        ? (currentAiPlayer === BLACK ? parseInt(cpu1LevelSelect.value, 10) : parseInt(cpu2LevelSelect.value, 10))
        : parseInt(cpuLevelSelect.value, 10);
    messageAreaEl.textContent = 'CPUが思考中です...';
    await new Promise(resolve => setTimeout(resolve, 50));
    const move = findBestMove(currentAiPlayer, currentAiLevel);
    if (!isGameInProgress) return;
    if (move) {
        const flippable = getFlippableDiscs(board, move.r, move.c, currentAiPlayer);
        placeDisc(move.r, move.c, currentAiPlayer, flippable);
    }
    currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
    gameController();
}

function findBestMove(aiPlayer, aiLevel) {
    const validMoves = getValidMoves(board, aiPlayer);
    if (validMoves.length === 0) return null;
    if (aiLevel >= 7) {
        const bookMove = OPENING_BOOK[boardToString(board)];
        if (bookMove && validMoves.some(m => m.r === bookMove.r && m.c === bookMove.c)) {
            if ((aiLevel === 9 && Math.random() < 0.2) || (aiLevel === 10 && Math.random() < 0.1)) {} else { return bookMove; }
        }
    }
    const emptyCells = MAX_TURNS - turnCount;
    switch (aiLevel) {
        case 1: return validMoves[Math.floor(Math.random() * validMoves.length)];
        case 2: return validMoves.reduce((best, move) => { const count = getFlippableDiscs(board, move.r, move.c, aiPlayer).length; return count > best.count ? { move, count } : best; }, { move: validMoves[0], count: 0 }).move;
        case 3: return validMoves.reduce((best, move) => { const score = POSITIONAL_SCORE_TABLE[move.r][move.c]; return score > best.score ? { move, score } : best; }, { move: null, score: -Infinity }).move;
        case 4: return alphaBetaSearch(board, 3, -Infinity, Infinity, true, aiPlayer, aiLevel, turnCount).move;
        case 5: return alphaBetaSearch(board, 4, -Infinity, Infinity, true, aiPlayer, aiLevel, turnCount).move;
        case 6: return alphaBetaSearch(board, 5, -Infinity, Infinity, true, aiPlayer, aiLevel, turnCount).move;
        case 7: { let d = (emptyCells > 24) ? 5 : ((emptyCells > 14) ? 6 : 8); return alphaBetaSearch(board, d, -Infinity, Infinity, true, aiPlayer, aiLevel, turnCount).move; }
        case 8: {
            if (emptyCells <= 12) { messageAreaEl.textContent = 'CPUが完全読みに移行...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
            let depth = (emptyCells > 22) ? 6 : 7; return alphaBetaSearch(board, depth, -Infinity, Infinity, true, aiPlayer, aiLevel, turnCount).move;
        }
        case 9: {
            if (emptyCells <= 12) { messageAreaEl.textContent = 'CPUが完全読みに移行...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
            let depth = (emptyCells > 22) ? 6 : 7; return findBestMoveWithVariety(board, depth, aiPlayer, 8, turnCount);
        }
        case 10: {
            if (emptyCells <= 14) { messageAreaEl.textContent = 'CPUが完全読みに移行...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
            let depth = (emptyCells > 24) ? 7 : 8; return alphaBetaSearch(board, depth, -Infinity, Infinity, true, aiPlayer, aiLevel, turnCount).move;
        }
        default: return validMoves[0];
    }
}

function findBestMoveWithVariety(currentBoard, depth, aiPlayer, level, turnCount) {
    const validMoves = getValidMoves(currentBoard, aiPlayer);
    const moveEvals = [];
    for (const move of validMoves) {
        const newBoard = JSON.parse(JSON.stringify(currentBoard));
        placeDiscInBoard(newBoard, move.r, move.c, aiPlayer, getFlippableDiscs(newBoard, move.r, move.c, aiPlayer));
        const result = alphaBetaSearch(newBoard, depth - 1, -Infinity, Infinity, false, aiPlayer, level, turnCount + 1);
        moveEvals.push({ move, score: result.score });
    }
    if (moveEvals.length === 0) return null;
    const bestScore = Math.max(...moveEvals.map(e => e.score));
    const threshold = 50; 
    const bestMoves = moveEvals.filter(e => e.score >= bestScore - threshold);
    if (bestMoves.length > 0) return bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
    return moveEvals.reduce((best, current) => current.score > best.score ? current : best).move;
}

function alphaBetaSearch(currentBoard, depth, alpha, beta, isMaximizingNode, maximizingPlayer, currentLevel, turnCount) {
    const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
    if (depth === 0 || emptyCells === 0) return { score: evaluateBoard(currentBoard, maximizingPlayer, currentLevel, turnCount) };
    const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
    const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
    let validMoves = getValidMoves(currentBoard, playerForThisNode);
    if (validMoves.length === 0) {
        if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, true) };
        return alphaBetaSearch(currentBoard, depth, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel, turnCount);
    }
    let bestResult = { move: null, score: isMaximizingNode ? -Infinity : Infinity };
    if (depth >= 4 && currentLevel >= 8) {
        const moveScores = validMoves.map(move => {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
            return { move, score: evaluateBoard(newBoard, maximizingPlayer, currentLevel, turnCount + 1) };
        });
        if (isMaximizingNode) moveScores.sort((a, b) => b.score - a.score);
        else moveScores.sort((a, b) => a.score - b.score);
        validMoves = moveScores.map(ms => ms.move);
    }
    bestResult.move = validMoves[0]; 
    for (const move of validMoves) {
        const newBoard = JSON.parse(JSON.stringify(currentBoard));
        placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
        const result = alphaBetaSearch(newBoard, depth - 1, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel, turnCount + 1);
        if (isMaximizingNode) {
            if (result.score > bestResult.score) bestResult = { move, score: result.score };
            alpha = Math.max(alpha, bestResult.score);
        } else {
            if (result.score < bestResult.score) bestResult = { move, score: result.score };
            beta = Math.min(beta, bestResult.score);
        }
        if (beta <= alpha) break; 
    }
    return bestResult;
}

function perfectSearch(currentBoard, alpha, beta, isMaximizingNode, maximizingPlayer) {
    const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
    if (emptyCells === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, false) };
    const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
    const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
    const validMoves = getValidMoves(currentBoard, playerForThisNode);
    if (validMoves.length === 0) {
        if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, false) };
        return perfectSearch(currentBoard, alpha, beta, !isMaximizingNode, maximizingPlayer);
    }
    let bestResult = { move: validMoves[0], score: isMaximizingNode ? -Infinity : Infinity };
    for (const move of validMoves) {
        const newBoard = JSON.parse(JSON.stringify(currentBoard));
        placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
        const result = perfectSearch(newBoard, alpha, beta, !isMaximizingNode, maximizingPlayer);
        if (isMaximizingNode) {
            if (result.score > bestResult.score) bestResult = { move, score: result.score };
            alpha = Math.max(alpha, bestResult.score);
        } else {
            if (result.score < bestResult.score) bestResult = { move, score: result.score };
            beta = Math.min(beta, bestResult.score);
        }
        if (beta <= alpha) break;
    }
    return bestResult;
}

// ================================================================= //
//                           AI評価関数                             //
// ================================================================= //

function evaluateBoardForLevel9(board, player, currentTurn) {
    const opponent = (player === BLACK) ? WHITE : BLACK;
    const positionalScore = simplePositionalEvaluation(board, player);
    const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
    const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
    let cornerPenalty = 0;
    const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
    const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
    for (let i = 0; i < 4; i++) {
        if (board[corners[i].r][corners[i].c] === EMPTY) {
            if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 300;
            if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 300;
        }
    }
    let positionalWeight, mobilityWeight, fixedDiscWeight;
    if (currentTurn < 20) { positionalWeight = 1.0; mobilityWeight = 90; fixedDiscWeight = 130; } 
    else if (currentTurn < 45) { positionalWeight = 1.0; mobilityWeight = 65; fixedDiscWeight = 220; } 
    else { positionalWeight = 0.5; mobilityWeight = 45; fixedDiscWeight = 350; }
    let edgeControlScore = 0;
    const edges = [
        {line: board[0], corners: [board[0][0], board[0][7]]}, {line: board[7], corners: [board[7][0], board[7][7]]},
        {line: board.map(row => row[0]), corners: [board[0][0], board[7][0]]}, {line: board.map(row => row[7]), corners: [board[0][7], board[7][7]]},
    ];
    for (const edge of edges) {
        if (edge.corners[0] === EMPTY || edge.corners[1] === EMPTY) {
            let myStones = 0, oppStones = 0;
            for(let i = 1; i < 7; i++) {
                if (edge.line[i] === player) myStones++;
                else if (edge.line[i] === opponent) oppStones++;
            }
            edgeControlScore += (oppStones - myStones);
        }
    }
    const edgeControlWeight = 35;
    return (positionalScore * positionalWeight) + (mobilityScore * mobilityWeight) + (fixedDiscScore * fixedDiscWeight) + cornerPenalty + (edgeControlScore * edgeControlWeight);
}

function evaluateBoard(board, player, level, currentTurn) {
    if (level >= 10) return evaluateBoardForLevel9(board, player, currentTurn);
    if (level >= 8) return evaluateBoardForLevel8(board, player, currentTurn);
    if (level >= 6) return advancedPositionalEvaluation(board, player);
    return simplePositionalEvaluation(board, player);
}

function simplePositionalEvaluation(board, player) {
    let score = 0;
    const opponent = (player === BLACK) ? WHITE : BLACK;
    for (let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) {
        if(board[r][c]===player) score+=POSITIONAL_SCORE_TABLE[r][c];
        else if(board[r][c]===opponent) score-=POSITIONAL_SCORE_TABLE[r][c];
    }
    return score;
}

function advancedPositionalEvaluation(board, player) {
    const opponent = (player === BLACK) ? WHITE : BLACK;
    const positionalScore = simplePositionalEvaluation(board, player);
    const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
    const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
    return positionalScore + (mobilityScore * 50) + (fixedDiscScore * 150);
}

function evaluateBoardForLevel8(board, player, currentTurn) {
    const opponent = (player === BLACK) ? WHITE : BLACK;
    const positionalScore = simplePositionalEvaluation(board, player);
    const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
    const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
    let cornerPenalty = 0;
    const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
    const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
    for (let i = 0; i < 4; i++) {
        if (board[corners[i].r][corners[i].c] === EMPTY) {
            if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 250;
            if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 250;
        }
    }
    let positionalWeight, mobilityWeight, fixedDiscWeight;
    if (currentTurn < 20) { positionalWeight=1; mobilityWeight=80; fixedDiscWeight=120; } 
    else if (currentTurn < 48) { positionalWeight=1; mobilityWeight=60; fixedDiscWeight=180; } 
    else { positionalWeight=0.5; mobilityWeight=40; fixedDiscWeight=250; }
    return (positionalScore*positionalWeight) + (mobilityScore*mobilityWeight) + (fixedDiscScore*fixedDiscWeight) + cornerPenalty;
}

function evaluateByStoneCount(board, player, isFromAlphaBeta) {
    let score = 0;
    board.flat().forEach(c => { if (c === player) score++; else if (c !== EMPTY) score--; });
    return isFromAlphaBeta ? score * 1000 : score;
}

// ================================================================= //
//                       ルール・ユーティリティ関数                      //
// ================================================================= //

function placeDisc(r, c, player, flippable) {
    board[r][c] = player;
    flippable.forEach(pos => { board[pos.r][pos.c] = player; });
    lastMove = { r, c };
    turnCount++;
    gameHistory.push({ move: { r, c }, boardState: JSON.parse(JSON.stringify(board)) });
    if (!isPlaybackMode) {
        const currentAiLevel = isCpuVsCpuMode 
            ? (currentPlayer === BLACK ? parseInt(cpu1LevelSelect.value, 10) : parseInt(cpu2LevelSelect.value, 10))
            : parseInt(cpuLevelSelect.value, 10);
        const score = evaluateBoard(board, BLACK, currentAiLevel, turnCount);
        evaluationHistory.push(score);
        updateEvaluationDisplay(score);
        renderEvaluationGraph();
    }
    playbackIndex = turnCount;
}

function placeDiscInBoard(b, r, c, player, flippable) {
    b[r][c] = player;
    flippable.forEach(p => { b[p.r][p.c] = player; });
}

function getFlippableDiscs(currentBoard, r, c, player) {
    const flippable = [];
    if (currentBoard[r][c] !== EMPTY) return flippable;
    const opponent = (player === BLACK) ? WHITE : BLACK;
    for (const dir of DIRECTIONS) {
        const line = [];
        let currR = r + dir.r, currC = c + dir.c;
        while (currR >= 0 && currR < BOARD_SIZE && currC >= 0 && currC < BOARD_SIZE) {
            if (currentBoard[currR][currC] === opponent) line.push({r: currR, c: currC});
            else if (currentBoard[currR][currC] === player) { flippable.push(...line); break; } 
            else break;
            currR += dir.r; currC += dir.c;
        }
    }
    return flippable;
}

function getValidMoves(currentBoard, player) {
    const moves = [];
    for (let r=0; r<BOARD_SIZE; r++) for (let c=0; c<BOARD_SIZE; c++) {
        if (currentBoard[r][c] === EMPTY && getFlippableDiscs(currentBoard, r, c, player).length > 0) {
            moves.push({r, c});
        }
    }
    return moves;
}

function getStableDiscs(board, player) {
    const stable = Array.from({length: 8}, () => Array(8).fill(false));
    const directions = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]];
    if (board[0][0] === player) stable[0][0] = true; if (board[0][7] === player) stable[0][7] = true;
    if (board[7][0] === player) stable[7][0] = true; if (board[7][7] === player) stable[7][7] = true;
    let changed = true;
    while(changed) {
        changed = false;
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
            if(board[r][c] === player && !stable[r][c]) {
                let isStable = true;
                for(let i=0; i<4; i++) {
                    const [d1r,d1c]=directions[i*2], [d2r,d2c]=directions[i*2+1];
                    let line1_filled = true, line2_filled = true;
                    let nr = r + d1r, nc = c + d1c;
                    while(nr>=0&&nr<8&&nc>=0&&nc<8) { if(board[nr][nc]!==player&&!stable[nr][nc]){line1_filled=false;break;} nr+=d1r; nc+=d1c; }
                    nr = r + d2r, nc = c + d2c;
                    while(nr>=0&&nr<8&&nc>=0&&nc<8) { if(board[nr][nc]!==player&&!stable[nr][nc]){line2_filled=false;break;} nr+=d2r; nc+=d2c; }
                    if (!line1_filled && !line2_filled) { isStable=false; break; }
                }
                if(isStable) { stable[r][c] = true; changed = true; }
            }
        }
    }
    const stableDiscs = [];
    for (let r=0; r<8; r++) for(let c=0; c<8; c++) if(stable[r][c]) stableDiscs.push({r,c});
    return stableDiscs;
}

function boardToString(b) {
    return b.flat().join('');
}

// --- ゲームの初回起動 ---
resetGame();
    </script>
</body>
</html>
