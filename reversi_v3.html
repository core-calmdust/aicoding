<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    
    <title>【強力AI搭載】無料で遊べるリバーシ（オセロ）ゲーム - ブラウザで今すぐ対戦！</title>
    <meta name="description" content="8段階の強さから選べる強力なAIを搭載した無料のリバーシ（オセロ）ゲームです。登録不要、インストール不要でブラウザですぐにプレイ可能。CPUとの対戦や棋譜再生機能も充実。あなたの挑戦をお待ちしています！">
    <meta name="keywords" content="リバーシ, オセロ, ゲーム, 無料, AI, CPU, 対戦, ブラウザゲーム, オンライン, 思考エンジン, 定石, 棋譜">
    <link rel="canonical" href="https://core-calmdust.github.io/aicoding/reversi_v3.html">
    <link rel="icon" href="https://core-calmdust.github.io/aicoding/images/reversi_favicon.ico" type="image/x-icon">

    <meta property="og:title" content="【強力AI搭載】無料で遊べるリバーシ（オセロ）ゲーム">
    <meta property="og:description" content="8段階の強さから選べる強力AI搭載！ブラウザで今すぐプレイできる無料リバーシゲーム。">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://core-calmdust.github.io/aicoding/reversi_v3.html">
    <meta property="og:image" content="https://core-calmdust.github.io/aicoding/images/reversi-ogp.png">
    <meta property="og:site_name" content="無料リバーシゲーム">
    <meta property="og:locale" content="ja_JP">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="【強力AI搭載】無料で遊べるリバーシ（オセロ）ゲーム">
    <meta name="twitter:description" content="8段階の強さから選べる強力AI搭載！ブラウザで今すぐプレイできる無料リバーシゲーム。">
    <meta name="twitter:image" content="https://core-calmdust.github.io/aicoding/images/reversi-ogp.png"> 
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1e2a38;
            --surface-color: #2c3e50;
            --board-bg: #008080;
            --border-color: #1a2531;
            --text-color: #ecf0f1;
            --text-muted-color: #bdc3c7;
            --accent-color: #3498db;
            --accent-hover-color: #2980b9;
            --danger-color: #e74c3c;
            --highlight-color: rgba(255, 255, 0, 0.7);
            --board-size-pc: 600px;
            --board-size-sp: 90vw;
            --graph-inner-bg-color: #3b526a;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans JP', sans-serif; background-color: var(--bg-color); color: var(--text-color);
            display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; padding: 10px;
        }

        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        
        main {
            width: 100%;
            max-width: 850px;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 20px;
        }
        
        .top-container {
            display: flex;
            gap: 20px;
            width: 100%;
            align-items: flex-start;
        }

        .sidebar {
            width: 240px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-shrink: 0;
        }

        .game-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%;
            background-color: var(--board-bg); border: 5px solid var(--surface-color); border-radius: 8px; padding: 5px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3), inset 0 2px 5px rgba(0, 0, 0, 0.2); aspect-ratio: 1 / 1;
        }

        .cell {
            width: 100%; height: 100%; border: 1px solid rgba(0, 0, 0, 0.2);
            display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative;
        }

        .disc {
            width: 85%; height: 85%; border-radius: 50%;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }

        .disc.black { background: radial-gradient(circle at 30% 30%, #444, #111); }
        .disc.white { background: radial-gradient(circle at 70% 70%, #fff, #ccc); box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 -2px 4px rgba(0, 0, 0, 0.2); }
        .last-move { outline: 3px solid var(--highlight-color); outline-offset: -3px; border-radius: 2px; }

        .valid-move-hint::after {
            content: ''; display: block; width: 35%; height: 35%;
            background-color: rgba(255, 255, 255, 0.3); border-radius: 50%;
            pointer-events: none; transition: background-color 0.2s;
        }
        .valid-move-hint:hover::after { background-color: rgba(255, 255, 255, 0.5); }

        .controls, .game-info, #evaluation-graph-container, .test-controls {
            background-color: var(--surface-color); padding: 20px;
            border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); width: 100%;
        }
        
        #message-area { font-size: 18px; font-weight: bold; color: var(--danger-color); height: 25px; text-align: center; }
        
        .controls label,
        .test-controls label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-muted-color);
            font-size: 14px;
            font-weight: bold;
        }
        
        .test-controls h2 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--text-color);
            font-size: 1.1em;
        }
        
        .controls select, .test-controls select {
            width: 100%; padding: 12px; border-radius: 6px; border: 1px solid var(--border-color);
            background-color: var(--bg-color); color: var(--text-color); font-size: 16px;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23bdc3c7%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.3-5.5-12.8z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat; background-position: right 12px center; background-size: 12px; cursor: pointer;
        }

        .controls button, .test-controls button {
            width: 100%; padding: 12px; margin-top: 10px; border-radius: 6px; border: none;
            background-color: var(--accent-color); color: white; font-size: 16px; font-weight: bold;
            cursor: pointer; transition: background-color 0.2s ease-in-out;
        }
        
        .controls button:hover, .test-controls button:hover { background-color: var(--accent-hover-color); }
        
        .start-controls-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }
        
        .radio-group { display: flex; gap: 10px; justify-content: flex-start; }
        
        .radio-group label {
            position: relative; width: 48px; height: 48px;
            display: flex; justify-content: center; align-items: center;
            padding: 0; border: 3px solid var(--border-color);
            border-radius: 50%; cursor: pointer; transition: all 0.2s;
            background-color: transparent;
        }
        .radio-group label:hover { border-color: var(--text-muted-color); }
        .radio-group input { display: none; }
        .radio-group label:has(input:checked) {
            border-color: var(--accent-color);
            box-shadow: 0 0 8px var(--accent-color);
        }
        .radio-group label:has(input:disabled) { cursor: not-allowed; opacity: 0.5; }
        
        .radio-group .disc {
            width: 85%; height: 85%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 2px rgba(255,255,255,0.2);
        }
        .radio-group .disc.white { box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 -1px 2px rgba(0,0,0,0.2); }
        
        #start-button {
            background: #cccccc; border: none; padding: 0;
            border-radius: 8px; width: 48px; height: 48px;
            cursor: pointer; transition: all 0.2s ease;
            display: flex; justify-content: center; align-items: center;
            flex-shrink: 0; margin: 0;
        }
        #start-button:hover:not(:disabled) { background-color: #b0b0b0; }
        #start-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #6a6a6a; }
        #start-button img { width: 70%; height: 70%; opacity: 0.9; }

        .controls button:disabled, .test-controls button:disabled { background-color: #555; cursor: not-allowed; }
        
        .game-info {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 15px 20px; flex-grow: 1; gap: 15px;
        }
        #turn-info { display: flex; align-items: baseline; gap: 0.5em; font-family: 'Roboto', sans-serif; }
        #turn-count-label { font-size: 1em; font-weight: 700; color: var(--text-muted-color); }
        #turn-count-number { font-size: 1.8em; font-weight: 700; min-width: 2ch; text-align: left; }
        #score-info {
            display: flex; align-items: center; justify-content: center; gap: 8px;
            font-size: 1.6em; font-weight: 700; font-family: 'Roboto', sans-serif;
        }
        #score-info .disc { width: 28px; height: 28px; }
        #black-score, #white-score { min-width: 2.5ch; text-align: center; display: inline-block; }
        
        #evaluation-graph-container { padding: 10px 15px; height: auto; }

        #current-evaluation-display {
            text-align: center;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 700;
            color: var(--text-muted-color);
            margin-bottom: 10px;
            height: 20px;
        }

        #evaluation-graph-wrapper-outer { display: flex; width: 100%; height: 80px; }
        #evaluation-y-axis {
            display: flex; flex-direction: column; justify-content: space-between; align-items: flex-start;
            height: 100%; font-size: 10px; color: var(--text-muted-color);
            margin-right: 8px; width: 25px; flex-shrink: 0; font-family: 'Roboto', sans-serif;
        }
        #evaluation-graph-wrapper { flex-grow: 1; position: relative; overflow: hidden; cursor: default; }
        body.game-over #evaluation-graph-wrapper { cursor: grab; }
        body.graph-dragging #evaluation-graph-wrapper { cursor: grabbing; }

        #evaluation-graph {
            display: flex; height: 100%; position: relative; background-color: var(--graph-inner-bg-color);
            border-left: 1px solid var(--border-color); border-right: 1px solid var(--border-color);
        }
        #evaluation-graph::before {
            content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 1px;
            background-color: var(--border-color); transform: translateY(-50%); z-index: 1;
        }
        .bar-container { flex: 1; height: 100%; position: relative; transition: background-color 0.2s; }
        .bar-container:hover { background-color: rgba(52, 152, 219, 0.1); }
        .bar-container.current-turn-highlight { background-color: rgba(255, 255, 0, 0.2); }
        
        .bar {
            width: 70%; position: absolute; left: 15%; transition: height 0.3s ease, background-color 0.2s; z-index: 2;
        }
        .bar.black { background-color: #444; bottom: 50%; }
        .bar.white { background-color: #eee; top: 50%; }
        .bar-container:hover .bar.black { background-color: #666; }
        .bar-container:hover .bar.white { background-color: #fff; }
        #evaluation-tooltip {
            position: absolute; display: none; background-color: var(--accent-color); color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;
            pointer-events: none; transform: translate(-50%, -130%); white-space: nowrap; z-index: 10;
        }

        .kifu-buttons { display: flex; gap: 10px; margin-top: 10px; }
        .kifu-buttons button {
            flex: 1; margin-top: 0; padding: 6px; font-size: 16px;
            background-color: #cccccc; border-radius: 8px;
        }
        .kifu-buttons button:hover { background-color: #b0b0b0; }
        .kifu-buttons button:disabled { background-color: #6a6a6a; cursor: not-allowed; }
        .kifu-buttons button img {
            height: 1.2em; vertical-align: middle; opacity: 0.8; transition: opacity 0.2s;
        }
        .kifu-buttons button:hover img { opacity: 1; }
        .kifu-buttons button:disabled img { opacity: 0.4; }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .action-buttons button {
            flex: 1;
            padding: 8px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-muted-color);
            border: 2px solid var(--border-color);
            border-radius: 6px;
        }
        .action-buttons button:not(:disabled):hover {
            border-color: var(--accent-color);
            color: var(--text-color);
        }
        .action-buttons button:disabled {
            opacity: 0.5;
            background-color: var(--bg-color);
            cursor: not-allowed;
        }
        .action-buttons button.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .research-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(12px, 3.5vw, 24px);
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 3px black, -1px -1px 3px black;
            pointer-events: none;
        }
        .research-value.plus { color: #87CEEB; }
        .research-value.minus { color: #F08080; }
        
        .test-cpu-selectors { display: flex; gap: 20px; justify-content: center; }
        .test-cpu-selector { flex: 1; }

        #modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #custom-modal {
            background: var(--surface-color);
            padding: 25px 35px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        #modal-overlay.visible #custom-modal {
            transform: scale(1);
        }
        #modal-message {
            margin: 0;
            font-size: 1.1em;
            color: var(--text-color);
            line-height: 1.6;
        }
        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            justify-content: center;
        }
        .modal-buttons button {
            padding: 10px 24px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        #modal-confirm-btn {
            background: var(--accent-color);
            color: white;
        }
        #modal-confirm-btn:hover {
            background: var(--accent-hover-color);
        }
        #modal-cancel-btn {
            background: var(--bg-color);
            color: var(--text-muted-color);
            border: 2px solid var(--border-color);
        }
        #modal-cancel-btn:hover {
            border-color: var(--text-muted-color);
            color: var(--text-color);
        }

        @media (max-width: 900px) {
            .top-container {
                flex-direction: column;
            }
            .sidebar {
                flex-direction: row;
                width: 100%;
                gap: 10px;
                align-items: stretch;
            }
            .controls, .game-info {
                flex: 1;
                display: flex;
                flex-direction: column;
                padding: 15px;
                justify-content: space-between;
            }
            .game-info {
                gap: 10px;
            }
            #turn-info, #score-info, .action-buttons {
                flex-grow: 1;
                display:flex;
                align-items: center;
                justify-content: center;
            }
            .controls label { font-size: 12px; }
            .controls select { font-size: 14px; padding: 10px; }
            .start-controls-wrapper { padding-top: 10px; margin-top: 10px; }
            .game-area {
                width: 100%;
            }
             #board {
                width: var(--board-size-sp);
                margin: 0 auto;
            }
             #message-area {
                width: 100%;
                margin: 0 0 10px 0;
            }
            #evaluation-graph-container {
                display: block;
            }
        }
        
        @media (max-width: 600px) {
             .sidebar {
                flex-direction: column;
            }
        }
    </style>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org", "@type": "VideoGame", "name": "強力AI搭載リバーシゲーム",
      "description": "8段階の強さから選べる強力なAIを搭載した無料のブラウザリバーシ（オセロ）ゲームです。登録不要ですぐにプレイできます。",
      "gamePlatform": "Web-based game", "applicationCategory": "Game", "operatingSystem": "All",
      "author": { "@type": "Person", "name": "Your Name or Company" }, "offers": { "@type": "Offer", "price": "0", "priceCurrency": "JPY" }
    }
    </script>
</head>
<body>
    <main>
        <div class="game-wrapper">
            <div class="top-container">
                <div class="sidebar">
                    <section class="controls" aria-labelledby="game-settings-heading">
                        <h2 id="game-settings-heading" class="visually-hidden">対戦設定</h2>
                        <label for="cpu-level">あなたの対戦相手:</label>
                        <select id="cpu-level">
                            <option value="1">レベル1 (ランダム)</option>
                            <option value="2">レベル2 (最大反転)</option>
                            <option value="3">レベル3 (場所評価)</option>
                            <option value="4">レベル4 (α-β法 弱)</option>
                            <option value="5">レベル5 (α-β法 強)</option>
                            <option value="6">レベル6 (思考強化)</option>
                            <option value="7">レベル7 (定石+探索)</option>
                            <option value="8">レベル8 (複合型AI)</option>
                            <option value="9">レベル8+ (レベル8＋多様性)</option>
                            <option value="10" selected>レベル9 (思考深化)</option>
                        </select>
                        
                        <div class="start-controls-wrapper">
                            <div class="radio-group" role="radiogroup" aria-label="手番選択">
                                <label title="先攻 (黒)">
                                    <input type="radio" name="player_color" value="1" checked>
                                    <span class="disc black"></span>
                                </label>
                                <label title="後攻 (白)">
                                    <input type="radio" name="player_color" value="2">
                                    <span class="disc white"></span>
                                </label>
                            </div>
                            <button id="start-button" aria-label="ゲームを開始します">
                                <img src="https://core-calmdust.github.io/aicoding/images/reversi/play.png" alt="開始">
                            </button>
                        </div>
                    </section>
    
                    <section class="game-info" aria-labelledby="game-status-heading">
                        <h2 id="game-status-heading" class="visually-hidden">ゲーム状況</h2>
                        <div id="turn-info">
                            <span id="turn-count-label">TURN</span>
                            <span id="turn-count-number">0</span>
                        </div>
                        <div id="score-info">
                            <span class="disc black"></span>
                            <span id="black-score">2</span>
                            <span class="disc white"></span>
                            <span id="white-score">2</span>
                        </div>
                        <div class="action-buttons">
                            <button id="undo-button" disabled>UNDO</button>
                            <button id="research-button" disabled>RESEARCH</button>
                        </div>
                    </section>
    
                    <section id="evaluation-graph-container">
                        <div id="current-evaluation-display">
                            <span>評価値: </span>
                            <span id="evaluation-value-text">N/A</span>
                        </div>
                         <div id="evaluation-graph-wrapper-outer">
                            <div id="evaluation-y-axis"></div>
                            <div id="evaluation-graph-wrapper">
                                <div id="evaluation-graph"></div>
                                <div id="evaluation-tooltip"></div>
                            </div>
                        </div>
                        <div class="kifu-buttons">
                            <button id="kifu-start" disabled aria-label="最初へ"><img src="https://core-calmdust.github.io/aicoding/images/reversi/<<.png" alt="最初へ"></button>
                            <button id="kifu-prev" disabled aria-label="前へ"><img src="https://core-calmdust.github.io/aicoding/images/reversi/<.png" alt="前へ"></button>
                            <button id="kifu-next" disabled aria-label="次へ"><img src="https://core-calmdust.github.io/aicoding/images/reversi/>.png" alt="次へ"></button>
                            <button id="kifu-end" disabled aria-label="最後へ"><img src="https://core-calmdust.github.io/aicoding/images/reversi/>>.png" alt="最後へ"></button>
                        </div>
                    </section>
                </div>
                <div class="game-area">
                    <div id="board"></div>
                </div>
            </div>
            <div id="message-area" role="status" aria-live="polite"></div>
            <section class="test-controls" aria-labelledby="test-heading">
                <h2 id="test-heading">CPU対戦テスト</h2>
                <div class="test-cpu-selectors">
                    <div class="test-cpu-selector">
                        <label for="cpu1-level">CPU 1 (先攻/黒)</label>
                        <select id="cpu1-level">
                            <option value="1">レベル1</option> <option value="2">レベル2</option> <option value="3">レベル3</option>
                            <option value="4">レベル4</option> <option value="5">レベル5</option> <option value="6">レベル6</option>
                            <option value="7">レベル7</option>
                            <option value="8">レベル8</option>
                            <option value="9">レベル8+</option>
                            <option value="10" selected>レベル9</option>
                        </select>
                    </div>
                    <div class="test-cpu-selector">
                        <label for="cpu2-level">CPU 2 (後攻/白)</label>
                        <select id="cpu2-level">
                            <option value="1">レベル1</option> <option value="2">レベル2</option> <option value="3">レベル3</option>
                            <option value="4">レベル4</option> <option value="5">レベル5</option> <option value="6">レベル6</option>
                            <option value="7" selected>レベル7</option>
                            <option value="8">レベル8</option>
                            <option value="9">レベル8+</option>
                            <option value="10">レベル9</option>
                        </select>
                    </div>
                </div>
                <button id="cpu-vs-cpu-button" aria-label="選択したレベルのCPU同士を対戦させます">CPU VS CPU 開始</button>
            </section>
        </div>
    </main>

    <div id="modal-overlay">
        <div id="custom-modal">
            <p id="modal-message"></p>
            <div class="modal-buttons">
                <button id="modal-confirm-btn"></button>
                <button id="modal-cancel-btn"></button>
            </div>
        </div>
    </div>

    <script id="research-worker-script" type="javascript/worker">
        const EMPTY = 0, BLACK = 1, WHITE = 2;
        const DIRECTIONS = [ { r: -1, c: -1 }, { r: -1, c: 0 }, { r: -1, c: 1 }, { r: 0, c: -1 }, { r: 0, c: 1 }, { r: 1, c: -1 }, { r: 1, c: 0 }, { r: 1, c: 1 } ];
        const POSITIONAL_SCORE_TABLE = [
            [120, -20,  20,   5,   5,  20, -20, 120],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[  5,  -5,   3,   3,   3,   3,  -5,   5],
            [  5,  -5,   3,   3,   3,   3,  -5,   5],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[120, -20,  20,   5,   5,  20, -20, 120]
        ];
        let continueThinking = false;

        function getFlippableDiscs(currentBoard, r, c, player) {
            const flippable = [];
            if (currentBoard[r][c] !== EMPTY) return flippable;
            const opponent = (player === BLACK) ? WHITE : BLACK;
            for (const dir of DIRECTIONS) {
                const line = []; let currR = r + dir.r, currC = c + dir.c;
                while (currR >= 0 && currR < 8 && currC >= 0 && currC < 8) {
                    if (currentBoard[currR][currC] === opponent) line.push({r: currR, c: currC});
                    else if (currentBoard[currR][currC] === player) { flippable.push(...line); break; } 
                    else break;
                    currR += dir.r; currC += dir.c;
                }
            }
            return flippable;
        }

        function getValidMoves(currentBoard, player) {
            const moves = [];
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                if (currentBoard[r][c] === EMPTY && getFlippableDiscs(currentBoard, r, c, player).length > 0) {
                    moves.push({r, c});
                }
            }
            return moves;
        }
        
        function placeDiscInBoard(b, r, c, player, flippable) {
            b[r][c] = player;
            flippable.forEach(p => { b[p.r][p.c] = player; });
        }

        function evaluateBoard(board, player, level, currentTurn) {
            let score = 0;
            const opponent = (player === BLACK) ? WHITE : BLACK;
            for (let r=0; r<8; r++) for(let c=0; c<8; c++) {
                if(board[r][c]===player) score+=POSITIONAL_SCORE_TABLE[r][c];
                else if(board[r][c]===opponent) score-=POSITIONAL_SCORE_TABLE[r][c];
            }
            if (level < 6) return score;

            const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
            if (level < 8) return score + (mobilityScore * 50);

            let cornerPenalty = 0;
            const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
            const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
            for (let i = 0; i < 4; i++) {
                if (board[corners[i].r][corners[i].c] === EMPTY) {
                    if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 250;
                    if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 250;
                }
            }
            let positionalWeight = 1, mobilityWeight = 80;
            if (currentTurn >= 48) { positionalWeight = 0.5; mobilityWeight = 40; }
            return (score*positionalWeight) + (mobilityScore*mobilityWeight) + cornerPenalty;
        }

        function evaluateByStoneCount(board, player) {
            let score = 0;
            board.flat().forEach(c => { if (c === player) score++; else if (c !== EMPTY) score--; });
            return score * 1000;
        }
        
        function getDepthForLevel(level) {
            if (level <= 4) return 3;
            if (level === 5) return 4;
            if (level === 6) return 5;
            if (level === 7) return 6;
            if (level === 8 || level === 9) return 7;
            return 8;
        }

        function alphaBetaSearch(currentBoard, depth, alpha, beta, isMaximizingNode, maximizingPlayer, level, turnCount) {
            if (depth === 0) return { score: evaluateBoard(currentBoard, maximizingPlayer, level, turnCount) };
            
            const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
            const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
            let validMoves = getValidMoves(currentBoard, playerForThisNode);
            
            if (validMoves.length === 0) {
                if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer) };
                return alphaBetaSearch(currentBoard, depth, alpha, beta, !isMaximizingNode, maximizingPlayer, level, turnCount);
            }
            
            let bestResult = { move: null, score: isMaximizingNode ? -Infinity : Infinity };
            bestResult.move = validMoves[0];

            for (const move of validMoves) {
                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
                const result = alphaBetaSearch(newBoard, depth - 1, alpha, beta, !isMaximizingNode, maximizingPlayer, level, turnCount + 1);
                if (isMaximizingNode) {
                    if (result.score > bestResult.score) bestResult = { move, score: result.score };
                    alpha = Math.max(alpha, bestResult.score);
                } else {
                    if (result.score < bestResult.score) bestResult = { move, score: result.score };
                    beta = Math.min(beta, bestResult.score);
                }
                if (beta <= alpha) break; 
            }
            return bestResult;
        }

        self.onmessage = (e) => {
            const { type, board, playerColor, turnCount, currentEval, maxAiLevel } = e.data;
            if (type === 'stop') {
                continueThinking = false;
                return;
            }
            
            continueThinking = true;
            const validMoves = getValidMoves(board, playerColor);
            
            (async () => {
                for (let level = 5; level <= maxAiLevel; level++) {
                    if (!continueThinking) break;
                    
                    const moveEvals = {};
                    const depth = getDepthForLevel(level);

                    for (const move of validMoves) {
                        if (!continueThinking) break;
                        const tempBoard = JSON.parse(JSON.stringify(board));
                        const flippable = getFlippableDiscs(tempBoard, move.r, move.c, playerColor);
                        placeDiscInBoard(tempBoard, move.r, move.c, playerColor, flippable);
                        
                        const result = alphaBetaSearch(tempBoard, depth, -Infinity, Infinity, false, BLACK, level, turnCount + 1);
                        let diff = result.score - currentEval;
                        if (playerColor === WHITE) diff = -diff;
                        
                        moveEvals[`${move.r},${move.c}`] = diff;
                    }
                    
                    if (continueThinking) {
                        self.postMessage({ type: 'evalUpdate', evaluations: moveEvals });
                    }
                }
            })();
        };
    </script>
    <script>
    // ================================================================= //
    //                             定数と変数定義                         //
    // ================================================================= //

    const BOARD_SIZE = 8, EMPTY = 0, BLACK = 1, WHITE = 2;
    const DIRECTIONS = [ { r: -1, c: -1 }, { r: -1, c: 0 }, { r: -1, c: 1 }, { r: 0, c: -1 }, { r: 0, c: 1 }, { r: 1, c: -1 }, { r: 1, c: 0 }, { r: 1, c: 1 } ];
    const MAX_TURNS = 60;
    const EVAL_GRAPH_INITIAL_SCALE = 500;
    const POSITIONAL_SCORE_TABLE = [
        [120, -20,  20,   5,   5,  20, -20, 120],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[  5,  -5,   3,   3,   3,   3,  -5,   5],
        [  5,  -5,   3,   3,   3,   3,  -5,   5],[ 20,  -5,  15,   3,   3,  15,  -5,  20],[-20, -40,  -5,  -5,  -5,  -5, -40, -20],[120, -20,  20,   5,   5,  20, -20, 120]
    ];
    const OPENING_BOOK = {
        "0000000000000000000000000001200000021000000000000000000000000000": {r:4, c:5},"0000000000000000000000000012100000012000000000000000000000000000": {r:5, c:5},
        "0000000000000000000000000002100000012100000000000000000000000000": {r:2, c:3},"0000000000000000000001000001210000021100000000000000000000000000": {r:2, c:2},
        "0000000000000000000000000011200000012000000000000000000000000000": {r:5, c:2},"000000000000000000000000000210000001110000000000000000000000000": {r:5, c:3},
    };
    
    const boardEl = document.getElementById('board');
    const blackScoreEl = document.getElementById('black-score');
    const whiteScoreEl = document.getElementById('white-score');
    const turnCountNumberEl = document.getElementById('turn-count-number');
    const messageAreaEl = document.getElementById('message-area');
    const cpuLevelSelect = document.getElementById('cpu-level');
    const startButton = document.getElementById('start-button');
    const playerColorRadios = document.querySelectorAll('input[name="player_color"]');
    const cpu1LevelSelect = document.getElementById('cpu1-level');
    const cpu2LevelSelect = document.getElementById('cpu2-level');
    const cpuVsCpuButton = document.getElementById('cpu-vs-cpu-button');
    const kifuStartBtn = document.getElementById('kifu-start');
    const kifuPrevBtn = document.getElementById('kifu-prev');
    const kifuNextBtn = document.getElementById('kifu-next');
    const kifuEndBtn = document.getElementById('kifu-end');
    const evaluationValueTextEl = document.getElementById('evaluation-value-text');
    const undoButton = document.getElementById('undo-button');
    const researchButton = document.getElementById('research-button');
    const modalOverlay = document.getElementById('modal-overlay');
    const modalMessage = document.getElementById('modal-message');
    const modalConfirmBtn = document.getElementById('modal-confirm-btn');
    const modalCancelBtn = document.getElementById('modal-cancel-btn');

    let board, currentPlayer, turnCount, lastMove, playerColor, cpuColor;
    let isCpuVsCpuMode = false, isGameOver = false, isPlaybackMode = false;
    let isGameInProgress = false;
    let wasUndo = false;
    let gameHistory = [], playbackIndex = 0, evaluationHistory = [];
    let isDraggingGraph = false, lastHoveredTurn = -1;
    let undoCount = 0;
    let isResearchMode = false;
    let researchEvaluations = {};
    const maxAiLevel = 10;
    
    const workerScript = document.getElementById('research-worker-script').textContent;
    const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
    const researchWorker = new Worker(URL.createObjectURL(workerBlob));
    
    researchWorker.onmessage = (e) => {
        if (isResearchMode && e.data.type === 'evalUpdate') {
            researchEvaluations = { ...researchEvaluations, ...e.data.evaluations };
            renderBoard();
        }
    };
    
    // ================================================================= //
    //                      メインロジック (ゲーム進行管理)                 //
    // ================================================================= //

    function resetGame() {
        isGameInProgress = false;
        isCpuVsCpuMode = false;
        isPlaybackMode = false;
        isGameOver = false;
        researchWorker.postMessage({ type: 'stop' });
        if(isResearchMode) researchButton.click();

        undoCount = 0;
        document.body.classList.remove('game-over', 'graph-dragging');

        board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
        board[3][3] = WHITE; board[3][4] = BLACK;
        board[4][3] = BLACK; board[4][4] = WHITE;
        
        currentPlayer = BLACK;
        turnCount = 0;
        lastMove = null;
        gameHistory = [{ move: null, boardState: JSON.parse(JSON.stringify(board)) }];
        evaluationHistory = [];
        playbackIndex = 0;
        
        renderBoard();
        renderEvaluationGraph();
        updateEvaluationDisplay(null);
        updateUiState();
        updateGameInfo();
    }
    
    function startGame(isTestMode) {
        isGameInProgress = true;
        isCpuVsCpuMode = isTestMode;
        isGameOver = false;
        
        gameController();
    }
    
    function interruptGame() {
        isGameInProgress = false;
        isCpuVsCpuMode = false;
        researchWorker.postMessage({ type: 'stop' });
        messageAreaEl.textContent = 'ゲームを中断しました';
        updateUiState();
    }

    function resumeGame() {
        isGameInProgress = true;
        gameController();
    }
    
    function startCpuVsCpuFromCurrentState() {
        isGameInProgress = true;
        isCpuVsCpuMode = true;
        isGameOver = false;
        gameController();
    }
    
    async function gameController() {
        if (!isGameInProgress || isGameOver) return;
        
        updateUiState();
        updateGameInfo();
        
        const isPlayerTurn = !isCpuVsCpuMode && currentPlayer === playerColor;
        if (isResearchMode && isPlayerTurn) {
            runShallowResearch();
            renderBoard();
            const currentEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : 0;
            researchWorker.postMessage({
                type: 'start', board, playerColor, turnCount, currentEval, maxAiLevel
            });
        } else {
            renderBoard();
        }

        const canCurrentPlayerMove = getValidMoves(board, currentPlayer).length > 0;
        if (!canCurrentPlayerMove) {
            const opponent = (currentPlayer === BLACK) ? WHITE : BLACK;
            const canOpponentMove = getValidMoves(board, opponent).length > 0;
            
            if (!canOpponentMove) {
                endGame();
                return;
            }
            
            messageAreaEl.textContent = `${currentPlayer === BLACK ? '黒' : '白'}はパスします。`;
            await new Promise(resolve => setTimeout(resolve, 1000));
            currentPlayer = opponent;
            gameController();
            return;
        }

        const isCpuTurnNow = isCpuVsCpuMode || (currentPlayer === cpuColor);
        if (isCpuTurnNow) {
            await executeCpuTurn();
        }
    }

    function endGame() {
        isGameOver = true;
        isGameInProgress = false;
        researchWorker.postMessage({ type: 'stop' });
        document.body.classList.add('game-over');
        
        const blackScore = board.flat().filter(c => c === BLACK).length;
        const whiteScore = board.flat().filter(c => c === WHITE).length;
        const winner = (blackScore > whiteScore) ? BLACK : ((whiteScore > blackScore) ? WHITE : EMPTY);
        
        let message = "引き分けです！";
        if (winner !== EMPTY) {
            if (isCpuVsCpuMode) message = `CPU ${(winner === BLACK ? '1' : '2')} の勝ちです。`;
            else message = (winner === playerColor) ? "🎉 あなたの勝ちです！ 🎉" : "CPUの勝ちです。";
        }
        if (!isCpuVsCpuMode && undoCount > 0) {
            message += ` (待ったの使用回数: ${undoCount}回)`;
        }
        messageAreaEl.textContent = `ゲーム終了！ ${message}`;
        updateUiState();
        updateGameInfo();
        renderEvaluationGraph();
    }

    // ================================================================= //
    //                         UI・描画関連                             //
    // ================================================================= //
    
    function renderBoard() {
        boardEl.innerHTML = '';
        const validMoves = (isGameInProgress && !isCpuVsCpuMode && !isPlaybackMode && currentPlayer === playerColor && !isGameOver) 
            ? getValidMoves(board, currentPlayer) : [];
        
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';

                if (board[r][c] !== EMPTY) {
                    const disc = document.createElement('div');
                    disc.className = `disc ${board[r][c] === BLACK ? 'black' : 'white'}`;
                    cell.appendChild(disc);
                } else {
                    const validMove = validMoves.find(m => m.r === r && m.c === c);
                    if (validMove) {
                        const evalForMove = researchEvaluations[`${r},${c}`];
                        if (isResearchMode && evalForMove !== undefined) {
                            const valueSpan = document.createElement('span');
                            valueSpan.className = 'research-value';
                            valueSpan.textContent = (evalForMove > 0 ? '+' : '') + Math.round(evalForMove);
                            valueSpan.classList.add(evalForMove >= 0 ? 'plus' : 'minus');
                            cell.appendChild(valueSpan);
                        } else {
                            cell.classList.add('valid-move-hint');
                        }
                    }
                }
                if (lastMove && lastMove.r === r && lastMove.c === c) {
                    cell.classList.add('last-move');
                }
                cell.addEventListener('click', () => handleCellClick(r, c));
                boardEl.appendChild(cell);
            }
        }
    }
    
    function updateGameInfo() {
        let blackScore = 0, whiteScore = 0;
        const currentBoard = isPlaybackMode ? JSON.parse(JSON.stringify(gameHistory[playbackIndex].boardState)) : board;
        currentBoard.flat().forEach(cell => {
            if (cell === BLACK) blackScore++;
            if (cell === WHITE) whiteScore++;
        });
        blackScoreEl.textContent = blackScore;
        whiteScoreEl.textContent = whiteScore;
        
        const displayTurn = isPlaybackMode ? playbackIndex : turnCount;
        turnCountNumberEl.textContent = displayTurn;
        
        if (isGameOver) return;

        let message = '';
        if (isPlaybackMode) {
             message = `棋譜再生中 (${displayTurn}手目)`;
        } else if (isGameInProgress) {
            if (isCpuVsCpuMode) {
                 message = `${turnCount + 1}手目: CPU ${currentPlayer === BLACK ? '1' : '2'}のターンです`;
            } else {
                 message = `${turnCount + 1}手目: ${currentPlayer === playerColor ? 'あなたのターンです' : 'CPUのターンです'}`;
            }
        } else if (turnCount > 0) {
            message = '中断中...';
        } else {
             message = '対戦設定を選んで開始してください';
        }

        if (wasUndo) {
            messageAreaEl.textContent = '待った！ ' + message;
            wasUndo = false;
        } else {
            messageAreaEl.textContent = message;
        }
    }
    
    function updateUiState() {
        playerColor = parseInt(document.querySelector('input[name="player_color"]:checked').value, 10);
        cpuColor = (playerColor === BLACK) ? WHITE : BLACK;
        
        const startButtonImg = startButton.querySelector('img');

        if (isGameInProgress && !isGameOver) {
            startButtonImg.src = 'https://core-calmdust.github.io/aicoding/images/reversi/stop.png';
            startButtonImg.alt = '中断';
            startButton.setAttribute('aria-label', 'ゲームを中断します');
        } else {
            startButtonImg.src = 'https://core-calmdust.github.io/aicoding/images/reversi/play.png';
            startButtonImg.alt = '開始';
            startButton.setAttribute('aria-label', 'ゲームを開始します');
        }
        
        const controlsLocked = isGameInProgress || isPlaybackMode;
        cpuLevelSelect.disabled = controlsLocked;
        playerColorRadios.forEach(radio => { radio.disabled = controlsLocked; });
        cpuVsCpuButton.disabled = controlsLocked;
        
        const isPlayerTurn = isGameInProgress && !isCpuVsCpuMode && currentPlayer === playerColor;
        undoButton.disabled = !isPlayerTurn || turnCount < 2;
        researchButton.disabled = isCpuVsCpuMode || !isGameInProgress;
        
        const kifuActive = isGameOver || isPlaybackMode;
        kifuStartBtn.disabled = !kifuActive || playbackIndex === 0;
        kifuPrevBtn.disabled = !kifuActive || playbackIndex === 0;
        kifuNextBtn.disabled = !kifuActive || playbackIndex >= gameHistory.length - 1;
        kifuEndBtn.disabled = !kifuActive || playbackIndex >= gameHistory.length - 1;
    }

    function updateEvaluationDisplay(score) {
        if (score === null || score === undefined) {
            evaluationValueTextEl.textContent = "N/A";
        } else {
            const scoreText = (score > 0 ? '+' : '') + score.toFixed(0);
            evaluationValueTextEl.textContent = scoreText;
        }
    }
    
    function renderEvaluationGraph() {
        const graphEl = document.getElementById('evaluation-graph');
        const yAxisEl = document.getElementById('evaluation-y-axis');
        const tooltipEl = document.getElementById('evaluation-tooltip');
        if (!graphEl || !yAxisEl || !tooltipEl) return;

        graphEl.innerHTML = '';
        const maxAbsValue = evaluationHistory.length > 0 ? Math.max(...evaluationHistory.map(v => Math.abs(v))) : 0;
        const scale = Math.max(EVAL_GRAPH_INITIAL_SCALE, Math.ceil(maxAbsValue / 100) * 100);
        yAxisEl.innerHTML = `<span>+${scale}</span><span>-${scale}</span>`;

        for (let i = 0; i < MAX_TURNS; i++) {
            const barContainer = document.createElement('div');
            barContainer.className = 'bar-container';

            if (isPlaybackMode && i === playbackIndex - 1) {
                barContainer.classList.add('current-turn-highlight');
            }

            if (i < evaluationHistory.length) {
                const value = evaluationHistory[i];
                const bar = document.createElement('div');
                bar.className = 'bar';
                const heightPercentage = Math.min((Math.abs(value) / scale) * 100, 100);
                bar.style.height = `${heightPercentage / 2}%`;
                if (value > 0) bar.classList.add('black');
                else if (value < 0) bar.classList.add('white');
                barContainer.appendChild(bar);

                barContainer.addEventListener('mouseover', () => {
                    tooltipEl.style.display = 'block';
                    tooltipEl.textContent = `Turn ${i + 1}: ${value > 0 ? '+' : ''}${value.toFixed(0)}`;
                    const wrapperRect = graphEl.parentElement.getBoundingClientRect();
                    const barRect = barContainer.getBoundingClientRect();
                    tooltipEl.style.left = `${barRect.left - wrapperRect.left + barRect.width / 2}px`;
                    tooltipEl.style.top = `${barRect.top - wrapperRect.top}px`;
                });
                barContainer.addEventListener('mouseleave', () => {
                    tooltipEl.style.display = 'none';
                });
            }
            graphEl.appendChild(barContainer);
        }
    }
    
    function runShallowResearch() {
        researchEvaluations = {};
        const isPlayerTurn = isGameInProgress && !isCpuVsCpuMode && currentPlayer === playerColor;
        if (!isPlayerTurn) return;

        const validMoves = getValidMoves(board, playerColor);
        const currentEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : 0;
        
        for (const move of validMoves) {
            const tempBoard = JSON.parse(JSON.stringify(board));
            const flippable = getFlippableDiscs(tempBoard, move.r, move.c, playerColor);
            placeDiscInBoard(tempBoard, move.r, move.c, playerColor, flippable);
            
            const result = alphaBetaSearch(tempBoard, 3, -Infinity, Infinity, false, BLACK, 4, turnCount + 1);
            let diff = result.score - currentEval;
            if (playerColor === WHITE) diff = -diff;
            researchEvaluations[`${move.r},${move.c}`] = diff;
        }
    }

    // ================================================================= //
    //                        イベントハンドラ・リスナー                   //
    // ================================================================= //

    function handleCellClick(r, c) {
        if (!isGameInProgress || isCpuVsCpuMode || isPlaybackMode || currentPlayer !== playerColor || board[r][c] !== EMPTY) return;
        
        const flippable = getFlippableDiscs(board, r, c, playerColor);
        if (flippable.length === 0) return;
        
        researchWorker.postMessage({ type: 'stop' });
        researchEvaluations = {};

        placeDisc(r, c, playerColor, flippable);
        currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
        gameController();
    }

    function renderPlayback(index) {
        isPlaybackMode = true;
        isGameInProgress = false;
        researchWorker.postMessage({ type: 'stop' });
        playbackIndex = Math.max(0, Math.min(index, gameHistory.length - 1));
        const record = gameHistory[playbackIndex];
        board = JSON.parse(JSON.stringify(record.boardState));
        lastMove = record.move;
        
        const score = playbackIndex > 0 ? evaluationHistory[playbackIndex - 1] : null;
        updateEvaluationDisplay(score);
        
        updateUiState();
        updateGameInfo();
        renderBoard();
        renderEvaluationGraph();
    }
    
    function handleGraphScrub(event) {
        event.preventDefault();
        if (!isGameOver) return;

        const graphWrapper = document.getElementById('evaluation-graph-wrapper');
        const graphRect = graphWrapper.getBoundingClientRect();
        
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const relativeX = clientX - graphRect.left;
        
        let progress = relativeX / graphRect.width;
        progress = Math.max(0, Math.min(1, progress));

        const maxTurn = gameHistory.length - 1;
        let turn = Math.round(progress * (maxTurn - 1)) + 1;
        turn = Math.max(1, Math.min(turn, maxTurn));

        if (turn !== lastHoveredTurn) {
            lastHoveredTurn = turn;
            renderPlayback(turn);
        }
    }

    function stopGraphScrub() {
        isDraggingGraph = false;
        document.body.classList.remove('graph-dragging');
        lastHoveredTurn = -1;
        window.removeEventListener('mousemove', onGraphMouseMove);
        window.removeEventListener('touchmove', onGraphTouchMove);
        window.removeEventListener('mouseup', onGraphMouseUp);
        window.removeEventListener('touchend', onGraphTouchEnd);
    }
    
    function onGraphMouseMove(event) { if (isDraggingGraph) handleGraphScrub(event); }
    function onGraphTouchMove(event) { if (isDraggingGraph) handleGraphScrub(event); }
    function onGraphMouseUp() { stopGraphScrub(); }
    function onGraphTouchEnd() { stopGraphScrub(); }
    
    const graphWrapper = document.getElementById('evaluation-graph-wrapper');
    graphWrapper.addEventListener('mousedown', (event) => {
        if (!isGameOver) return;
        isDraggingGraph = true;
        document.body.classList.add('graph-dragging');
        handleGraphScrub(event);
        window.addEventListener('mousemove', onGraphMouseMove);
        window.addEventListener('mouseup', onGraphMouseUp, { once: true });
    });
    graphWrapper.addEventListener('touchstart', (event) => {
        if (!isGameOver) return;
        isDraggingGraph = true;
        document.body.classList.add('graph-dragging');
        handleGraphScrub(event);
        window.addEventListener('touchmove', onGraphTouchMove);
        window.addEventListener('touchend', onGraphTouchEnd, { once: true });
    }, { passive: false });

    function showModal(message, confirmText, cancelText, onConfirm, onCancel) {
        modalMessage.innerHTML = message;
        modalConfirmBtn.textContent = confirmText;
        modalCancelBtn.textContent = cancelText;

        modalConfirmBtn.onclick = () => {
            hideModal();
            onConfirm();
        };
        modalCancelBtn.onclick = () => {
            hideModal();
            onCancel();
        };

        modalOverlay.classList.add('visible');
    }

    function hideModal() {
        modalOverlay.classList.remove('visible');
    }

    startButton.addEventListener('click', () => {
        if (isGameInProgress) {
            interruptGame();
        } else {
            if(turnCount > 0 && !isGameOver) {
                showModal('ゲームを再開しますか？<br>それとも最初から始めますか？', '再開', '最初から', 
                    () => resumeGame(), 
                    () => { resetGame(); startGame(false); }
                );
            } else {
                resetGame();
                startGame(false);
            }
        }
    });

    cpuVsCpuButton.addEventListener('click', () => {
        if (isGameInProgress || isPlaybackMode) return;
        if(turnCount > 0 && !isGameOver) {
             showModal('CPU戦を最初から始めますか？<br>それとも今の局面から行いますか？', '最初から', 'この局面から',
                () => { resetGame(); startGame(true); },
                () => startCpuVsCpuFromCurrentState()
            );
        } else {
            resetGame();
            startGame(true);
        }
    });
    
    kifuStartBtn.addEventListener('click', () => { if (!kifuStartBtn.disabled) renderPlayback(0); });
    kifuPrevBtn.addEventListener('click', () => { if (!kifuPrevBtn.disabled) renderPlayback(playbackIndex - 1); });
    kifuNextBtn.addEventListener('click', () => { if (!kifuNextBtn.disabled) renderPlayback(playbackIndex + 1); });
    kifuEndBtn.addEventListener('click', () => { if (!kifuEndBtn.disabled) renderPlayback(gameHistory.length - 1); });
    
    undoButton.addEventListener('click', () => {
        if (undoButton.disabled) return;
        gameHistory.splice(-2, 2);
        evaluationHistory.splice(-2, 2);
        turnCount -= 2;
        undoCount++;
        wasUndo = true;

        const lastState = gameHistory[gameHistory.length - 1];
        board = JSON.parse(JSON.stringify(lastState.boardState));
        lastMove = lastState.move;
        currentPlayer = playerColor;
        
        const lastEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : null;
        updateEvaluationDisplay(lastEval);

        gameController();
    });

    researchButton.addEventListener('click', () => {
        if (researchButton.disabled) return;
        isResearchMode = !isResearchMode;
        researchButton.classList.toggle('active', isResearchMode);
        researchEvaluations = {};

        if (isResearchMode) {
            const isPlayerTurn = isGameInProgress && !isCpuVsCpuMode && currentPlayer === playerColor;
            if (isPlayerTurn) {
                runShallowResearch();
                const currentEval = evaluationHistory.length > 0 ? evaluationHistory[evaluationHistory.length - 1] : 0;
                researchWorker.postMessage({
                    type: 'start', board, playerColor, turnCount, currentEval, maxAiLevel
                });
            }
        } else {
            researchWorker.postMessage({ type: 'stop' });
        }
        renderBoard();
    });
    
    playerColorRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            if (!isGameInProgress) updateUiState();
        });
    });

    document.addEventListener('keydown', (event) => {
        if (isPlaybackMode || isGameOver) {
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(event.key)) {
                event.preventDefault();
            }
            if (event.key === 'ArrowLeft' && !kifuPrevBtn.disabled) kifuPrevBtn.click();
            else if (event.key === 'ArrowRight' && !kifuNextBtn.disabled) kifuNextBtn.click();
            else if (event.key === 'ArrowDown' && !kifuStartBtn.disabled) kifuStartBtn.click();
            else if (event.key === 'ArrowUp' && !kifuEndBtn.disabled) kifuEndBtn.click();
        }
    });

    // ================================================================= //
    //                         AI思考ロジック (コア)                      //
    // ================================================================= //

    async function executeCpuTurn() {
        if (!isGameInProgress) return;

        const currentAiPlayer = isCpuVsCpuMode ? currentPlayer : cpuColor;
        const currentAiLevel = isCpuVsCpuMode 
            ? (currentAiPlayer === BLACK ? parseInt(cpu1LevelSelect.value, 10) : parseInt(cpu2LevelSelect.value, 10))
            : parseInt(cpuLevelSelect.value, 10);

        messageAreaEl.textContent = 'CPUが思考中です...';
        await new Promise(resolve => setTimeout(resolve, 50));
        
        const move = findBestMove(currentAiPlayer, currentAiLevel);
        
        if (!isGameInProgress) return;

        if (move) {
            const flippable = getFlippableDiscs(board, move.r, move.c, currentAiPlayer);
            placeDisc(move.r, move.c, currentAiPlayer, flippable);
        }
        currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
        
        gameController();
    }
    
    function findBestMove(aiPlayer, aiLevel) {
        const validMoves = getValidMoves(board, aiPlayer);
        if (validMoves.length === 0) return null;
        if (aiLevel >= 7) {
            const bookMove = OPENING_BOOK[boardToString(board)];
            if (bookMove && validMoves.some(m => m.r === bookMove.r && m.c === bookMove.c)) {
                if ((aiLevel === 9 || aiLevel === 10) && Math.random() < 0.5) {} else { return bookMove; }
            }
        }
        const emptyCells = MAX_TURNS - turnCount;
        switch (aiLevel) {
            case 1: return validMoves[Math.floor(Math.random() * validMoves.length)];
            case 2: return validMoves.reduce((best, move) => { const count = getFlippableDiscs(board, move.r, move.c, aiPlayer).length; return count > best.count ? { move, count } : best; }, { move: validMoves[0], count: 0 }).move;
            case 3: return validMoves.reduce((best, move) => { const score = POSITIONAL_SCORE_TABLE[move.r][move.c]; return score > best.score ? { move, score } : best; }, { move: null, score: -Infinity }).move;
            case 4: return alphaBetaSearch(board, 3, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
            case 5: return alphaBetaSearch(board, 4, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
            case 6: return alphaBetaSearch(board, 5, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
            case 7: { let d = (emptyCells > 24) ? 5 : ((emptyCells > 14) ? 6 : 8); return alphaBetaSearch(board, d, -Infinity, Infinity, true, aiPlayer, aiLevel).move; }
            case 8: {
                if (emptyCells <= 12) { messageAreaEl.textContent = 'CPUが完全読みに移行...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
                let depth = (emptyCells > 22) ? 6 : 7; return alphaBetaSearch(board, depth, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
            }
            case 9: {
                if (emptyCells <= 12) { messageAreaEl.textContent = 'CPUが完全読みに移行...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
                let depth = (emptyCells > 22) ? 6 : 7; return findBestMoveWithVariety(board, depth, aiPlayer, 8);
            }
            case 10: {
                if (emptyCells <= 14) { messageAreaEl.textContent = 'CPUが完全読みに移行...'; return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move; }
                let depth = (emptyCells > 24) ? 8 : 9; return findBestMoveWithVariety(board, depth, aiPlayer, 10);
            }
            default: return validMoves[0];
        }
    }

    function findBestMoveWithVariety(currentBoard, depth, aiPlayer, level) {
        const validMoves = getValidMoves(currentBoard, aiPlayer);
        const moveEvals = [];
        for (const move of validMoves) {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            placeDiscInBoard(newBoard, move.r, move.c, aiPlayer, getFlippableDiscs(newBoard, move.r, move.c, aiPlayer));
            const result = alphaBetaSearch(newBoard, depth - 1, -Infinity, Infinity, false, aiPlayer, level);
            moveEvals.push({ move, score: result.score });
        }
        if (moveEvals.length === 0) return null;
        const bestScore = Math.max(...moveEvals.map(e => e.score));
        const threshold = 50; 
        const bestMoves = moveEvals.filter(e => e.score >= bestScore - threshold);
        if (bestMoves.length > 0) return bestMoves[Math.floor(Math.random() * bestMoves.length)].move;
        return moveEvals.reduce((best, current) => current.score > best.score ? current : best).move;
    }

    function alphaBetaSearch(currentBoard, depth, alpha, beta, isMaximizingNode, maximizingPlayer, currentLevel) {
        const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
        if (depth === 0 || emptyCells === 0) return { score: evaluateBoard(currentBoard, maximizingPlayer, currentLevel, 60 - emptyCells) };
        const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
        const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
        let validMoves = getValidMoves(currentBoard, playerForThisNode);
        
        if (validMoves.length === 0) {
            if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, true) };
            return alphaBetaSearch(currentBoard, depth, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel);
        }
        
        let bestResult = { move: null, score: isMaximizingNode ? -Infinity : Infinity };
        if (depth >= 4 && currentLevel >= 8) {
            const moveScores = validMoves.map(move => {
                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
                return { move, score: evaluateBoard(newBoard, maximizingPlayer, currentLevel, 60 - emptyCells + 1) };
            });
            if (isMaximizingNode) moveScores.sort((a, b) => b.score - a.score);
            else moveScores.sort((a, b) => a.score - b.score);
            validMoves = moveScores.map(ms => ms.move);
        }
        bestResult.move = validMoves[0]; 

        for (const move of validMoves) {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
            const result = alphaBetaSearch(newBoard, depth - 1, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel);
            if (isMaximizingNode) {
                if (result.score > bestResult.score) bestResult = { move, score: result.score };
                alpha = Math.max(alpha, bestResult.score);
            } else {
                if (result.score < bestResult.score) bestResult = { move, score: result.score };
                beta = Math.min(beta, bestResult.score);
            }
            if (beta <= alpha) break; 
        }
        return bestResult;
    }

    function perfectSearch(currentBoard, alpha, beta, isMaximizingNode, maximizingPlayer) {
        const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
        if (emptyCells === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, false) };
        const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
        const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
        const validMoves = getValidMoves(currentBoard, playerForThisNode);
        if (validMoves.length === 0) {
            if (getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer).length === 0) return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, false) };
            return perfectSearch(currentBoard, alpha, beta, !isMaximizingNode, maximizingPlayer);
        }
        let bestResult = { move: validMoves[0], score: isMaximizingNode ? -Infinity : Infinity };
        for (const move of validMoves) {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
            const result = perfectSearch(newBoard, alpha, beta, !isMaximizingNode, maximizingPlayer);
            if (isMaximizingNode) {
                if (result.score > bestResult.score) bestResult = { move, score: result.score };
                alpha = Math.max(alpha, bestResult.score);
            } else {
                if (result.score < bestResult.score) bestResult = { move, score: result.score };
                beta = Math.min(beta, bestResult.score);
            }
            if (beta <= alpha) break;
        }
        return bestResult;
    }

    // ================================================================= //
    //                           AI評価関数                             //
    // ================================================================= //

    function evaluateBoard(board, player, level, currentTurn) {
        if (level >= 8) return evaluateBoardForLevel8(board, player, currentTurn);
        if (level >= 6) return advancedPositionalEvaluation(board, player);
        return simplePositionalEvaluation(board, player);
    }
    
    function simplePositionalEvaluation(board, player) {
        let score = 0;
        const opponent = (player === BLACK) ? WHITE : BLACK;
        for (let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) {
            if(board[r][c]===player) score+=POSITIONAL_SCORE_TABLE[r][c];
            else if(board[r][c]===opponent) score-=POSITIONAL_SCORE_TABLE[r][c];
        }
        return score;
    }

    function advancedPositionalEvaluation(board, player) {
        const opponent = (player === BLACK) ? WHITE : BLACK;
        const positionalScore = simplePositionalEvaluation(board, player);
        const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
        const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
        return positionalScore + (mobilityScore * 50) + (fixedDiscScore * 150);
    }

    function evaluateBoardForLevel8(board, player, currentTurn) {
        const opponent = (player === BLACK) ? WHITE : BLACK;
        const positionalScore = simplePositionalEvaluation(board, player);
        const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
        const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
        let cornerPenalty = 0;
        const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
        const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
        for (let i = 0; i < 4; i++) {
            if (board[corners[i].r][corners[i].c] === EMPTY) {
                if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 250;
                if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 250;
            }
        }
        let positionalWeight, mobilityWeight, fixedDiscWeight;
        if (currentTurn < 20) { positionalWeight=1; mobilityWeight=80; fixedDiscWeight=120; } 
        else if (currentTurn < 48) { positionalWeight=1; mobilityWeight=60; fixedDiscWeight=180; } 
        else { positionalWeight=0.5; mobilityWeight=40; fixedDiscWeight=250; }
        return (positionalScore*positionalWeight) + (mobilityScore*mobilityWeight) + (fixedDiscScore*fixedDiscWeight) + cornerPenalty;
    }

    function evaluateByStoneCount(board, player, isFromAlphaBeta) {
        let score = 0;
        board.flat().forEach(c => { if (c === player) score++; else if (c !== EMPTY) score--; });
        return isFromAlphaBeta ? score * 1000 : score;
    }

    // ================================================================= //
    //                       ルール・ユーティリティ関数                      //
    // ================================================================= //
    
    function placeDisc(r, c, player, flippable) {
        board[r][c] = player;
        flippable.forEach(pos => { board[pos.r][pos.c] = player; });
        lastMove = { r, c };
        turnCount++;
        gameHistory.push({ move: { r, c }, boardState: JSON.parse(JSON.stringify(board)) });
        
        if (!isPlaybackMode) {
            const score = evaluateBoard(board, BLACK, parseInt(cpuLevelSelect.value, 10), turnCount);
            evaluationHistory.push(score);
            updateEvaluationDisplay(score);
            renderEvaluationGraph();
        }
        playbackIndex = gameHistory.length - 1;
    }
    
    function placeDiscInBoard(b, r, c, player, flippable) {
        b[r][c] = player;
        flippable.forEach(p => { b[p.r][p.c] = player; });
    }

    function getFlippableDiscs(currentBoard, r, c, player) {
        const flippable = [];
        if (currentBoard[r][c] !== EMPTY) return flippable;
        const opponent = (player === BLACK) ? WHITE : BLACK;
        for (const dir of DIRECTIONS) {
            const line = [];
            let currR = r + dir.r, currC = c + dir.c;
            while (currR >= 0 && currR < BOARD_SIZE && currC >= 0 && currC < BOARD_SIZE) {
                if (currentBoard[currR][currC] === opponent) line.push({r: currR, c: currC});
                else if (currentBoard[currR][currC] === player) { flippable.push(...line); break; } 
                else break;
                currR += dir.r; currC += dir.c;
            }
        }
        return flippable;
    }
    
    function getValidMoves(currentBoard, player) {
        const moves = [];
        for (let r=0; r<BOARD_SIZE; r++) for (let c=0; c<BOARD_SIZE; c++) {
            if (currentBoard[r][c] === EMPTY && getFlippableDiscs(currentBoard, r, c, player).length > 0) {
                moves.push({r, c});
            }
        }
        return moves;
    }
    
    function getStableDiscs(board, player) {
        const stable = Array.from({length: 8}, () => Array(8).fill(false));
        const directions = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]];
        if (board[0][0] === player) stable[0][0] = true; if (board[0][7] === player) stable[0][7] = true;
        if (board[7][0] === player) stable[7][0] = true; if (board[7][7] === player) stable[7][7] = true;
        let changed = true;
        while(changed) {
            changed = false;
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                if(board[r][c] === player && !stable[r][c]) {
                    let isStable = true;
                    for(let i=0; i<4; i++) {
                        const [d1r,d1c]=directions[i*2], [d2r,d2c]=directions[i*2+1];
                        let line1_filled = true, line2_filled = true;
                        let nr = r + d1r, nc = c + d1c;
                        while(nr>=0&&nr<8&&nc>=0&&nc<8) { if(board[nr][nc]!==player&&!stable[nr][nc]){line1_filled=false;break;} nr+=d1r; nc+=d1c; }
                        nr = r + d2r, nc = c + d2c;
                        while(nr>=0&&nr<8&&nc>=0&&nc<8) { if(board[nr][nc]!==player&&!stable[nr][nc]){line2_filled=false;break;} nr+=d2r; nc+=d2c; }
                        if (!line1_filled && !line2_filled) { isStable=false; break; }
                    }
                    if(isStable) { stable[r][c] = true; changed = true; }
                }
            }
        }
        const stableDiscs = [];
        for (let r=0; r<8; r++) for(let c=0; c<8; c++) if(stable[r][c]) stableDiscs.push({r,c});
        return stableDiscs;
    }

    function boardToString(b) {
        return b.flat().join('');
    }

    // --- ゲームの初回起動 ---
    resetGame();
    </script>
</body>
</html>
