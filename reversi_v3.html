<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    
    <!-- â–¼â–¼â–¼ SEO/OGPé–¢é€£ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ã“ã“ã‹ã‚‰è¿½åŠ  â–¼â–¼â–¼ -->
    
    <!-- 1. åŸºæœ¬çš„ãªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ -->
    <title>ã€æœ€å¼·AIæ­è¼‰ã€‘ç„¡æ–™ã§éŠã¹ã‚‹ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ  - ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ãå¯¾æˆ¦ï¼</title>
    <meta name="description" content="8æ®µéšã®å¼·ã•ã‹ã‚‰é¸ã¹ã‚‹æœ€å¼·AIã‚’æ­è¼‰ã—ãŸç„¡æ–™ã®ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ ã§ã™ã€‚ç™»éŒ²ä¸è¦ã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸è¦ã§ãƒ–ãƒ©ã‚¦ã‚¶ã§ã™ãã«ãƒ—ãƒ¬ã‚¤å¯èƒ½ã€‚CPUã¨ã®å¯¾æˆ¦ã‚„æ£‹è­œå†ç”Ÿæ©Ÿèƒ½ã‚‚å……å®Ÿã€‚ã‚ãªãŸã®æŒ‘æˆ¦ã‚’ãŠå¾…ã¡ã—ã¦ã„ã¾ã™ï¼">
    <meta name="keywords" content="ãƒªãƒãƒ¼ã‚·, ã‚ªã‚»ãƒ­, ã‚²ãƒ¼ãƒ , ç„¡æ–™, AI, CPU, å¯¾æˆ¦, ãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ , ã‚ªãƒ³ãƒ©ã‚¤ãƒ³, æ€è€ƒã‚¨ãƒ³ã‚¸ãƒ³, å®šçŸ³, æ£‹è­œ">
    <link rel="canonical" href="https://example.com/reversi-game/"> <!-- TODO: ã‚ãªãŸã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã®æ­£å¼ãªURLã«ç½®ãæ›ãˆã¦ãã ã•ã„ -->
    <link rel="icon" href="favicon.ico" type="image/x-icon"> <!-- TODO: favicon.icoã‚’è¨­ç½®ã—ã¦ãã ã•ã„ -->

    <!-- 2. OGP (Open Graph Protocol) ã‚¿ã‚° - Facebookã‚„LINEãªã©ã§ã‚·ã‚§ã‚¢ã•ã‚ŒãŸéš›ã«è¡¨ç¤º -->
    <meta property="og:title" content="ã€æœ€å¼·AIæ­è¼‰ã€‘ç„¡æ–™ã§éŠã¹ã‚‹ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ ">
    <meta property="og:description" content="8æ®µéšã®å¼·ã•ã‹ã‚‰é¸ã¹ã‚‹æœ€å¼·AIæ­è¼‰ï¼ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ããƒ—ãƒ¬ã‚¤ã§ãã‚‹ç„¡æ–™ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ ã€‚">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://example.com/reversi-game/"> <!-- TODO: ã‚ãªãŸã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã®æ­£å¼ãªURLã«ç½®ãæ›ãˆã¦ãã ã•ã„ -->
    <meta property="og:image" content="https://example.com/reversi-ogp.png"> <!-- TODO: ã‚·ã‚§ã‚¢ã•ã‚ŒãŸéš›ã«è¡¨ç¤ºã™ã‚‹ç”»åƒã®URLã«ç½®ãæ›ãˆã¦ãã ã•ã„ (æ¨å¥¨ã‚µã‚¤ã‚º: 1200x630px) -->
    <meta property="og:site_name" content="ç„¡æ–™ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ ">
    <meta property="og:locale" content="ja_JP">

    <!-- 3. Twitterã‚«ãƒ¼ãƒ‰ ã‚¿ã‚° - Twitterã§ã‚·ã‚§ã‚¢ã•ã‚ŒãŸéš›ã«è¡¨ç¤º -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ã€æœ€å¼·AIæ­è¼‰ã€‘ç„¡æ–™ã§éŠã¹ã‚‹ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ ">
    <meta name="twitter:description" content="8æ®µéšã®å¼·ã•ã‹ã‚‰é¸ã¹ã‚‹æœ€å¼·AIæ­è¼‰ï¼ãƒ–ãƒ©ã‚¦ã‚¶ã§ä»Šã™ããƒ—ãƒ¬ã‚¤ã§ãã‚‹ç„¡æ–™ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ ã€‚">
    <meta name="twitter:image" content="https://example.com/reversi-ogp.png"> <!-- TODO: OGPã¨åŒã˜ç”»åƒã®URLã«ç½®ãæ›ãˆã¦ãã ã•ã„ -->

    <!-- â–²â–²â–² SEO/OGPé–¢é€£ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã“ã“ã¾ã§ â–²â–²â–² -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto:wght@500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1e2a38;
            --surface-color: #2c3e50;
            --board-bg: #008080;
            --border-color: #1a2531;
            --text-color: #ecf0f1;
            --text-muted-color: #bdc3c7;
            --accent-color: #3498db;
            --accent-hover-color: #2980b9;
            --danger-color: #e74c3c;
            --highlight-color: rgba(255, 255, 0, 0.7);
            --board-size-pc: 600px;
            --board-size-sp: 90vw;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        /* è¦–è¦šçš„ã«éš ã—ã¤ã¤ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒªãƒ¼ãƒ€ãƒ¼ã«ã¯èª­ã¿ä¸Šã’ã•ã›ã‚‹ãŸã‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 850px;
        }

        .container {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            width: 100%;
        }

        .sidebar {
            width: 240px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-shrink: 0;
        }

        .game-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            background-color: var(--board-bg);
            border: 5px solid var(--surface-color);
            border-radius: 8px;
            padding: 5px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3), inset 0 2px 5px rgba(0, 0, 0, 0.2);
            aspect-ratio: 1 / 1;
        }

        .cell {
            width: 100%;
            height: 100%;
            border: 1px solid rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .disc {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }

        .disc.black {
            background: radial-gradient(circle at 30% 30%, #444, #111);
        }

        .disc.white {
            background: radial-gradient(circle at 70% 70%, #fff, #ccc);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }

        .last-move {
            outline: 3px solid var(--highlight-color);
            outline-offset: -3px;
            border-radius: 2px;
        }

        .valid-move-hint::after {
            content: '';
            display: block;
            width: 35%;
            height: 35%;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transition: background-color 0.2s;
        }

        .valid-move-hint:hover::after {
            background-color: rgba(255, 255, 255, 0.5);
        }

        .controls,
        .game-info,
        .kifu-controls,
        .test-controls {
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            width: 100%;
        }
        
        #message-area {
            margin-top: 20px;
        }
        .kifu-controls {
            margin-top: 20px;
        }
        .test-controls {
            margin-top: 20px;
        }
        
        /* â–¼â–¼â–¼ SEO: h3ã‚’h2ã«å¤‰æ›´ã—ãŸãŸã‚ã‚»ãƒ¬ã‚¯ã‚¿ã‚’èª¿æ•´ â–¼â–¼â–¼ */
        .controls label,
        .player-color-selector > label,
        .kifu-controls h2,
        .test-controls label,
        .test-controls h2 {
            display: block;
            margin-bottom: 8px;
            color: var(--text-muted-color);
            font-size: 14px;
            font-weight: bold;
        }
        
        .kifu-controls h2,
        .test-controls h2 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--text-color); /* è¦‹å‡ºã—ã¨ã—ã¦ä»–ã®ãƒ©ãƒ™ãƒ«ã‚ˆã‚Šç›®ç«‹ãŸã›ã‚‹ */
            font-size: 1.1em; /* å°‘ã—å¤§ãã */
        }
        /* â–²â–²â–² SEO: èª¿æ•´ã“ã“ã¾ã§ â–²â–²â–² */

        .controls select,
        .test-controls select {
            width: 100%;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 16px;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23bdc3c7%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.3-5.5-12.8z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 12px;
            cursor: pointer;
        }

        .controls button,
        .kifu-controls button,
        .test-controls button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border-radius: 6px;
            border: none;
            background-color: var(--accent-color);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        
        .kifu-buttons {
            display: flex;
            gap: 10px;
        }

        .kifu-buttons button {
            margin-top: 0;
            font-size: 14px;
        }

        .controls button:hover,
        .kifu-controls button:hover,
        .test-controls button:hover {
            background-color: var(--accent-hover-color);
        }

        .controls button:disabled,
        .kifu-controls button:disabled,
        .test-controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .player-color-selector {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }

        .radio-group {
            display: flex;
            justify-content: space-between;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 12px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            width: 48%;
            justify-content: center;
            transition: all 0.2s;
        }

        .radio-group input {
            display: none;
        }

        .radio-group input:checked+span {
            color: var(--text-color);
            font-weight: bold;
        }

        .radio-group label:has(input:checked) {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        .game-info p {
            margin: 0 0 12px 0;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 12px;
        }

        .game-info p:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .game-info span {
            font-weight: bold;
        }

        #current-turn {
            color: var(--accent-color);
        }

        #message-area {
            font-size: 18px;
            font-weight: bold;
            color: var(--danger-color);
            height: 25px;
            text-align: center;
        }

        .test-cpu-selectors {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .test-cpu-selector {
            flex: 1;
        }

        @media (max-width: 900px) {
            .game-wrapper {
                max-width: none;
            }
            .container { 
                flex-direction: column; 
                align-items: center; 
                gap: 20px;
                max-width: none;
            }
            .sidebar { 
                flex-direction: row; 
                width: 100%; 
                max-width: var(--board-size-pc); 
                align-items: stretch; 
            }
            .controls, .game-info { 
                flex: 1; 
            }
            #board, .game-area { 
                width: var(--board-size-sp); 
                height: auto; 
                max-width: 500px; 
            }
            .test-cpu-selectors { 
                flex-direction: column; 
            }
        }
        
        @media (max-width: 600px) {
            .sidebar {
                flex-direction: column;
            }
            .kifu-buttons {
                flex-wrap: wrap;
            }
            .kifu-buttons button {
                width: calc(50% - 5px);
                font-size: 12px;
            }
        }
    </style>
    <!-- â–¼â–¼â–¼ SEO: æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ  â–¼â–¼â–¼ -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "æœ€å¼·AIæ­è¼‰ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ ",
      "description": "8æ®µéšã®å¼·ã•ã‹ã‚‰é¸ã¹ã‚‹AIã‚’æ­è¼‰ã—ãŸç„¡æ–™ã®ãƒ–ãƒ©ã‚¦ã‚¶ãƒªãƒãƒ¼ã‚·ï¼ˆã‚ªã‚»ãƒ­ï¼‰ã‚²ãƒ¼ãƒ ã§ã™ã€‚ç™»éŒ²ä¸è¦ã§ã™ãã«ãƒ—ãƒ¬ã‚¤ã§ãã¾ã™ã€‚",
      "gamePlatform": "Web-based game",
      "applicationCategory": "Game",
      "operatingSystem": "All",
      "author": {
        "@type": "Person",
        "name": "Your Name or Company" 
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "JPY"
      }
    }
    </script>
    <!-- â–²â–²â–² SEO: æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã“ã“ã¾ã§ â–²â–²â–² -->
</head>
<body>
    <!-- â–¼â–¼â–¼ SEO: <h1>ã‚’è¿½åŠ ã—ã€ä¸»è¦ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’<main>ã§å›²ã‚€ â–¼â–¼â–¼ -->
    <h1 class="visually-hidden">æœ€å¼·AIæ­è¼‰ ç„¡æ–™ãƒ–ãƒ©ã‚¦ã‚¶ãƒªãƒãƒ¼ã‚·ã‚²ãƒ¼ãƒ </h1>
    <main class="game-wrapper">
        <div class="container">
            <!-- â–¼â–¼â–¼ SEO: ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‚’<aside>ã«å¤‰æ›´ â–¼â–¼â–¼ -->
            <aside class="sidebar">
                <!-- â–¼â–¼â–¼ SEO: ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’<section>ã«å¤‰æ›´ â–¼â–¼â–¼ -->
                <section class="controls" aria-labelledby="game-settings-heading">
                    <h2 id="game-settings-heading" class="visually-hidden">å¯¾æˆ¦è¨­å®š</h2>
                    <label for="cpu-level">ã‚ãªãŸã®å¯¾æˆ¦ç›¸æ‰‹:</label>
                    <select id="cpu-level">
                        <option value="1">ãƒ¬ãƒ™ãƒ«1 (ãƒ©ãƒ³ãƒ€ãƒ )</option>
                        <option value="2">ãƒ¬ãƒ™ãƒ«2 (æœ€å¤§åè»¢)</option>
                        <option value="3">ãƒ¬ãƒ™ãƒ«3 (å ´æ‰€è©•ä¾¡)</option>
                        <option value="4">ãƒ¬ãƒ™ãƒ«4 (Î±-Î²æ³• å¼±)</option>
                        <option value="5">ãƒ¬ãƒ™ãƒ«5 (Î±-Î²æ³• å¼·)</option>
                        <option value="6">ãƒ¬ãƒ™ãƒ«6 (æ€è€ƒå¼·åŒ–)</option>
                        <option value="7">ãƒ¬ãƒ™ãƒ«7 (å®šçŸ³+æ¢ç´¢)</option>
                        <option value="8" selected>ãƒ¬ãƒ™ãƒ«8 (è¤‡åˆå‹AI)</option>
                        <option value="9">ãƒ¬ãƒ™ãƒ«8+ (å¤šæ§˜æ€§ãŒã‚ã‚‹ãƒ¬ãƒ™ãƒ«8)</option>
                    </select>
                    <div class="player-color-selector">
                        <label>ã‚ãªãŸã®è‰²:</label>
                        <div class="radio-group">
                            <label><input type="radio" name="player_color" value="1" checked><span>å…ˆæ”» (é»’)</span></label>
                            <label><input type="radio" name="player_color" value="2"><span>å¾Œæ”» (ç™½)</span></label>
                        </div>
                    </div>
                    <button id="start-button" aria-label="ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã¾ãŸã¯ãƒªã‚»ãƒƒãƒˆã—ã¾ã™">ã‚²ãƒ¼ãƒ é–‹å§‹ / ãƒªã‚»ãƒƒãƒˆ</button>
                </section>
                <section class="game-info" aria-labelledby="game-status-heading">
                    <h2 id="game-status-heading" class="visually-hidden">ã‚²ãƒ¼ãƒ çŠ¶æ³</h2>
                    <p>æ‰‹æ•°: <span id="turn-count">0</span></p>
                    <p><span id="black-label">é»’ (YOU)</span>: <span id="black-score">2</span></p>
                    <p><span id="white-label">ç™½ (CPU)</span>: <span id="white-score">2</span></p>
                    <p>ã‚¿ãƒ¼ãƒ³: <span id="current-turn"></span></p>
                </section>
                 <!-- â–²â–²â–² SEO: å¤‰æ›´ã“ã“ã¾ã§ â–²â–²â–² -->
            </aside>
            <div class="game-area">
                <div id="board"></div>
            </div>
        </div>
        
        <div id="message-area" role="status" aria-live="polite"></div>

        <!-- â–¼â–¼â–¼ SEO: ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’<section>ã«ã€è¦‹å‡ºã—ã‚’h2ã«å¤‰æ›´ â–¼â–¼â–¼ -->
        <section class="kifu-controls" aria-labelledby="kifu-heading">
            <h2 id="kifu-heading">æ£‹è­œå†ç”Ÿ</h2>
            <div class="kifu-buttons">
                <button id="kifu-start" disabled aria-label="æ£‹è­œã®æœ€åˆã«æˆ»ã‚‹ (ä¸‹çŸ¢å°ã‚­ãƒ¼)">Â« æœ€åˆã¸ (â†“)</button>
                <button id="kifu-prev" disabled aria-label="ä¸€æ‰‹å‰ã®æ£‹è­œã«æˆ»ã‚‹ (å·¦çŸ¢å°ã‚­ãƒ¼)">â€¹ å‰ã¸ (â†)</button>
                <button id="kifu-next" disabled aria-label="ä¸€æ‰‹å…ˆã®æ£‹è­œã«é€²ã‚€ (å³çŸ¢å°ã‚­ãƒ¼)">æ¬¡ã¸ â€º (â†’)</button>
                <button id="kifu-end" disabled aria-label="æ£‹è­œã®æœ€å¾Œã«é€²ã‚€ (ä¸ŠçŸ¢å°ã‚­ãƒ¼)">æœ€å¾Œã¸ Â» (â†‘)</button>
            </div>
        </section>

        <section class="test-controls" aria-labelledby="test-heading">
            <h2 id="test-heading">CPUå¯¾æˆ¦ãƒ†ã‚¹ãƒˆ</h2>
            <div class="test-cpu-selectors">
                <div class="test-cpu-selector">
                    <label for="cpu1-level">CPU 1 (å…ˆæ”»/é»’)</label>
                    <select id="cpu1-level">
                        <option value="1">ãƒ¬ãƒ™ãƒ«1</option> <option value="2">ãƒ¬ãƒ™ãƒ«2</option> <option value="3">ãƒ¬ãƒ™ãƒ«3</option>
                        <option value="4">ãƒ¬ãƒ™ãƒ«4</option> <option value="5">ãƒ¬ãƒ™ãƒ«5</option> <option value="6">ãƒ¬ãƒ™ãƒ«6</option>
                        <option value="7">ãƒ¬ãƒ™ãƒ«7</option>
                        <option value="8">ãƒ¬ãƒ™ãƒ«8</option>
                        <option value="9" selected>ãƒ¬ãƒ™ãƒ«8+</option>
                    </select>
                </div>
                <div class="test-cpu-selector">
                    <label for="cpu2-level">CPU 2 (å¾Œæ”»/ç™½)</label>
                    <select id="cpu2-level">
                        <option value="1">ãƒ¬ãƒ™ãƒ«1</option> <option value="2">ãƒ¬ãƒ™ãƒ«2</option> <option value="3">ãƒ¬ãƒ™ãƒ«3</option>
                        <option value="4">ãƒ¬ãƒ™ãƒ«4</option> <option value="5">ãƒ¬ãƒ™ãƒ«5</option> <option value="6">ãƒ¬ãƒ™ãƒ«6</option>
                        <option value="7" selected>ãƒ¬ãƒ™ãƒ«7</option>
                        <option value="8">ãƒ¬ãƒ™ãƒ«8</option>
                        <option value="9">ãƒ¬ãƒ™ãƒ«8+</option>
                    </select>
                </div>
            </div>
            <button id="cpu-vs-cpu-button" aria-label="é¸æŠã—ãŸãƒ¬ãƒ™ãƒ«ã®CPUåŒå£«ã‚’å¯¾æˆ¦ã•ã›ã¾ã™">CPU VS CPU é–‹å§‹</button>
        </section>
        <!-- â–²â–²â–² SEO: å¤‰æ›´ã“ã“ã¾ã§ â–²â–²â–² -->
    </main>

    <script>
    // ================================================================= //
    //                             å®šæ•°ã¨å¤‰æ•°å®šç¾©                         //
    // ================================================================= //

    // --- ã‚²ãƒ¼ãƒ ã®åŸºæœ¬å®šæ•° ---
    const BOARD_SIZE = 8, EMPTY = 0, BLACK = 1, WHITE = 2;
    const DIRECTIONS = [ { r: -1, c: -1 }, { r: -1, c: 0 }, { r: -1, c: 1 }, { r: 0, c: -1 }, { r: 0, c: 1 }, { r: 1, c: -1 }, { r: 1, c: 0 }, { r: 1, c: 1 } ];
    const MAX_TURNS = 60;

    // --- AIé–¢é€£ã®å®šæ•°ãƒ»ãƒ‡ãƒ¼ã‚¿ ---
    const POSITIONAL_SCORE_TABLE = [
        [120, -20,  20,   5,   5,  20, -20, 120],
        [-20, -40,  -5,  -5,  -5,  -5, -40, -20],
        [ 20,  -5,  15,   3,   3,  15,  -5,  20],
        [  5,  -5,   3,   3,   3,   3,  -5,   5],
        [  5,  -5,   3,   3,   3,   3,  -5,   5],
        [ 20,  -5,  15,   3,   3,  15,  -5,  20],
        [-20, -40,  -5,  -5,  -5,  -5, -40, -20],
        [120, -20,  20,   5,   5,  20, -20, 120]
    ];
    const OPENING_BOOK = {
        // åˆæœŸç›¤é¢ (é»’ç•ª)
        "0000000000000000000000000001200000021000000000000000000000000000": {r:4, c:5}, // F5
        "0000000000000000000000000012100000012000000000000000000000000000": {r:5, c:5}, // F6
        // ç™½ç•ªã®å®šçŸ³ (æ—¢å­˜)
        "0000000000000000000000000002100000012100000000000000000000000000": {r:2, c:3}, // D3
        "0000000000000000000001000001210000021100000000000000000000000000": {r:2, c:2}, // C3
        "0000000000000000000000000011200000012000000000000000000000000000": {r:5, c:2}, // C6
        "0000000000000000000000000002100000011100000000000000000000000000": {r:5, c:3}, // D6
    };
    
    // --- DOMè¦ç´  ---
    const boardEl = document.getElementById('board'), turnCountEl = document.getElementById('turn-count'), blackScoreEl = document.getElementById('black-score'), whiteScoreEl = document.getElementById('white-score');
    const blackLabelEl = document.getElementById('black-label'), whiteLabelEl = document.getElementById('white-label'), currentTurnEl = document.getElementById('current-turn'), messageAreaEl = document.getElementById('message-area');
    const cpuLevelSelect = document.getElementById('cpu-level'), startButton = document.getElementById('start-button'), playerColorRadios = document.querySelectorAll('input[name="player_color"]');
    const cpu1LevelSelect = document.getElementById('cpu1-level'), cpu2LevelSelect = document.getElementById('cpu2-level'), cpuVsCpuButton = document.getElementById('cpu-vs-cpu-button');
    const kifuStartBtn = document.getElementById('kifu-start'), kifuPrevBtn = document.getElementById('kifu-prev'), kifuNextBtn = document.getElementById('kifu-next'), kifuEndBtn = document.getElementById('kifu-end');

    // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹å¤‰æ•° ---
    let board, currentPlayer, turnCount, lastMove, playerColor, cpuColor, isCpuVsCpuMode = false, isGameOver = false;
    let gameHistory = [], playbackIndex = 0, isPlaybackMode = false;

    // ================================================================= //
    //                      ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ (ã‚²ãƒ¼ãƒ é€²è¡Œç®¡ç†)                 //
    // ================================================================= //

    function initGame(isTestMode = false) {
        isCpuVsCpuMode = isTestMode;
        isPlaybackMode = false;
        isGameOver = false;

        board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
        board[3][3] = WHITE; board[3][4] = BLACK;
        board[4][3] = BLACK; board[4][4] = WHITE;
        
        currentPlayer = BLACK;
        turnCount = 0;
        lastMove = null;
        gameHistory = [{ move: null, boardState: JSON.parse(JSON.stringify(board)) }];
        playbackIndex = 0;
        
        updateUiState();
        gameController();
    }
    
    async function gameController() {
        if (isGameOver) return;

        updateInfoLabels();
        renderBoard();

        const canCurrentPlayerMove = getValidMoves(board, currentPlayer).length > 0;
        
        if (!canCurrentPlayerMove) {
            const opponent = (currentPlayer === BLACK) ? WHITE : BLACK;
            const canOpponentMove = getValidMoves(board, opponent).length > 0;
            
            if (!canOpponentMove) {
                endGame();
                return;
            }
            
            messageAreaEl.textContent = `${currentPlayer === BLACK ? 'é»’' : 'ç™½'}ã¯ãƒ‘ã‚¹ã—ã¾ã™ã€‚`;
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            currentPlayer = opponent;
            gameController();
            return;
        }

        const isCpuTurnNow = isCpuVsCpuMode || (currentPlayer === cpuColor);

        if (isCpuTurnNow) {
            await executeCpuTurn();
        }
    }

    function endGame() {
        isGameOver = true;
        updateInfoLabels();
        
        const blackScore = board.flat().filter(c => c === BLACK).length;
        const whiteScore = board.flat().filter(c => c === WHITE).length;
        const winner = (blackScore > whiteScore) ? BLACK : ((whiteScore > blackScore) ? WHITE : EMPTY);
        
        let message = "å¼•ãåˆ†ã‘ã§ã™ï¼";
        if (winner !== EMPTY) {
            if (isCpuVsCpuMode) { message = `CPU ${(winner === BLACK ? '1' : '2')} ã®å‹ã¡ã§ã™ã€‚`; } 
            else { message = (winner === playerColor) ? "ğŸ‰ ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ ğŸ‰" : "CPUã®å‹ã¡ã§ã™ã€‚"; }
        }
        messageAreaEl.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ ${message}`;
        updateUiState();
    }


    // ================================================================= //
    //                         UIãƒ»æç”»é–¢é€£                             //
    // ================================================================= //
    
    function renderBoard() {
        boardEl.innerHTML = '';
        const validMoves = (!isCpuVsCpuMode && !isPlaybackMode && currentPlayer === playerColor && !isGameOver) 
            ? getValidMoves(board, currentPlayer) 
            : [];
        
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                
                if (board[r][c] !== EMPTY) {
                    const disc = document.createElement('div');
                    disc.className = `disc ${board[r][c] === BLACK ? 'black' : 'white'}`;
                    cell.appendChild(disc);
                } else if (validMoves.some(move => move.r === r && move.c === c)) {
                    cell.classList.add('valid-move-hint');
                }
                
                if(lastMove && lastMove.r === r && lastMove.c === c) {
                    cell.classList.add('last-move');
                }
                
                cell.addEventListener('click', () => handleCellClick(r, c));
                boardEl.appendChild(cell);
            }
        }
    }
    
    function updateInfoLabels() {
        let blackScore = 0, whiteScore = 0;
        board.flat().forEach(cell => { if (cell === BLACK) blackScore++; if (cell === WHITE) whiteScore++; });
        
        const currentTurnNumber = isPlaybackMode ? playbackIndex : turnCount;
        turnCountEl.textContent = currentTurnNumber;
        blackScoreEl.textContent = blackScore;
        whiteScoreEl.textContent = whiteScore;
        
        if (isCpuVsCpuMode) {
            blackLabelEl.textContent = `é»’ (CPU 1)`;
            whiteLabelEl.textContent = `ç™½ (CPU 2)`;
            currentTurnEl.textContent = isGameOver ? 'çµ‚äº†' : `CPU ${(currentPlayer === BLACK ? '1' : '2')} ã®ã‚¿ãƒ¼ãƒ³`;
        } else {
            blackLabelEl.textContent = (playerColor === BLACK) ? 'é»’ (YOU)' : 'é»’ (CPU)';
            whiteLabelEl.textContent = (playerColor === WHITE) ? 'ç™½ (YOU)' : 'ç™½ (CPU)';
            currentTurnEl.textContent = isGameOver ? 'çµ‚äº†' : (currentPlayer === playerColor ? 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³' : 'CPUã®ã‚¿ãƒ¼ãƒ³');
        }
    }

    function updateUiState() {
        if (isGameOver) {
            startButton.disabled = false;
            cpuVsCpuButton.disabled = false;
        } else if (isCpuVsCpuMode) {
            startButton.disabled = true;
            cpuVsCpuButton.disabled = true;
        } else {
            startButton.disabled = false;
            cpuVsCpuButton.disabled = false;
        }

        if (!isCpuVsCpuMode) {
            playerColor = parseInt(document.querySelector('input[name="player_color"]:checked').value, 10);
            cpuColor = (playerColor === BLACK) ? WHITE : BLACK;
        }

        const kifuActive = isGameOver || isPlaybackMode;
        kifuStartBtn.disabled = !kifuActive || playbackIndex === 0;
        kifuPrevBtn.disabled = !kifuActive || playbackIndex === 0;
        kifuNextBtn.disabled = !kifuActive || playbackIndex === gameHistory.length - 1;
        kifuEndBtn.disabled = !kifuActive || playbackIndex === gameHistory.length - 1;
    }

    // ================================================================= //
    //                        ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ»ãƒªã‚¹ãƒŠãƒ¼                   //
    // ================================================================= //

    function handleCellClick(r, c) {
        if (isGameOver || isCpuVsCpuMode || isPlaybackMode || currentPlayer !== playerColor || board[r][c] !== EMPTY) {
            return;
        }
        
        const flippable = getFlippableDiscs(board, r, c, playerColor);
        if (flippable.length === 0) return;
        
        placeDisc(r, c, playerColor, flippable);
        
        currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
        gameController();
    }

    function renderPlayback(index) {
        isPlaybackMode = true;
        playbackIndex = index;
        const record = gameHistory[playbackIndex];
        board = JSON.parse(JSON.stringify(record.boardState));
        lastMove = record.move;
        
        updateUiState();
        updateInfoLabels();
        renderBoard();
    }

    // --- å„ç¨®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç™»éŒ² ---
    startButton.addEventListener('click', () => initGame(false));
    playerColorRadios.forEach(radio => radio.addEventListener('change', () => initGame(false)));
    cpuVsCpuButton.addEventListener('click', () => initGame(true));
    kifuStartBtn.addEventListener('click', () => { if (kifuStartBtn.disabled === false) renderPlayback(0); });
    kifuPrevBtn.addEventListener('click', () => { if (kifuPrevBtn.disabled === false) renderPlayback(playbackIndex - 1); });
    kifuNextBtn.addEventListener('click', () => { if (kifuNextBtn.disabled === false) renderPlayback(playbackIndex + 1); });
    kifuEndBtn.addEventListener('click', () => { if (kifuEndBtn.disabled === false) renderPlayback(gameHistory.length - 1); });
    
    document.addEventListener('keydown', (event) => {
        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(event.key)) event.preventDefault();
        if (event.key === 'ArrowLeft' && !kifuPrevBtn.disabled) kifuPrevBtn.click();
        else if (event.key === 'ArrowRight' && !kifuNextBtn.disabled) kifuNextBtn.click();
        else if (event.key === 'ArrowDown' && !kifuStartBtn.disabled) kifuStartBtn.click();
        else if (event.key === 'ArrowUp' && !kifuEndBtn.disabled) kifuEndBtn.click();
    });

    // ================================================================= //
    //                         AIæ€è€ƒãƒ­ã‚¸ãƒƒã‚¯ (ã‚³ã‚¢)                      //
    // ================================================================= //

    async function executeCpuTurn() {
        const currentAiPlayer = isCpuVsCpuMode ? currentPlayer : cpuColor;
        const currentAiLevel = isCpuVsCpuMode 
            ? (currentAiPlayer === BLACK ? parseInt(cpu1LevelSelect.value, 10) : parseInt(cpu2LevelSelect.value, 10))
            : parseInt(cpuLevelSelect.value, 10);

        messageAreaEl.textContent = 'CPUãŒæ€è€ƒä¸­ã§ã™...';
        await new Promise(resolve => setTimeout(resolve, 50));

        const move = findBestMove(currentAiPlayer, currentAiLevel);
        
        messageAreaEl.textContent = '';
        if (move) {
            const flippable = getFlippableDiscs(board, move.r, move.c, currentAiPlayer);
            placeDisc(move.r, move.c, currentAiPlayer, flippable);
        }
        
        currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
        gameController();
    }
    
    function findBestMove(aiPlayer, aiLevel) {
        const validMoves = getValidMoves(board, aiPlayer);
        if (validMoves.length === 0) return null;
        
        // å®šçŸ³ã®é©ç”¨ (ãƒ¬ãƒ™ãƒ«7ä»¥ä¸Š)
        if (aiLevel >= 7) {
            const bookMove = OPENING_BOOK[boardToString(board)];
            if (bookMove && validMoves.some(m => m.r === bookMove.r && m.c === bookMove.c)) {
                // ===== LEVEL 8+ å¤‰æ›´ç‚¹ Start: ãƒ¬ãƒ™ãƒ«8+ã¯å®šçŸ³ã«ã‚‚æºã‚‰ãã‚’æŒãŸã›ã‚‹ =====
                // 50%ã®ç¢ºç‡ã§å®šçŸ³ã‚’ä½¿ã„ã€50%ã®ç¢ºç‡ã§é€šå¸¸æ€è€ƒã«ç§»è¡Œã™ã‚‹
                if (aiLevel === 9 && Math.random() < 0.5) {
                    // é€šå¸¸æ€è€ƒã¸
                } else {
                    return bookMove;
                }
                // ===== LEVEL 8+ å¤‰æ›´ç‚¹ End =====
            }
        }
        
        const emptyCells = MAX_TURNS - turnCount;
        switch (aiLevel) {
            case 1: return validMoves[Math.floor(Math.random() * validMoves.length)];
            case 2: return validMoves.reduce((best, move) => { const count = getFlippableDiscs(board, move.r, move.c, aiPlayer).length; return count > best.count ? { move, count } : best; }, { move: validMoves[0], count: 0 }).move;
            case 3: return validMoves.reduce((best, move) => { const score = POSITIONAL_SCORE_TABLE[move.r][move.c]; return score > best.score ? { move, score } : best; }, { move: null, score: -Infinity }).move;
            case 4: return alphaBetaSearch(board, 3, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
            case 5: return alphaBetaSearch(board, 4, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
            case 6: return alphaBetaSearch(board, 5, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
            case 7: { 
                let d = (emptyCells > 24) ? 5 : ((emptyCells > 14) ? 6 : 8); 
                return alphaBetaSearch(board, d, -Infinity, Infinity, true, aiPlayer, aiLevel).move; 
            }
            case 8: {
                if (emptyCells <= 12) {
                    messageAreaEl.textContent = 'CPUãŒå®Œå…¨èª­ã¿ã«ç§»è¡Œ...';
                    return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move;
                }
                let depth = (emptyCells > 22) ? 6 : 7;
                return alphaBetaSearch(board, depth, -Infinity, Infinity, true, aiPlayer, aiLevel).move;
            }
            // ===== LEVEL 8+ å¤‰æ›´ç‚¹ Start: ãƒ¬ãƒ™ãƒ«8+ã®æ€è€ƒãƒ­ã‚¸ãƒƒã‚¯ =====
            case 9: { // ãƒ¬ãƒ™ãƒ«8+
                // çµ‚ç›¤: å®Œå…¨èª­ã¿ (å¤šæ§˜æ€§ãªã—)
                if (emptyCells <= 12) {
                    messageAreaEl.textContent = 'CPUãŒå®Œå…¨èª­ã¿ã«ç§»è¡Œ...';
                    return perfectSearch(board, -Infinity, Infinity, true, aiPlayer).move;
                }
                // åºç›¤ãƒ»ä¸­ç›¤: å¤šæ§˜æ€§ã‚’æŒãŸã›ãŸæ¢ç´¢
                let depth = (emptyCells > 22) ? 6 : 7;
                return findBestMoveWithVariety(board, depth, aiPlayer, 9);
            }
            // ===== LEVEL 8+ å¤‰æ›´ç‚¹ End =====
            default: return validMoves[0];
        }
    }

    // ===== LEVEL 8+ å¤‰æ›´ç‚¹ Start: å¤šæ§˜æ€§ã‚’æŒãŸã›ã‚‹ãŸã‚ã®æ€è€ƒé–¢æ•° =====
    function findBestMoveWithVariety(currentBoard, depth, aiPlayer, level) {
        const validMoves = getValidMoves(currentBoard, aiPlayer);
        
        // å„æ‰‹ã®è©•ä¾¡å€¤ã‚’è¨ˆç®—
        const moveEvals = [];
        for (const move of validMoves) {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            placeDiscInBoard(newBoard, move.r, move.c, aiPlayer, getFlippableDiscs(newBoard, move.r, move.c, aiPlayer));
            
            // ç›¸æ‰‹ã®æ‰‹ç•ªã«ãªã‚‹ã®ã§ã€è©•ä¾¡å€¤ã¯æœ€å°åŒ–ãƒãƒ¼ãƒ‰ã®çµæœï¼ˆã®ãƒã‚¤ãƒŠã‚¹ï¼‰ã¨ã—ã¦è¦‹ã‚‹
            const result = alphaBetaSearch(newBoard, depth - 1, -Infinity, Infinity, false, aiPlayer, level);
            moveEvals.push({ move: move, score: result.score });
        }

        if (moveEvals.length === 0) return null;

        // æœ€é«˜è©•ä¾¡å€¤ã‚’è¦‹ã¤ã‘ã‚‹
        const bestScore = Math.max(...moveEvals.map(e => e.score));
        
        // æœ€é«˜è©•ä¾¡å€¤ã«è¿‘ã„æ‰‹ï¼ˆã»ã¼æœ€å–„æ‰‹ï¼‰ã‚’å€™è£œã¨ã™ã‚‹
        // ã“ã®é–¾å€¤(50)ã‚’èª¿æ•´ã™ã‚‹ã“ã¨ã§ã€æ‰‹ã®å¹…ã¨å¼·ã•ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å¤‰ãˆã‚‰ã‚Œã‚‹
        const threshold = 50; 
        const bestMoves = moveEvals.filter(e => e.score >= bestScore - threshold);

        // å€™è£œã®ä¸­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«ä¸€æ‰‹ã‚’é¸æŠ
        if (bestMoves.length > 0) {
            const randomIndex = Math.floor(Math.random() * bestMoves.length);
            return bestMoves[randomIndex].move;
        }

        // å¿µã®ãŸã‚ã€ã‚‚ã—å€™è£œãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯è©•ä¾¡å€¤æœ€å¤§ã®æ‰‹ã‚’è¿”ã™
        return moveEvals.reduce((best, current) => current.score > best.score ? current : best).move;
    }
    // ===== LEVEL 8+ å¤‰æ›´ç‚¹ End =====

    function alphaBetaSearch(currentBoard, depth, alpha, beta, isMaximizingNode, maximizingPlayer, currentLevel) {
        const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
        
        if (depth === 0 || emptyCells === 0) {
            return { score: evaluateBoard(currentBoard, maximizingPlayer, currentLevel) };
        }
        
        const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
        const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
        let validMoves = getValidMoves(currentBoard, playerForThisNode);
        
        if (validMoves.length === 0) {
            const opponentValidMoves = getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer);
            if (opponentValidMoves.length === 0) { 
                return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, true) };
            }
            return alphaBetaSearch(currentBoard, depth, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel);
        }
        
        let bestResult = { move: null, score: isMaximizingNode ? -Infinity : Infinity };
        
        if (depth >= 4 && currentLevel >= 8) { // ãƒ¬ãƒ™ãƒ«8ä»¥ä¸Šã§æ¢ç´¢é †æœ€é©åŒ–
            const moveScores = validMoves.map(move => {
                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
                return { move, score: evaluateBoard(newBoard, maximizingPlayer, currentLevel) };
            });
            if(isMaximizingNode) moveScores.sort((a, b) => b.score - a.score);
            else moveScores.sort((a, b) => a.score - b.score);
            validMoves = moveScores.map(ms => ms.move);
        }
        bestResult.move = validMoves[0]; 

        for (const move of validMoves) {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
            
            const result = alphaBetaSearch(newBoard, depth - 1, alpha, beta, !isMaximizingNode, maximizingPlayer, currentLevel);
            
            if (isMaximizingNode) {
                if (result.score > bestResult.score) { bestResult = { move, score: result.score }; }
                alpha = Math.max(alpha, bestResult.score);
            } else {
                if (result.score < bestResult.score) { bestResult = { move, score: result.score }; }
                beta = Math.min(beta, bestResult.score);
            }
            if (beta <= alpha) break; 
        }
        
        return bestResult;
    }

    function perfectSearch(currentBoard, alpha, beta, isMaximizingNode, maximizingPlayer) {
        const emptyCells = MAX_TURNS - (currentBoard.flat().filter(c => c !== EMPTY).length - 4);
        if (emptyCells === 0) {
            return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, false) };
        }

        const opponentPlayer = (maximizingPlayer === BLACK) ? WHITE : BLACK;
        const playerForThisNode = isMaximizingNode ? maximizingPlayer : opponentPlayer;
        const validMoves = getValidMoves(currentBoard, playerForThisNode);

        if (validMoves.length === 0) {
            const opponentValidMoves = getValidMoves(currentBoard, isMaximizingNode ? opponentPlayer : maximizingPlayer);
            if (opponentValidMoves.length === 0) {
                return { score: evaluateByStoneCount(currentBoard, maximizingPlayer, false) };
            }
            return perfectSearch(currentBoard, alpha, beta, !isMaximizingNode, maximizingPlayer);
        }

        let bestResult = { move: validMoves[0], score: isMaximizingNode ? -Infinity : Infinity };

        for (const move of validMoves) {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            placeDiscInBoard(newBoard, move.r, move.c, playerForThisNode, getFlippableDiscs(newBoard, move.r, move.c, playerForThisNode));
            
            const result = perfectSearch(newBoard, alpha, beta, !isMaximizingNode, maximizingPlayer);
            
            if (isMaximizingNode) {
                if (result.score > bestResult.score) { bestResult = { move, score: result.score }; }
                alpha = Math.max(alpha, bestResult.score);
            } else {
                if (result.score < bestResult.score) { bestResult = { move, score: result.score }; }
                beta = Math.min(beta, bestResult.score);
            }
            if (beta <= alpha) break;
        }
        
        return bestResult;
    }

    // ================================================================= //
    //                           AIè©•ä¾¡é–¢æ•°                             //
    // ================================================================= //

    function evaluateBoard(board, player, level) {
        if (level >= 8) { // ãƒ¬ãƒ™ãƒ«8ã¨8+ã¯åŒã˜è©•ä¾¡é–¢æ•°ã‚’ä½¿ã†
            const currentTurn = board.flat().filter(c => c !== EMPTY).length - 4;
            return evaluateBoardForLevel8(board, player, currentTurn);
        }
        if (level >= 6) return advancedPositionalEvaluation(board, player);
        return simplePositionalEvaluation(board, player);
    }
    
    function simplePositionalEvaluation(board, player) {
        let score = 0;
        const opponent = (player === BLACK) ? WHITE : BLACK;
        for (let r=0; r<8; r++) for(let c=0; c<8; c++) {
            if(board[r][c]===player) score+=POSITIONAL_SCORE_TABLE[r][c];
            else if(board[r][c]===opponent) score-=POSITIONAL_SCORE_TABLE[r][c];
        }
        return score;
    }

    function advancedPositionalEvaluation(board, player) {
        const opponent = (player === BLACK) ? WHITE : BLACK;
        const positionalScore = simplePositionalEvaluation(board, player);
        const mobilityScore = getValidMoves(board, player).length - getValidMoves(board, opponent).length;
        const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
        return positionalScore + (mobilityScore * 50) + (fixedDiscScore * 150);
    }

    function evaluateBoardForLevel8(board, player, currentTurn) {
        const opponent = (player === BLACK) ? WHITE : BLACK;

        const positionalScore = simplePositionalEvaluation(board, player);
        const playerMoves = getValidMoves(board, player);
        const opponentMoves = getValidMoves(board, opponent);
        const mobilityScore = playerMoves.length - opponentMoves.length;
        const fixedDiscScore = getStableDiscs(board, player).length - getStableDiscs(board, opponent).length;
        
        let cornerPenalty = 0;
        const corners = [{r:0,c:0},{r:0,c:7},{r:7,c:0},{r:7,c:7}];
        const xSquares = [{r:1,c:1},{r:1,c:6},{r:6,c:1},{r:6,c:6}];
        for (let i = 0; i < 4; i++) {
            if (board[corners[i].r][corners[i].c] === EMPTY) {
                if (board[xSquares[i].r][xSquares[i].c] === player) cornerPenalty -= 250;
                if (board[xSquares[i].r][xSquares[i].c] === opponent) cornerPenalty += 250;
            }
        }

        let positionalWeight, mobilityWeight, fixedDiscWeight;
        if (currentTurn < 20) { 
            positionalWeight = 1; mobilityWeight = 80; fixedDiscWeight = 120;
        } else if (currentTurn < 48) {
            positionalWeight = 1; mobilityWeight = 60; fixedDiscWeight = 180;
        } else {
            positionalWeight = 0.5; mobilityWeight = 40; fixedDiscWeight = 250;
        }
        
        return (positionalScore * positionalWeight) + 
               (mobilityScore * mobilityWeight) + 
               (fixedDiscScore * fixedDiscWeight) +
               cornerPenalty;
    }

    function evaluateByStoneCount(board, player, isFromAlphaBeta) {
        let score = 0;
        board.flat().forEach(c => { if (c === player) score++; else if (c !== EMPTY) score--; });
        return isFromAlphaBeta ? score * 1000 : score;
    }

    // ================================================================= //
    //                       ãƒ«ãƒ¼ãƒ«ãƒ»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°                      //
    // ================================================================= //
    
    function placeDisc(r, c, player, flippable) {
        board[r][c] = player;
        flippable.forEach(pos => { board[pos.r][pos.c] = player; });
        lastMove = { r, c };
        turnCount++;
        gameHistory.push({ move: { r, c }, boardState: JSON.parse(JSON.stringify(board)) });
        playbackIndex = gameHistory.length - 1;
    }
    
    function placeDiscInBoard(b, r, c, player, flippable) { b[r][c] = player; flippable.forEach(p => { b[p.r][p.c] = player; }); }

    function getFlippableDiscs(currentBoard, r, c, player) {
        const flippable = [];
        if (currentBoard[r][c] !== EMPTY) return flippable;
        const opponent = (player === BLACK) ? WHITE : BLACK;
        for (const dir of DIRECTIONS) {
            const line = [];
            let currR = r + dir.r, currC = c + dir.c;
            while (currR >= 0 && currR < BOARD_SIZE && currC >= 0 && currC < BOARD_SIZE) {
                if (currentBoard[currR][currC] === opponent) { line.push({r:currR, c:currC}); } 
                else if (currentBoard[currR][currC] === player) { flippable.push(...line); break; } 
                else break;
                currR += dir.r; currC += dir.c;
            }
        }
        return flippable;
    }
    
    function getValidMoves(currentBoard, player) {
        const moves = [];
        for (let r = 0; r < BOARD_SIZE; r++) for (let c = 0; c < BOARD_SIZE; c++) {
            if (currentBoard[r][c] === EMPTY && getFlippableDiscs(currentBoard, r, c, player).length > 0) {
                moves.push({r, c});
            }
        }
        return moves;
    }
    
    function getStableDiscs(board, player) {
        const stable = Array.from({length: 8}, () => Array(8).fill(false));
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, 1], [-1, 1], [1, -1]];
        
        if(board[0][0] === player) stable[0][0] = true;
        if(board[0][7] === player) stable[0][7] = true;
        if(board[7][0] === player) stable[7][0] = true;
        if(board[7][7] === player) stable[7][7] = true;

        let changed = true;
        while(changed) {
            changed = false;
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                if(board[r][c] === player && !stable[r][c]) {
                    let isStable = true;
                    for(let i=0; i<4; i++) {
                        const [d1r, d1c] = directions[i*2];
                        const [d2r, d2c] = directions[i*2+1];
                        let line1_filled = true, line2_filled = true;
                        
                        let nr = r + d1r, nc = c + d1c;
                        while(nr>=0 && nr<8 && nc>=0 && nc<8) {
                            if(board[nr][nc] !== player && !stable[nr][nc]) { line1_filled = false; break; }
                            nr += d1r; nc += d1c;
                        }
                        nr = r + d2r, nc = c + d2c;
                        while(nr>=0 && nr<8 && nc>=0 && nc<8) {
                            if(board[nr][nc] !== player && !stable[nr][nc]) { line2_filled = false; break; }
                            nr += d2r; nc += d2c;
                        }
                        if (!line1_filled && !line2_filled) {
                            isStable = false;
                            break;
                        }
                    }
                    if(isStable) {
                        stable[r][c] = true;
                        changed = true;
                    }
                }
            }
        }
        
        const stableDiscs = [];
        for (let r=0; r<8; r++) for(let c=0; c<8; c++) if(stable[r][c]) stableDiscs.push({r,c});
        return stableDiscs;
    }

    function boardToString(b) { return b.flat().join(''); }

    // --- ã‚²ãƒ¼ãƒ ã®åˆå›èµ·å‹• ---
    initGame(false);
    </script>
</body>
</html>
