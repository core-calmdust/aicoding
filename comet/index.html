<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">

    <!-- ‚ñº‚ñº‚ñº SEO & OGPÂØæÂøú „Åì„Åì„Åã„Çâ ‚ñº‚ñº‚ñº -->

    <!-- 1. Âü∫Êú¨ÊÉÖÂ†± -->
    <title>COMET OUTBURST - „Çµ„Ç§„Éê„ÉºÂºæÂπï„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞„Éª„Éâ„ÉÉ„Ç∏„Ç≤„Éº„É†</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="„ÄåCOMET OUTBURST„Äç„ÅØ„ÄÅ„Ç∑„É≥„Çª„Ç¶„Çß„Ç§„É¥„ÅÆ„Éì„Éº„Éà„Å´‰πó„Çä„Å™„Åå„ÇâÂΩóÊòüÁæ§„ÇíÊΩú„ÇäÊäú„Åë„Çã„É¨„Éà„É≠SFÂºæÂπï„Éâ„ÉÉ„Ç∏„Ç≤„Éº„É†„Åß„Åô„ÄÇ„Éó„É≠„Ç∑„Éº„Ç∏„É£„É´„Å™BGMÁîüÊàê„ÇÑ„ÄÅ„Éê„Ç§„Éñ„Ç≥„Éº„Éá„Ç£„É≥„Ç∞ÔºàAI„Ç≥„Éº„Éá„Ç£„É≥„Ç∞Ôºâ„Åß‰Ωú„Çä‰∏ä„Åí„ÅüÁÜ±Ê∞ó„ÇíÊÑü„Åò„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Éè„Ç§„Çπ„Ç≥„Ç¢„ÇíÁõÆÊåá„Åó„ÄÅÂÖâ„ÅÆËªåË∑°„ÇíÂàª„ÇÅÔºÅ">
    <meta name="keywords" content="ÂºæÂπï, „Éâ„ÉÉ„Ç∏„Ç≤„Éº„É†, STG, „Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞, „É¨„Éà„É≠„Ç≤„Éº„É†, 8bit, synthwave, outrun, AI, AI programming, live coding, generative art, procedural generation, javascript game">
    <meta name="author" content="CALMDUST">
    <!-- ‚ñ≤ üëÜ YOUR_NAME_OR_HANDLE „Çí„ÅÇ„Å™„Åü„ÅÆÂêçÂâç„ÇÑ„Éè„É≥„Éâ„É´„Éç„Éº„É†„Å´Êõ∏„ÅçÊèõ„Åà„Å¶„Åè„Å†„Åï„ÅÑ -->

    <!-- 2. Ê≠£Ë¶èURLÔºàÊ§úÁ¥¢„Ç®„É≥„Ç∏„É≥„Å´Ê≠£„Åó„ÅÑ„Éö„Éº„Ç∏„ÅÆURL„Çí‰ºù„Åà„ÇãÔºâ -->
    <link rel="canonical" href="https://core-calmdust.github.io/aicoding/comet/">
    <!-- ‚ñ≤ üëÜ YOUR_GAME_DOMAIN „Çí„ÅÇ„Å™„Åü„ÅÆ„Ç≤„Éº„É†„ÇíÂÖ¨Èñã„Åô„Çã„Éâ„É°„Ç§„É≥„Å´Êõ∏„ÅçÊèõ„Åà„Å¶„Åè„Å†„Åï„ÅÑ (‰æã: user.github.io/comet-outburst) -->

    <!-- 3. „Éï„Ç°„Éì„Ç≥„É≥ (WebPÂØæÂøú & ÂêÑÁ®Æ„Éá„Éê„Ç§„ÇπÂØæÂøú) -->
    <link rel="icon" href="favicon.ico" sizes="any">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <link rel="manifest" href="site.webmanifest">
    <!-- ‚ñ≤ üëÜ ‰∏äË®ò„ÅÆ„Éï„Ç°„Ç§„É´ (favicon.ico, favicon.svg, apple-touch-icon.png, site.webmanifest) „Çí„É´„Éº„Éà„Å´ÈÖçÁΩÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
             „Åì„Çå„Çâ„ÅØ„Éï„Ç°„Éì„Ç≥„É≥„Ç∏„Çß„Éç„É¨„Éº„Çø„ÉºÁ≠â„ÅßÁ∞°Âçò„Å´‰ΩúÊàê„Åß„Åç„Åæ„Åô„ÄÇ -->

    <!-- 4. OGP (Open Graph Protocol) „Çø„Ç∞ / SNS„Ç∑„Çß„Ç¢Áî® -->
    <meta property="og:title" content="COMET OUTBURST -  „Çµ„Ç§„Éê„ÉºÂºæÂπï„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞„Éª„Éâ„ÉÉ„Ç∏„Ç≤„Éº„É†">
    <meta property="og:description" content="„Ç∑„É≥„Çª„Ç¶„Çß„Ç§„É¥„ÅÆ„Éì„Éº„Éà„Å´‰πó„Çä„Å™„Åå„ÇâÂΩóÊòüÁæ§„ÇíÊΩú„ÇäÊäú„Åë„Çã„É¨„Éà„É≠SFÂºæÂπï„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞„Éª„Éâ„ÉÉ„Ç∏„Ç≤„Éº„É†„ÄÇ„Çπ„É™„É™„É≥„Ç∞„Å™„Ç≤„Éº„É†„Éó„É¨„Ç§„Åß„Éê„Ç§„Éñ„Ç≥„Éº„Éá„Ç£„É≥„Ç∞ÔºàAI„Ç≥„Éº„Éá„Ç£„É≥„Ç∞Ôºâ„ÅÆÁÜ±Ê∞ó„ÇíÊÑü„Åò„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://core-calmdust.github.io/aicoding/comet/">
    <!-- ‚ñ≤ üëÜ YOUR_GAME_DOMAIN „Çí„ÅÇ„Å™„Åü„ÅÆ„Ç≤„Éº„É†„ÇíÂÖ¨Èñã„Åô„Çã„Éâ„É°„Ç§„É≥„Å´Êõ∏„ÅçÊèõ„Åà„Å¶„Åè„Å†„Åï„ÅÑ -->
    <meta property="og:image" content="https://core-calmdust.github.io/aicoding/comet/ogp-image.webp">
    <!-- ‚ñ≤ üëÜ YOUR_GAME_DOMAIN „Å®„ÄÅ„Ç∑„Çß„Ç¢Áî®ÁîªÂÉè (ogp-image.webp) „ÅÆ„Éë„Çπ„ÇíÊõ∏„ÅçÊèõ„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊé®Â•®„Çµ„Ç§„Ç∫„ÅØ 1200x630px „Åß„Åô -->
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="COMET OUTBURST">
    <meta property="og:locale" content="ja_JP">

    <!-- 5. Twitter„Ç´„Éº„Éâ -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@core_tan">
    <!-- ‚ñ≤ üëÜ „ÅÇ„Å™„Åü„ÅÆTwitter ID„Åå„ÅÇ„Çå„Å∞ @YOUR_TWITTER_ID „ÇíÊõ∏„ÅçÊèõ„Åà„Å¶„Åè„Å†„Åï„ÅÑ (‰ªªÊÑè) -->

    <!-- 6. ÊßãÈÄ†Âåñ„Éá„Éº„Çø (Ê§úÁ¥¢„Ç®„É≥„Ç∏„É≥„Å´„Ç≤„Éº„É†„ÅÆÊÉÖÂ†±„ÇíÊ≠£Á¢∫„Å´‰ºù„Åà„Çã) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "COMET OUTBURST",
      "url": "https://core-calmdust.github.io/aicoding/comet/",
      "image": "https://core-calmdust.github.io/aicoding/comet/ogp-image.webp",
      "description": "„ÄåCOMET OUTBURST„Äç„ÅØ„ÄÅ„Ç∑„É≥„Çª„Ç¶„Çß„Ç§„É¥„ÅÆ„Éì„Éº„Éà„Å´‰πó„Çä„Å™„Åå„ÇâÂΩóÊòüÁæ§„ÇíÊΩú„ÇäÊäú„Åë„Çã„É¨„Éà„É≠SFÂºæÂπï„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞„Éª„Éâ„ÉÉ„Ç∏„Ç≤„Éº„É†„Åß„Åô„ÄÇ„Éó„É≠„Ç∑„Éº„Ç∏„É£„É´„Å™BGMÁîüÊàê„ÇÑ„ÄÅ„É©„Ç§„Éñ„Ç≥„Éº„Éá„Ç£„É≥„Ç∞ÔºàAI„Ç≥„Éº„Éá„Ç£„É≥„Ç∞Ôºâ„Åß‰Ωú„Çä‰∏ä„Åí„ÅüÁÜ±Ê∞ó„ÇíÊÑü„Åò„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
      "keywords": "ÂºæÂπï, „Éâ„ÉÉ„Ç∏„Ç≤„Éº„É†, STG, „Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞, „É¨„Éà„É≠„Ç≤„Éº„É†, 8bit, synthwave, outrun, AI, AI programming, live coding, generative art, procedural generation, javascript game",
      "author": {
        "@type": "Person",
        "name": "CALMDUST"
      },
      "genre": ["Shooter", "Action", "Music/Rhythm Game"],
      "gamePlatform": ["PC", "Web Browser"],
      "operatingSystem": "Any"
    }
    </script>
    <!-- ‚ñ≤ üëÜ YOUR... „ÅÆÈÉ®ÂàÜ„Çí„ÅÇ„Å™„Åü„ÅÆÊÉÖÂ†±„Å´Êõ∏„ÅçÊèõ„Åà„Å¶„Åè„Å†„Åï„ÅÑ -->

    <!-- ‚ñ≤‚ñ≤‚ñ≤ SEO & OGPÂØæÂøú „Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤ -->


    <!-- „Çπ„Çø„Ç§„É´„Ç∑„Éº„Éà„Å®„Éï„Ç©„É≥„Éà -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            margin: 0;
            background-color: #00001a;
            font-family: 'Press Start 2P', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #fullscreen-root:fullscreen {
            background-color: #00001a;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #fullscreen-root:fullscreen #game-wrapper {
            transform: scale(var(--scale-factor, 1));
            transform-origin: center;
        }
        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        canvas {
            background-color: #000000;
            border: 2px solid #0088cc;
            box-shadow: 0 0 20px #0088cc;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
            transition: border-color 0.2s, box-shadow 0.2s, filter 1s ease-out, -webkit-filter 1s ease-out;
        }
        #instructions-container {
           color: #ccc;
           font-size: 12px;
           width: 800px;
           padding: 8px 15px;
           box-sizing: border-box;
           display: flex;
           justify-content: space-between;
           align-items: center;
           text-shadow: 0 0 10px #00ccff;
        }
        #extra-instruction {
            opacity: 0.8;
            padding-top: 4px;
        }
        
        /* ‚ñº‚ñº‚ñº „Åì„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Åß„ÄÅÂÖÉ„ÅÆ„Éú„Çø„É≥Èñ¢ÈÄ£CSS„Çí„Åô„Åπ„Å¶ÁΩÆ„ÅçÊèõ„Åà„Çã ‚ñº‚ñº‚ñº */

        /* „Éú„Çø„É≥„Çí„Åæ„Å®„ÇÅ„Çã„Ç≥„É≥„ÉÜ„Éä„ÅÆ„Çπ„Çø„Ç§„É´ */
        #buttons-container {
            position: absolute;
            bottom: 65px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px; /* „Éú„Çø„É≥„Å®Âå∫Âàá„ÇäÁ∑ö„ÅÆÈñì„ÅÆ„Çπ„Éö„Éº„Çπ */
            z-index: 100;
        }

        /* 2„Å§„ÅÆ„Éú„Çø„É≥„Å´ÂÖ±ÈÄö„ÅÆ„Çπ„Çø„Ç§„É´ */
        #sound-toggle-button,
        #effects-toggle-button {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #00ccff;
            background-color: transparent;
            border: 2px solid #00ccff;
            padding: 5px 10px;
            border-radius: 4px;
            box-shadow: 0 0 10px #00ccff;
            cursor: pointer;
            user-select: none;
            text-shadow: 0 0 5px #00ccff;
            opacity: 0.7;
            transition: opacity 0.2s, background-color 0.2s;
            
            /* „Éú„Çø„É≥„ÅÆ„Çµ„Ç§„Ç∫„Å®„ÉÜ„Ç≠„Çπ„ÉàÈÖçÁΩÆ„ÇíÁµ±‰∏Ä */
            box-sizing: border-box;
            min-width: 100px;
            text-align: center;
        }

        #sound-toggle-button:hover,
        #effects-toggle-button:hover {
            opacity: 1.0;
            background-color: var(--button-hover-bg, rgba(0, 204, 255, 0.2));
        }

        /* Âå∫Âàá„ÇäÁ∑ö„Äå|„Äç„ÅÆ„Çπ„Çø„Ç§„É´ */
        .button-separator {
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            color: #00ccff;
            opacity: 0.5;
            text-shadow: 0 0 5px #00ccff;
        }

        /* ‚ñ≤‚ñ≤‚ñ≤ ÁΩÆ„ÅçÊèõ„Åà„ÅØ„Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤ */
        
    </style>
</head>
<body>
    <div id="fullscreen-root">
        <div id="game-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>

            <!-- ‚ñº‚ñº‚ñº ‰øÆÊ≠£Âæå„ÅÆ„Éú„Çø„É≥„ÅÆHTMLÊßãÈÄ† ‚ñº‚ñº‚ñº -->
            <div id="buttons-container">
                <button type="button" id="effects-toggle-button">EFX ON</button>
                <button type="button" id="sound-toggle-button">SOUND ON</button>
            </div>
            <!-- ‚ñ≤‚ñ≤‚ñ≤ „Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤ -->
            
            <footer id="instructions-container">
                <div>
                    <div id="main-instruction"></div>
                    <div id="extra-instruction"></div>
                </div>
                <div style="text-align: right;">
                    <div id="controls-instruction"></div>
                    <div id="controls-instruction-2" style="padding-top: 4px;"></div>
                </div>
            </footer>
        </div>
    </div>

<script>
// =================================================================================
// ‚ñº‚ñº‚ñº Comet - A Synthwave dodging game (v1.00) ‚ñº‚ñº‚ñº
// =================================================================================

// ---------------------------------
// „Ç≤„Éº„É†Ë®≠ÂÆö
// ---------------------------------
const config = {
    canvasWidth: 800,
    canvasHeight: 600,
    playerSpeed: 300,
    playerSlowModeMultiplier: 0.5,
    playerHitboxRadius: 3,
    playerVisualSize: 16,
    initialCometSpeed: 288,
    cometSpeedIncrease: 0.07,
    distanceScoreMultiplier: 1,
    cometSpawnInterval: 12,
    cometSpawnAmount: 3,
    cometCoreRadius: 5,
    starCount: 50,
    starScrollMultiplier: 16,
    starGlazeRadius: 20,
    glazeDistance: 40,
    glazeScore: 750,
    starGlazeScore: 500,
    highScoreKeyStandard: 'cometHighScore_standard',
    highScoreKeyJourney: 'cometHighScore_journey',
    highScoreKeyStartrail: 'cometHighScore_startrail',
    fontFamily: '"Press Start 2P", monospace',
    glowBlur: 12,
    energyTotal: 20 * 60,
    energyItemSpeed: 305,
    energyItemSize: 16,
    energyItemScoreNormal: 10000,
    energyItemScoreSpecial: 50000,
    gravity: 600,
    playerBulletSpeed: 800,
    monsterUFOBaseScore: 10000,
    monsterInvaderBaseScore: 3000,
    monsterLooperBaseScore: 50000,
    monsterCollisionBonus: 10000,
};

// ---------------------------------
// „Éâ„ÉÉ„ÉàÁµµ„Éá„Éº„Çø
// ---------------------------------
const PLAYER_PIXEL_ART = [
    [0,0,0,0,0,0,2,2,0,0,0,0,0,0],
    [0,0,0,0,0,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,1,1,0,0,0,0],
    [0,0,0,2,1,1,1,1,1,1,2,0,0,0],
    [0,0,1,1,1,1,1,1,1,1,1,1,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [2,1,1,0,1,1,1,1,1,1,0,1,1,2],
    [0,0,0,0,3,0,0,0,0,3,0,0,0,0],
];
const ENERGY_ITEM_PIXEL_ART = [
    [0,0,0,2,2,2,2,2,2,2,2,0,0,0],
    [0,0,2,2,2,2,2,2,2,2,2,2,0,0],
    [0,2,2,0,0,0,0,0,0,0,0,2,2,0],
    [2,2,0,0,1,1,1,1,1,1,0,0,2,2],
    [2,2,0,1,1,0,0,0,0,0,0,0,2,2],
    [2,2,0,1,1,0,0,0,0,0,0,0,2,2],
    [2,2,0,1,1,1,1,1,1,0,0,0,2,2],
    [2,2,0,1,1,1,1,1,1,0,0,0,2,2],
    [2,2,0,1,1,0,0,0,0,0,0,0,2,2],
    [2,2,0,1,1,0,0,0,0,0,0,0,2,2],
    [2,2,0,0,1,1,1,1,1,1,0,0,2,2],
    [0,2,2,0,0,0,0,0,0,0,0,2,2,0],
    [0,0,2,2,2,2,2,2,2,2,2,2,0,0],
    [0,0,0,2,2,2,2,2,2,2,2,0,0,0]
];
// UFO (0:ÈÄèÊòé, 1:„É°„Ç§„É≥, 2:„Çµ„Éñ, 3:„Éâ„Éº„É†, 4:„Ç¢„ÇØ„Çª„É≥„Éà)
const UFO_PIXEL_ART_FINAL = [
    [0,0,0,0,0,3,3,3,3,0,0,0,0,0],
    [0,0,0,3,3,3,3,3,3,3,3,0,0,0],
    [0,0,3,1,1,3,3,3,3,1,1,3,0,0],
    [0,3,1,4,4,1,3,3,1,4,4,1,3,0],
    [3,1,4,4,4,4,1,1,4,4,4,4,1,3],
    [3,1,1,4,4,1,1,1,1,4,4,1,1,3],
    [3,2,2,1,1,1,1,1,1,1,1,2,2,3],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,1,2,2,2,2,2,2,2,2,2,2,1,1],
    [0,1,1,2,2,2,2,2,2,2,2,1,1,0],
    [0,0,1,1,1,2,2,2,2,1,1,1,0,0],
    [0,0,0,1,1,1,2,2,1,1,1,0,0,0],
    [0,0,0,0,1,1,1,1,1,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
];
// „Ç§„É≥„Éô„Éº„ÉÄ„Éº (0:ÈÄèÊòé, 1:„É°„Ç§„É≥, 2:„Çµ„Éñ, 3:„Ç¢„ÇØ„Çª„É≥„Éà)
const INVADER_PIXEL_ART_GAMING = [
    [0,0,0,1,1,1,1,1,1,1,1,0,0,0],
    [0,0,1,2,2,2,2,2,2,2,2,1,0,0],
    [0,1,2,1,1,2,2,2,2,1,1,2,1,0],
    [1,2,1,3,3,1,2,2,1,3,3,1,2,1],
    [1,2,1,3,3,1,1,1,1,3,3,1,2,1],
    [1,2,2,1,1,1,1,1,1,1,1,2,2,1],
    [0,1,2,2,2,2,2,2,2,2,2,2,1,0],
    [0,0,1,1,1,0,0,0,0,0,1,1,1,0],
    [0,0,0,0,0,1,1,0,0,1,1,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
];
// „É´„Éº„Éó„Éâ („Çø„Ç≥) (0:ÈÄèÊòé, 1:„Éú„Éá„Ç£, 2:ÁõÆ, 3:Âê∏Áõ§)
const LOOPER_PIXEL_ART = [
    [0,0,0,1,1,1,1,1,1,1,0,0,0,0],
    [0,0,1,1,1,1,1,1,1,1,1,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,0,0],
    [0,1,1,2,1,1,1,1,1,2,1,1,1,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,3,1,1,1,1,1,1,1,1,1,1,3,1],
    [1,0,3,1,1,1,1,1,1,1,1,3,0,1],
    [1,0,0,3,1,1,1,1,1,1,3,0,0,1],
    [0,0,0,1,3,1,0,0,1,3,1,0,0,0],
    [0,0,0,0,1,3,0,0,0,1,3,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
];

const STAGE_LENGTH_IN_FRAMES = 886;

const themes = [
    { name: 'Synthwave', grid: '#ff00ff', player: '#00ffff', comet: '#00aaff', ui: '#00ccff' },
    { name: 'Outrun',    grid: '#ff8c00', player: '#ffdf00', comet: '#ff4500', ui: '#ffd700' },
    { name: 'Aurora', grid: '#4B0082', player: '#00FF7F', comet: '#9400D3', ui: '#7CFC00' },
    { name: 'Coral Reef', grid: '#1E90FF', player: '#FFD700', comet: '#FF4500', ui: '#00FFFF' },
    { name: 'Neon Jungle', grid: '#006400', player: '#FF00FF', comet: '#39FF14', ui: '#F0E68C' },
    { name: 'Midnight Sun', grid: '#483D8B', player: '#FFFFE0', comet: '#FF8C00', ui: '#FFDAB9' },
    { name: 'Deep Space', grid: '#191970', player: '#FFFFFF', comet: '#B0C4DE', ui: '#E6E6FA' },
    { name: 'Sakura', grid: '#3CB371', player: '#FFFFFF', comet: '#FFB6C1', ui: '#FFC0CB' },
    { name: 'Autumn', grid: '#8B4513', player: '#FFFF00', comet: '#FF4500', ui: '#FFA500' },
    { name: 'Tropical', grid: '#008080', player: '#ADFF2F', comet: '#FF1493', ui: '#F0E68C' },
    { name: 'Galaxy', grid: '#483D8B', player: '#FFD700', comet: '#DA70D6', ui: '#BA55D3' },
    { name: 'Inferno', grid: '#8B0000', player: '#FFFF00', comet: '#FF4500', ui: '#FF6347' },
    { name: 'Crystal Cave', grid: '#00008B', player: '#E0FFFF', comet: '#AFEEEE', ui: '#ADD8E6' },
    { name: 'Gilded Age', grid: '#2F4F4F', player: '#FFD700', comet: '#F0E68C', ui: '#DAA520' },
    { name: 'Cosmic',    grid: '#a953e6', player: '#ffffff', comet: '#68d9f5', ui: '#f06e8c' },
    { name: 'Monochrome',grid: '#888888', player: '#ffffff', comet: '#cccccc', ui: '#dddddd' }
];

// ---------------------------------
// „Ç™„Éº„Éá„Ç£„Ç™„Éè„É≥„Éâ„É©
// ---------------------------------
class AudioHandler {
    constructor() {
        this.ctx = null;
        this.masterGain = null;
        this.bgmOscillators = [];
        this.isInitialized = false;
        this.bgmPlaying = false;
        this.nextNoteTime = 0;
        this.current16th = 0;
        this.seq3ChordProgression = [0, -2, 3, 5];
        this.seq4Melody = [12, 10, 7, 5, 3, 0, -2, 0];
        this.seq4MelodyIndex = 0;
        this.seq5Melody = [12, null, 15, 10, null, 12, 7, null, 14, null, 17, 12, null, 10, 5, null];
        this.seq5MelodyIndex = 0;
        this.hiHatPanIndex = 0;
        this.isMuted = false;
        this.volume = 0.4;
        this.barTrigger = false;
    }

    initialize() {
        if (this.isInitialized) {
            return;
        }
        try {
            this.ctx = new(window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.masterGain.gain.value = this.isMuted ? 0 : this.volume;
            this.isInitialized = true;
        } catch (e) {
            console.error("Web Audio API is not supported in this browser.");
        }
    }

    createSound(freq, dur, type, decay, vol, startTime, ramp) {
        if (!this.ctx) {
            return;
        }
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain).connect(this.masterGain);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, startTime);
        if (ramp) {
            osc.frequency.exponentialRampToValueAtTime(ramp.endFreq, startTime + dur);
        }
        gain.gain.setValueAtTime(vol, startTime);
        gain.gain.exponentialRampToValueAtTime(0.001, startTime + dur * decay);
        osc.start(startTime);
        osc.stop(startTime + dur);
    }

    async playBgm() {
        if (!this.isInitialized) {
            return;
        }

        // AudioContext„ÅåÂÅúÊ≠¢Áä∂ÊÖã(suspended)„Å™„Çâ„ÄÅÂÜçÈñã(resume)„ÇíË©¶„Åø„Çã
        if (this.ctx.state === 'suspended') {
            try {
                // resume()„ÅåÂÆå‰∫Ü„Åô„Çã„ÅÆ„ÇíÂæÖ„Å§
                await this.ctx.resume();
            } catch (e) {
                console.error("AudioContext resume failed, cannot play BGM.", e);
                return; // ÂÜçÈñã„Å´Â§±Êïó„Åó„Åü„ÇâBGM„ÅØÂÜçÁîü„Åó„Å™„ÅÑ
            }
        }

        // „Åô„Åß„Å´ÂÜçÁîü‰∏≠„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºàÁä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ„ÅØresume„ÅÆÂæå„Å´Ë°å„ÅÜÔºâ
        if (this.bgmPlaying) {
            return;
        }

        this.stopBgm();
        this.bgmPlaying = true;
        this.current16th = 0;
        this.seq4MelodyIndex = 0;
        this.seq5MelodyIndex = 0;
        this.hiHatPanIndex = 0;
        this.nextNoteTime = this.ctx.currentTime + 0.1;
    }

    scheduleBGM() {
        if (!this.bgmPlaying) {
            return;
        }

        const bgmStage = ((stage - 1) % 6) + 1;
        const bpm = 130;
        const sixteenth = 60 / bpm / 4;
        const rootNote = 27.50;

        const createKick = time => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const noise = this.ctx.createBufferSource();
            const noiseGain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(120, time);
            osc.frequency.exponentialRampToValueAtTime(40, time + 0.15);
            gain.gain.setValueAtTime(1.0, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            osc.connect(gain).connect(this.masterGain);
            const bufSize = this.ctx.sampleRate * 0.05;
            const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buf;
            noiseGain.gain.setValueAtTime(0.3, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.02);
            noise.connect(noiseGain).connect(this.masterGain);
            osc.start(time);
            osc.stop(time + 0.2);
            noise.start(time);
            noise.stop(time + 0.05);
            this.bgmOscillators.push(osc, gain, noise, noiseGain);
        };
        const createHiHat = (time, open = false) => {
            const noise = this.ctx.createBufferSource();
            const bufSize = this.ctx.sampleRate * 0.5;
            const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buf;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 8000;
            const panner = this.ctx.createStereoPanner();
            panner.pan.value = [-0.6, 0.6][this.hiHatPanIndex % 2];
            this.hiHatPanIndex++;
            const gain = this.ctx.createGain();
            const decayTime = open ? 0.3 : 0.05;
            gain.gain.setValueAtTime(open ? 0.3 : 0.2, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + decayTime);
            noise.connect(filter).connect(panner).connect(gain).connect(this.masterGain);
            noise.start(time);
            noise.stop(time + decayTime + 0.05);
            this.bgmOscillators.push(noise, filter, panner, gain);
        };
        const createSnare = time => {
            const noise = this.ctx.createBufferSource();
            const bufSize = this.ctx.sampleRate * 0.2;
            const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buf;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1500;
            filter.Q.value = 1;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            noise.connect(filter).connect(gain).connect(this.masterGain);
            noise.start(time);
            noise.stop(time + 0.1);
            this.bgmOscillators.push(noise, filter, gain);
        };
        const createStereoBass = (time, note) => {
            const oscL = this.ctx.createOscillator();
            const oscR = this.ctx.createOscillator();
            const pannerL = this.ctx.createStereoPanner();
            const pannerR = this.ctx.createStereoPanner();
            const filter = this.ctx.createBiquadFilter();
            const gain = this.ctx.createGain();
            oscL.type = 'square';
            oscL.frequency.value = note;
            oscR.type = 'sawtooth';
            oscR.frequency.value = note * 1.01;
            filter.type = 'lowpass';
            filter.Q.value = 5;
            filter.frequency.setValueAtTime(800, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + sixteenth * 0.8);
            gain.gain.setValueAtTime(0.6, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 0.9);
            pannerL.pan.value = -0.8;
            oscL.connect(pannerL).connect(filter);
            pannerR.pan.value = 0.8;
            oscR.connect(pannerR).connect(filter);
            filter.connect(gain).connect(this.masterGain);
            oscL.start(time);
            oscL.stop(time + sixteenth);
            oscR.start(time);
            oscR.stop(time + sixteenth);
            this.bgmOscillators.push(oscL, oscR, pannerL, pannerR, filter, gain);
        };
        const createSequence = (time, note) => {
            const osc = this.ctx.createOscillator();
            const panner = this.ctx.createStereoPanner();
            const gain = this.ctx.createGain();
            const delay = this.ctx.createDelay();
            const feedback = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.9;
            osc.type = 'triangle';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            delay.delayTime.value = sixteenth * 3;
            feedback.gain.value = 0.5;
            osc.connect(panner).connect(gain);
            gain.connect(this.masterGain);
            gain.connect(delay);
            delay.connect(feedback).connect(delay);
            delay.connect(this.masterGain);
            osc.start(time);
            osc.stop(time + 0.1);
            this.bgmOscillators.push(osc, panner, gain, delay, feedback);
        };
        const createStereoPad = (time, note) => {
            const oscL = this.ctx.createOscillator();
            const oscR = this.ctx.createOscillator();
            const pannerL = this.ctx.createStereoPanner();
            const pannerR = this.ctx.createStereoPanner();
            const filter = this.ctx.createBiquadFilter();
            const gain = this.ctx.createGain();
            oscL.type = 'sawtooth';
            oscR.type = 'sawtooth';
            oscL.frequency.value = note;
            oscR.frequency.value = note;
            oscL.detune.value = -10;
            oscR.detune.value = 10;
            pannerL.pan.value = -1;
            pannerR.pan.value = 1;
            filter.type = 'lowpass';
            filter.Q.value = 1;
            filter.frequency.setValueAtTime(200, time);
            filter.frequency.linearRampToValueAtTime(1500, time + sixteenth * 64);
            filter.frequency.linearRampToValueAtTime(200, time + sixteenth * 128);
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.2, time + sixteenth * 4);
            gain.gain.setValueAtTime(0.2, time + sixteenth * 120);
            gain.gain.linearRampToValueAtTime(0, time + sixteenth * 128);
            oscL.connect(pannerL).connect(filter);
            oscR.connect(pannerR).connect(filter);
            filter.connect(gain).connect(this.masterGain);
            oscL.start(time);
            oscL.stop(time + sixteenth * 128);
            oscR.start(time);
            oscR.stop(time + sixteenth * 128);
            this.bgmOscillators.push(oscL, oscR, pannerL, pannerR, filter, gain);
        };
        const createSequence2 = (time, note) => {
            const osc = this.ctx.createOscillator();
            const panner = this.ctx.createStereoPanner();
            const gain = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.7;
            osc.type = 'sine';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.45, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 1.5);
            osc.connect(panner).connect(gain).connect(this.masterGain);
            osc.start(time);
            osc.stop(time + sixteenth * 1.5);
            this.bgmOscillators.push(osc, panner, gain);
        };
        const createSequence3 = (time, note) => {
            const osc = this.ctx.createOscillator();
            const panner = this.ctx.createStereoPanner();
            const gain = this.ctx.createGain();
            const delay = this.ctx.createDelay();
            const feedback = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.9;
            osc.type = 'triangle';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 2);
            delay.delayTime.value = sixteenth * 4;
            feedback.gain.value = 0.5;
            osc.connect(panner).connect(gain);
            gain.connect(this.masterGain);
            gain.connect(delay);
            delay.connect(feedback).connect(delay);
            delay.connect(this.masterGain);
            osc.start(time);
            osc.stop(time + sixteenth * 2);
            this.bgmOscillators.push(osc, panner, gain, delay, feedback);
        };
        const createSequence4 = (time, note) => {
            const osc = this.ctx.createOscillator();
            const panner = this.ctx.createStereoPanner();
            const gain = this.ctx.createGain();
            const delay = this.ctx.createDelay();
            const feedback = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.9;
            osc.type = 'sine';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.35, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 3.5);
            delay.delayTime.value = sixteenth * 3;
            feedback.gain.value = 0.4;
            osc.connect(panner).connect(gain);
            gain.connect(this.masterGain);
            gain.connect(delay);
            delay.connect(feedback).connect(delay);
            delay.connect(this.masterGain);
            osc.start(time);
            osc.stop(time + sixteenth * 3.5);
            this.bgmOscillators.push(osc, panner, gain, delay, feedback);
        };
        const createSequence5 = (time, note) => {
            const osc = this.ctx.createOscillator();
            const panner = this.ctx.createStereoPanner();
            const gain = this.ctx.createGain();
            const delay = this.ctx.createDelay();
            const feedback = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.9;
            osc.type = 'triangle';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 4);
            delay.delayTime.value = sixteenth * 6;
            feedback.gain.value = 0.4;
            osc.connect(panner).connect(gain);
            gain.connect(this.masterGain);
            gain.connect(delay);
            delay.connect(feedback).connect(delay);
            delay.connect(this.masterGain);
            osc.start(time);
            osc.stop(time + sixteenth * 4);
            this.bgmOscillators.push(osc, panner, gain, delay, feedback);
        };

        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
            const beatInLoop = this.current16th % 128;
            const noteInMeasure = beatInLoop % 16;

            if (noteInMeasure === 0) {
                this.barTrigger = true;
            }

            if (noteInMeasure % 4 === 0) {
                createKick(this.nextNoteTime);
                visualBeat = 1.0;
            }
            if (noteInMeasure === 4 || noteInMeasure === 12) {
                createSnare(this.nextNoteTime);
            }
            if (noteInMeasure % 2 === 1) {
                createHiHat(this.nextNoteTime, false);
            }
            if (noteInMeasure === 14) {
                createHiHat(this.nextNoteTime, true);
            }
            if (beatInLoop === 0) {
                createStereoPad(this.nextNoteTime, rootNote * 2);
            }

            const measureIn8BarLoop = Math.floor(beatInLoop / 16);
            if (measureIn8BarLoop % 2 === 0) {
                if ([0, 8].includes(noteInMeasure)) {
                    createStereoBass(this.nextNoteTime, rootNote);
                }
            } else {
                if ([0, 6, 10, 14].includes(noteInMeasure)) {
                    createStereoBass(this.nextNoteTime, rootNote);
                }
            }

            if ([3, 7, 10, 15].includes(noteInMeasure)) {
                createSequence(this.nextNoteTime, [rootNote * 8, rootNote * 16][Math.floor(Math.random() * 2)]);
            }

            if (bgmStage >= 2) {
                if (noteInMeasure % 4 === 0) {
                    const degree = [0, 7, 3, 5][Math.floor(noteInMeasure / 4)];
                    createSequence2(this.nextNoteTime, rootNote * 8 * Math.pow(2, degree / 12));
                }
            }

            if (bgmStage >= 3) {
                if (beatInLoop === 62) {
                    const chordIndex = 1;
                    const chordRootDegree = this.seq3ChordProgression[chordIndex];
                    const note = rootNote * 16 * Math.pow(2, (chordRootDegree + 7) / 12);
                    createSequence3(this.nextNoteTime, note);
                }
                if (beatInLoop === 126) {
                    const chordIndex = 3;
                    const chordRootDegree = this.seq3ChordProgression[chordIndex];
                    const note = rootNote * 16 * Math.pow(2, (chordRootDegree + 2) / 12);
                    createSequence3(this.nextNoteTime, note);
                }
            }
            if (bgmStage >= 4) {
                if (beatInLoop % 8 === 0) {
                    const degree = this.seq4Melody[this.seq4MelodyIndex];
                    const note = rootNote * 16 * Math.pow(2, degree / 12);
                    createSequence4(this.nextNoteTime, note);
                    this.seq4MelodyIndex = (this.seq4MelodyIndex + 1) % this.seq4Melody.length;
                }
            }
            if (bgmStage >= 5) {
                if (beatInLoop % 4 === 0) {
                    const degree = this.seq5Melody[this.seq5MelodyIndex];
                    if (degree !== null) {
                        const note = rootNote * 8 * Math.pow(2, degree / 12);
                        createSequence5(this.nextNoteTime, note);
                    }
                    this.seq5MelodyIndex = (this.seq5MelodyIndex + 1) % this.seq5Melody.length;
                }
            }

            this.nextNoteTime += sixteenth;
            this.current16th = (this.current16th + 1) % 128;
        }
    }

    stopBgm() {
        this.bgmPlaying = false;
        this.bgmOscillators.forEach(o => {
            try {
                o.disconnect();
                if (o.stop) {
                    o.stop(0);
                }
            } catch (e) {}
        });
        this.bgmOscillators = [];
    }

    playSound(type) {
        if (!this.isInitialized || this.isMuted) {
            return;
        }
        const now = this.ctx.currentTime;
        switch (type) {
            case 'itemGet':
                this.createSound(1046, 0.05, "triangle", 0.8, 0.7, now);
                setTimeout(() => this.createSound(1396, 0.1, "triangle", 0.7, 0.7, now + 0.08), 80);
                break;
            case 'waveClear':
                setTimeout(() => this.createSound(523, 0.1, 'sine', 0.9, 0.5, now), 0);
                setTimeout(() => this.createSound(659, 0.1, 'sine', 0.9, 0.5, now + 0.1), 100);
                setTimeout(() => this.createSound(783, 0.1, 'sine', 0.9, 0.5, now + 0.2), 200);
                setTimeout(() => this.createSound(1046, 0.2, 'sine', 0.8, 0.6, now + 0.3), 300);
                break;
            case 'start':
                [261.63, 329.63, 392].forEach((f, i) => this.createSound(f, 0.1, 'square', 0.9, 0.4, now + i * 0.08));
                break;
            case 'glaze':
                this.createSound(880, 0.1, 'triangle', 0.8, 0.5, now, {endFreq: 1200});
                break;
            case 'explosion':
                const b = this.ctx.sampleRate * 0.5;
                const buf = this.ctx.createBuffer(1, b, this.ctx.sampleRate);
                const o = buf.getChannelData(0);
                for (let i = 0; i < b; i++) o[i] = Math.random() * 2 - 1;
                const s = this.ctx.createBufferSource();
                s.buffer = buf;
                const f = this.ctx.createBiquadFilter();
                f.type = 'lowpass';
                f.frequency.setValueAtTime(2000, now);
                f.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(0.7, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                s.connect(f).connect(g).connect(this.masterGain);
                s.start(now);
                s.stop(now + 0.5);
                break;
            case 'invincibleHit':
                this.createSound(1568, 0.1, 'sine', 0.8, 0.8, now);
                setTimeout(() => this.createSound(2093, 0.15, 'sine', 0.7, 0.8, now + 0.07), 70);
                break;
            case 'lowEnergy':
                this.createSound(987, 0.1, 'sawtooth', 0.8, 0.5, now);
                setTimeout(() => this.createSound(987, 0.1, 'sawtooth', 0.8, 0.5, now + 0.15), 150);
                break;
            case 'playerShoot':
                this.createSound(2200, 0.1, 'sawtooth', 0.9, 0.4, now, {endFreq: 300});
                break;
            case 'enemyDestroy':
                this.createSound(200, 0.2, 'square', 0.8, 0.5, now, { endFreq: 50 });
                const noise = this.ctx.createBufferSource();
                const bufSize = this.ctx.sampleRate * 0.15;
                const noiseBuf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
                const data = noiseBuf.getChannelData(0);
                for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = noiseBuf;
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 1200;
                noiseFilter.Q.value = 1;
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.6, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                noise.connect(noiseFilter).connect(noiseGain).connect(this.masterGain);
                noise.start(now);
                noise.stop(now + 0.15);
                this.createSound(1000, 0.1, 'sine', 0.7, 0.3, now + 0.03);
                break;
        }
    }

    playJingle(type) {
        if (!this.isInitialized || this.isMuted) {
            return;
        }
        const now = this.ctx.currentTime;
        switch (type) {
            case 'gameOver':
                this.createSound(220, 0.8, 'sawtooth', 0.2, 0.8, now);
                setTimeout(() => this.createSound(110, 0.8, 'sawtooth', 0.4, 0.8, now + 0.1), 100);
                setTimeout(() => this.createSound(55, 0.8, 'sawtooth', 0.6, 0.8, now + 0.2), 200);
                break;
            case 'specialItemGet':
                [1046, 1318, 1567, 2093].forEach((f, i) => {
                    this.createSound(f, 0.15, 'triangle', 0.8, 0.6, now + i * 0.07);
                });
                break;
        }
    }

    toggleMute() {
        if (!this.isInitialized) {
            return;
        }
        this.isMuted = !this.isMuted;
        this.masterGain.gain.setValueAtTime(this.isMuted ? 0 : this.volume, this.ctx.currentTime);
        return this.isMuted;
    }
}

// ---------------------------------
// „Ç≤„Éº„É†„ÅÆ„É°„Ç§„É≥„É≠„Ç∏„ÉÉ„ÇØ
// ---------------------------------
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const offscreenCanvas = document.createElement('canvas');
offscreenCanvas.width = config.canvasWidth;
offscreenCanvas.height = config.canvasHeight;
const offscreenCtx = offscreenCanvas.getContext('2d');

const audioHandler = new AudioHandler();
const instructionsContainer = document.getElementById('instructions-container');
const mainInstruction = document.getElementById('main-instruction');
const extraInstruction = document.getElementById('extra-instruction');
const controlsInstruction = document.getElementById('controls-instruction');
const controlsInstruction2 = document.getElementById('controls-instruction-2');
const soundToggleButton = document.getElementById('sound-toggle-button');
const effectsToggleButton = document.getElementById('effects-toggle-button');

let gameState = 'title';
let gameMode = 'STANDARD';
let score = 0;
let highScoreStandard = localStorage.getItem(config.highScoreKeyStandard) || 0;
let highScoreJourney = localStorage.getItem(config.highScoreKeyJourney) || 0;
let highScoreStartrail = localStorage.getItem(config.highScoreKeyStartrail) || 0;
let frameCount = 0;

const keyState = {};
window.addEventListener('keydown', e => {
    lastInputDevice = 'keyboard';
    keyState[e.code] = true;
    if (!audioHandler.isInitialized) {
        audioHandler.initialize();
    }
    if (e.code === 'KeyF') {
        toggleFullScreen();
    }
});
window.addEventListener('keyup', e => {
    keyState[e.code] = false;
});

function resetKeys() {
    for (const key in keyState) {
        keyState[key] = false;
    }
}
window.addEventListener('blur', resetKeys);
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
        resetKeys();
    }
});


const input = { left: false, right: false, up: false, down: false, slow: false, shootTrigger: false, titleTrigger: false, replayTrigger: false, pauseTrigger: false };
let wasEnterPressed = false, wasQPressed = false, wasSelectPressed = false;
let wasStartPressed = false, wasPPressed = false, wasUpPressed = false;
let wasDownPressed = false, wasShootPressed = false;

let player;
let comets;
let stars;
let particles;
let effects;
let items;
let scoreTexts;
let playerBullet;
let monsters;
let enemyBullets;

let currentCometSpeed;
let lastInputDevice = 'keyboard';
let stage;
let stageClearFrame;
let currentThemeIndex;
let energy;
let nextItemScore;
let nextSpecialItemScore;
let newHighScoreAchieved;
let elapsedTime;
let lastTimestamp;
let visualBeat = 0;
let nextWayShotFrame;
let isInvincible = false;
let hasUsedInvincibility = false;
let wasMPressed = false;
let hasSpawned5000PointItem;
let gameOverReason = '';
let lowEnergyWarningPlayed;
let screenShake = { intensity: 0, duration: 0 };
let grayscaleAnimation = { progress: 0, duration: 1.0, isActive: false };
let chainCount = 0;
let chainEffectPending = false;
let titleMenuIndex = 0;
const titleMenuItems = ['STANDARD MODE', 'JOURNEY MODE', 'STARTRAIL MODE'];
let invaderSpawnCountForStage = 0;
let invadersSpawnedThisStage = 0;
let hasUFOSpawnedThisStage = false;
let hasLooperSpawnedThisStage = false;
let looperSpawnFrame = -1;
let highScoreDisplayToggle = 0;
let isEffectsEnabled = true;

// ‚ñº‚ñº‚ñº „Åì„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Çí„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Çª„ÇØ„Ç∑„Éß„É≥„Å´ËøΩÂä† ‚ñº‚ñº‚ñº
let titleBottomText = ""; // „Çø„Ç§„Éà„É´ÁîªÈù¢‰∏ãÈÉ®„Å´Ë°®Á§∫„Åï„Çå„Çã„ÉÜ„Ç≠„Çπ„Éà
let descriptionTimer = 0; // Ë™¨ÊòéÊñá„ÅÆË°®Á§∫ÊôÇÈñì„ÇíÁÆ°ÁêÜ„Åô„Çã„Çø„Ç§„Éû„Éº
let effectTimer = 0;      // „ÉÜ„Ç≠„Çπ„ÉàÂàá„ÇäÊõø„Åà„Ç®„Éï„Çß„ÇØ„Éà„ÅÆÊôÇÈñì„ÇíÁÆ°ÁêÜ„Åô„Çã„Çø„Ç§„Éû„Éº
const DESCRIPTION_DISPLAY_DURATION = 120; // Ë™¨ÊòéÊñá„ÅÆË°®Á§∫ÊôÇÈñì (2Áßí @ 60fps)
const EFFECT_DURATION = 12; // „Ç®„Éï„Çß„ÇØ„Éà„ÅÆÊôÇÈñì (0.2Áßí @ 60fps)
const MODE_DESCRIPTIONS = [
    'SHMUP-style Blasting through Enemies',
    'Stay Alive through Energy',
    'Dance Between the Falling Comets'
];
const RANDOM_CHARS = "!?#$@%&<>*=/+ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
// ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†„ÅØ„Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function applyThemeStyles(theme) {
    const borderAlpha = 0.5 + visualBeat * 0.5;
    const shadowSize = 10 + visualBeat * 40;

    canvas.style.borderColor = hexToRgba(theme.ui, borderAlpha);
    canvas.style.boxShadow = `0 0 ${shadowSize}px ${theme.ui}`;
    instructionsContainer.style.color = theme.ui;
    instructionsContainer.style.textShadow = `0 0 10px ${theme.ui}`;
    
    // ‚ñº‚ñº‚ñº „Åì„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Çí‰øÆÊ≠£ ‚ñº‚ñº‚ñº
    const buttons = [soundToggleButton, effectsToggleButton];
    buttons.forEach(button => {
        if (button) {
            button.style.color = theme.ui;
            button.style.textShadow = `0 0 5px ${theme.ui}`;
            button.style.borderColor = theme.ui;
            button.style.boxShadow = `0 0 10px ${theme.ui}`;
            button.style.setProperty('--button-hover-bg', hexToRgba(theme.ui, 0.2));
        }
    });
    // ‚ñ≤‚ñ≤‚ñ≤ ‰øÆÊ≠£„ÅØ„Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤
}

function init() {
    player = {
        x: config.canvasWidth / 2,
        y: config.canvasHeight - 80,
        radius: config.playerHitboxRadius,
        invincibleTimer: 0,
        maxInvincibleTimer: 0
    };
    comets = [];
    particles = [];
    effects = [];
    items = [];
    scoreTexts = [];
    playerBullet = null;
    monsters = [];
    enemyBullets = [];
    stars = Array.from({ length: config.starCount }, () => ({
        x: Math.random() * config.canvasWidth,
        y: Math.random() * config.canvasHeight,
        width: Math.random() * 1.5 + 1,
        length: Math.random() * 10 + 5,
        speed: Math.random() * 20 + 10,
        isGlazed: false,
    }));

    score = 0;
    frameCount = 0;
    elapsedTime = 0;
    lastTimestamp = 0;
    currentCometSpeed = config.initialCometSpeed;
    stage = 1;
    stageClearFrame = STAGE_LENGTH_IN_FRAMES;
    currentThemeIndex = 0;
    energy = config.energyTotal;
    nextItemScore = config.energyItemScoreNormal;
    nextSpecialItemScore = config.energyItemScoreSpecial;
    newHighScoreAchieved = false;
    nextWayShotFrame = (2 + Math.random() * 2) * 60;
    isInvincible = false;
    hasUsedInvincibility = false;
    hasSpawned5000PointItem = false;
    gameOverReason = '';
    lowEnergyWarningPlayed = false;
    screenShake = { intensity: 0, duration: 0 };
    grayscaleAnimation = { progress: 0, duration: 1.0, isActive: false };
    chainCount = 0;
    chainEffectPending = false;
    
    // Reset stage-specific flags
    invaderSpawnCountForStage = 0;
    invadersSpawnedThisStage = 0;
    hasUFOSpawnedThisStage = false;
    hasLooperSpawnedThisStage = false;
    looperSpawnFrame = -1;

    // ‚ñº‚ñº‚ñº ËøΩÂä†„Åï„Çå„ÅüÂàùÊúüÂåñÂá¶ÁêÜ ‚ñº‚ñº‚ñº
    descriptionTimer = 0;
    effectTimer = 0;
    titleBottomText = ""; // ÊúÄÂàù„ÅØÁ©∫„Å´„Åó„Å¶drawÈñ¢Êï∞„ÅßÂàùÊúü„ÉÜ„Ç≠„Çπ„Éà„ÇíË®≠ÂÆö„Åï„Åõ„Çã
    // ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†„Åï„Çå„ÅüÂàùÊúüÂåñÂá¶ÁêÜ ‚ñ≤‚ñ≤‚ñ≤

    canvas.style.filter = 'none';
    canvas.style.webkitFilter = 'none';
    
    applyThemeStyles(themes[currentThemeIndex]);
}

function setupNewStage() {
    stage++;
    currentThemeIndex = (currentThemeIndex + 1) % themes.length;
    stageClearFrame += STAGE_LENGTH_IN_FRAMES;
    effects.push({ type: 'stageClear', text: `STAGE ${stage} START`, life: 120, maxLife: 120 });
    audioHandler.playSound('waveClear');

    // Reset stage-specific flags and determine monster spawn counts for this new stage
    invadersSpawnedThisStage = 0;
    invaderSpawnCountForStage = Math.floor(stage / 2);
    hasUFOSpawnedThisStage = false;
    hasLooperSpawnedThisStage = false;
    
    // Set Looper spawn frame for this stage
    if (stage >= 4 && stage % 2 === 0) {
        const minSpawnFrame = stageClearFrame - STAGE_LENGTH_IN_FRAMES * 0.7;
        const maxSpawnFrame = stageClearFrame - STAGE_LENGTH_IN_FRAMES * 0.3;
        looperSpawnFrame = Math.floor(Math.random() * (maxSpawnFrame - minSpawnFrame) + minSpawnFrame);
    } else {
        looperSpawnFrame = -1;
    }
}

async function startGame(mode) {
    init();
    gameMode = mode;
    gameState = 'playing';
    
    // Determine monster spawn counts for the first stage
    invaderSpawnCountForStage = Math.floor(stage / 2);
    invadersSpawnedThisStage = 0;
    hasUFOSpawnedThisStage = false;
    hasLooperSpawnedThisStage = false;
    looperSpawnFrame = -1; // ÂàùÂõû„Çπ„ÉÜ„Éº„Ç∏„Åß„ÅØÂá∫Áèæ„Åó„Å™„ÅÑ

    audioHandler.playSound('start');
    // BGM„ÅÆÂÜçÁîüÊ∫ñÂÇô„ÅåÈùûÂêåÊúü„ÅßÂÆå‰∫Ü„Åô„Çã„ÅÆ„ÇíÂæÖ„Å§
    await audioHandler.playBgm();
}

function updateInstructions() {
    const pauseText = lastInputDevice === 'keyboard' ? 'PAUSE: P' : 'PAUSE: START';
    mainInstruction.textContent = `${pauseText} / FULLSCREEN: F`;
    
    if (gameMode === 'STARTRAIL MODE') {
        extraInstruction.textContent = 'AVOID COMETS AS LONG AS POSSIBLE';
    } else {
        extraInstruction.textContent = 'ENERGY BOX @ 10,000 PTS';
    }

    const moveText = lastInputDevice === 'keyboard' ? 'MOVE: ARROWS' : 'MOVE: PAD';
    const slowText = lastInputDevice === 'keyboard' ? 'SLOW: Z/SHIFT' : 'SLOW: AB BTN';
    controlsInstruction.textContent = `${moveText} | ${slowText}`;

    const shootText = lastInputDevice === 'keyboard' ? 'SHOOT: X/SPACE' : 'SHOOT: XY BTN';
    controlsInstruction2.textContent = shootText;
}


function pollInput() {
    const gamepads = navigator.getGamepads();
    let gpLeft = false, gpRight = false, gpUp = false, gpDown = false;
    let gpStart = false, gpSlow = false, gpSelect = false, gpShoot = false;

    for (const gp of gamepads) {
        if (!gp) continue;
        if (gp.buttons.some(b => b.pressed) || gp.axes.some(a => Math.abs(a) > 0.1)) {
            lastInputDevice = 'gamepad';
        }
        gpLeft = gp.buttons[14]?.pressed || gp.axes[0] < -0.5;
        gpRight = gp.buttons[15]?.pressed || gp.axes[0] > 0.5;
        gpUp = gp.buttons[12]?.pressed || gp.axes[1] < -0.5;
        gpDown = gp.buttons[13]?.pressed || gp.axes[1] > 0.5;
        gpStart = gp.buttons[9]?.pressed;
        gpSlow = gp.buttons[0]?.pressed || gp.buttons[1]?.pressed;
        gpShoot = gp.buttons[2]?.pressed || gp.buttons[3]?.pressed;
        gpSelect = gp.buttons[8]?.pressed;
    }

    // Direct state for continuous actions (movement, slow)
    input.left = keyState['ArrowLeft'] || gpLeft;
    input.right = keyState['ArrowRight'] || gpRight;
    input.up = keyState['ArrowUp'] || gpUp;
    input.down = keyState['ArrowDown'] || gpDown;
    input.slow = keyState['ShiftLeft'] || keyState['ShiftRight'] || keyState['KeyZ'] || gpSlow;

    // Trigger states for single-press actions
    const isShootPressed = keyState['Space'] || keyState['KeyX'] || gpShoot;
    input.shootTrigger = isShootPressed && !wasShootPressed;
    wasShootPressed = isShootPressed;

    const isPPressed = keyState['KeyP'];
    const isStartPressed = gpStart;
    input.pauseTrigger = (isPPressed && !wasPPressed) || (isStartPressed && !wasStartPressed);
    wasPPressed = isPPressed;
    
    const isEnterPressed = keyState['Enter'];
    const isQPressed = keyState['KeyQ'];
    const isSelectPressed = gpSelect;

    const enterTrigger = isEnterPressed && !wasEnterPressed;
    const qTrigger = isQPressed && !wasQPressed;
    const startTrigger = isStartPressed && !wasStartPressed;
    const selectTrigger = isSelectPressed && !wasSelectPressed;

    // gameState„Å´Âøú„Åò„Å¶„Éà„É™„Ç¨„Éº„ÇíË®≠ÂÆö
    if (gameState === 'title') {
        input.replayTrigger = enterTrigger || startTrigger;
        input.titleTrigger = false;
    } else if (gameState === 'gameOver') {
        input.replayTrigger = enterTrigger || startTrigger;
        input.titleTrigger = qTrigger || selectTrigger;
    } else if (gameState === 'paused') {
        input.replayTrigger = false;
        input.titleTrigger = qTrigger || selectTrigger;
    } else { // playing
        input.replayTrigger = false;
        input.titleTrigger = false;
    }
     
    const isUpPressed = input.up;
    input.upTrigger = isUpPressed && !wasUpPressed;
    wasUpPressed = isUpPressed;

    const isDownPressed = input.down;
    input.downTrigger = isDownPressed && !wasDownPressed;
    wasDownPressed = isDownPressed;
    
    wasStartPressed = isStartPressed;
    wasEnterPressed = isEnterPressed;
    wasSelectPressed = isSelectPressed;
    wasQPressed = isQPressed;
}


function triggerSpecialItemEffect() {
    energy = config.energyTotal;
    audioHandler.playJingle('specialItemGet');
    triggerInvincibility(150);
}

function triggerNormalItemEffect() {
    energy += config.energyTotal * 0.5;
    energy = Math.min(config.energyTotal, energy);
    audioHandler.playSound('itemGet');
    triggerInvincibility(90);
}

function triggerInvincibility(baseFrames) {
    if (player.invincibleTimer > 0) {
        chainCount++;
        effects.push({ type: 'chainComboUpdate', life: 60, maxLife: 60 });
        chainEffectPending = true;
    } else {
        chainCount = 1;
    }

    const chainLevelForTime = Math.floor((chainCount - 1) / 3);
    const timeReductionMultiplier = Math.pow(0.9, chainLevelForTime);
    const newItemInvincibleFrames = Math.floor(baseFrames * timeReductionMultiplier);

    let finalInvincibleTime;
    if (player.invincibleTimer > 0) {
        const longerTime = Math.max(player.invincibleTimer, newItemInvincibleFrames);
        finalInvincibleTime = longerTime + 30 * timeReductionMultiplier;
    } else {
        finalInvincibleTime = newItemInvincibleFrames;
    }
    player.invincibleTimer = finalInvincibleTime;
    player.maxInvincibleTimer = finalInvincibleTime;

    effects.push({
        type: 'textMorph',
        life: finalInvincibleTime,
        maxLife: finalInvincibleTime,
    });
}

function gameOver(reason) {
    if (gameState === 'gameOver') {
        return;
    }
    gameState = 'gameOver';
    gameOverReason = reason;

    audioHandler.stopBgm();
    audioHandler.playJingle('gameOver');
    
    let currentHighScore;
    let highScoreKey;

    switch(gameMode) {
        case 'STANDARD MODE':
            currentHighScore = highScoreStandard;
            highScoreKey = config.highScoreKeyStandard;
            break;
        case 'JOURNEY MODE':
            currentHighScore = highScoreJourney;
            highScoreKey = config.highScoreKeyJourney;
            break;
        case 'STARTRAIL MODE':
            currentHighScore = highScoreStartrail;
            highScoreKey = config.highScoreKeyStartrail;
            break;
    }

    if (score > currentHighScore && !hasUsedInvincibility) {
        currentHighScore = score;
        localStorage.setItem(highScoreKey, currentHighScore);
        
        switch(gameMode) {
            case 'STANDARD MODE':
                highScoreStandard = currentHighScore;
                break;
            case 'JOURNEY MODE':
                highScoreJourney = currentHighScore;
                break;
            case 'STARTRAIL MODE':
                highScoreStartrail = currentHighScore;
                break;
        }
        newHighScoreAchieved = true;
    }


    if (reason === 'collision') {
        audioHandler.playSound('explosion');
        screenShake = { intensity: 25, duration: 45 };
        effects.push({ type: 'shockwave', x: player.x, y: player.y, life: 30, maxLife: 30, radius: 20 });
        effects.push({ type: 'screenFlash', life: 15, maxLife: 15 });

        // ‚ñº‚ñº‚ñº „Åì„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Çí‰øÆÊ≠£ ‚ñº‚ñº‚ñº
        const particleCount = isEffectsEnabled ? 350 : 50; // EFX OFFÊôÇ„ÅØ„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÇíÊ∏õ„Çâ„Åô
        for (let i = 0; i < particleCount; i++) {
        // ‚ñ≤‚ñ≤‚ñ≤ ‰øÆÊ≠£„ÅØ„Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤
            const angle = Math.random() * Math.PI * 2;
            const speed = (Math.random() * 15 + 5) * 60;
            const theme = themes[currentThemeIndex];
            const color = [theme.player, theme.comet, theme.ui, '#ff3344', '#ffff00', '#ffffff'][Math.floor(Math.random() * 6)];
            particles.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: Math.random() * 100 + 80,
                maxLife: 180,
                color: color,
                gravityMultiplier: Math.random() * 0.6 + 0.7,
            });
        }
    } else if (reason === 'energy') {
        effects.push({ type: 'energyGameOverFlash', life: 8, maxLife: 8 });
        grayscaleAnimation.isActive = true;
        grayscaleAnimation.progress = 0;
    }
}

function spawnWayComets() {
    const wayCount = Math.floor(Math.random() * (stage - 1)) + 2;
    const startX = Math.random() * config.canvasWidth;
    const startY = -config.cometCoreRadius * 2;
    const targetX = player.x;
    const targetY = player.y;
    const angleToPlayer = Math.atan2(targetY - startY, targetX - startX);
    const speed = currentCometSpeed * 0.75;
    const spreadAngle = Math.PI / 8;
    const totalAngle = spreadAngle * (wayCount - 1);
    const startAngle = angleToPlayer - totalAngle / 2;

    for (let i = 0; i < wayCount; i++) {
        const angle = startAngle + i * spreadAngle;
        comets.push({
            x: startX,
            y: startY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: config.cometCoreRadius,
            isGlazed: false,
            isWay: true
        });
    }
}

function updateBackground(dt_sec) {
    if (gameState === 'playing' || gameState === 'title' || gameState === 'gameOver') {
        let speedRatio;
        if (gameState === 'playing') {
            speedRatio = currentCometSpeed / config.initialCometSpeed;
        } else { // title or gameOver
            speedRatio = 0.3;
        }

        if (speedRatio > 0 && !isNaN(dt_sec)) {
            stars.forEach(s => {
                s.y += s.speed * config.starScrollMultiplier * speedRatio * dt_sec;
                if (s.y > config.canvasHeight) {
                    s.y = 0;
                    s.x = Math.random() * config.canvasWidth;
                    s.isGlazed = false;
                }
            });
        }
    }
}

function updatePlayingState(dt_sec) {
    // Bar line effect
    if (audioHandler.barTrigger) {
        effects.push({ type: 'barLine', life: 30, maxLife: 30 });
        audioHandler.barTrigger = false;
    }

    // Player invincibility timer
    if (player.invincibleTimer > 0) {
        player.invincibleTimer -= 60 * dt_sec;
        if (player.invincibleTimer <= 0) {
            player.invincibleTimer = 0;
            if (chainCount > 1) {
                effects.push({ type: 'comboFadeOut', life: 12, maxLife: 12, count: chainCount });
            }
            chainCount = 0;
        }
    }

    // Player Movement
    const isPlayerTemporarilyInvincible = player.invincibleTimer > 0;
    const isPlayerInvincible = isInvincible || isPlayerTemporarilyInvincible;
    let currentSpeed = (input.slow ? config.playerSpeed * config.playerSlowModeMultiplier : config.playerSpeed) * dt_sec;
    if (player.invincibleTimer > 0) {
        currentSpeed *= 1.1;
    }
    if (input.left) player.x -= currentSpeed;
    if (input.right) player.x += currentSpeed;
    player.x = Math.max(0, Math.min(config.canvasWidth, player.x));

    // Player Shooting (Both modes)
    if (input.shootTrigger && !playerBullet) {
        if (gameMode !== 'STARTRAIL MODE') {
            if (!lowEnergyWarningPlayed) {
                energy -= config.energyTotal / 15;
            }
        }

        playerBullet = {
            x: player.x,
            y: player.y - config.playerVisualSize,
            width: 3,
            height: 10,
        };
        audioHandler.playSound('playerShoot');
    }

    // Update Player Bullet
    if (playerBullet) {
        playerBullet.y -= config.playerBulletSpeed * dt_sec;
        if (playerBullet.y < 0) {
            playerBullet = null;
        }
    }

    // Score and Difficulty Progression
    const stageMultiplier = Math.pow(1.1, stage - 1);
    score += Math.floor(config.distanceScoreMultiplier * (currentCometSpeed / config.initialCometSpeed) * stageMultiplier);
    currentCometSpeed += config.cometSpeedIncrease * dt_sec;

    // Energy Management (STARTRAIL MODE„Åß„ÅØ„Çπ„Ç≠„ÉÉ„Éó)
    if (gameMode !== 'STARTRAIL MODE') {
        const baseEnergyMultiplier = 0.9;
        const energyDecreaseRate = Math.pow(1.12, stage - 1);
        energy -= baseEnergyMultiplier * energyDecreaseRate * 60 * dt_sec;

        const energyThreshold = config.energyTotal / 3;
        if (energy <= energyThreshold && gameState === 'playing') {
            if (!lowEnergyWarningPlayed) lowEnergyWarningPlayed = true;
            if (frameCount % 60 === 0) {
                audioHandler.playSound('lowEnergy');
            }
        } else {
            if (lowEnergyWarningPlayed) lowEnergyWarningPlayed = false;
        }

        if (energy <= 0 && !isPlayerInvincible) {
            gameOver('energy');
            return;
        }
    }


    // Stage Progression
    if (frameCount >= stageClearFrame) {
        setupNewStage();
    }

    // Comet Spawning
    if (stage >= 2 && frameCount >= nextWayShotFrame) {
        spawnWayComets();
        const baseInterval = Math.max(3, 10 - stage) * 15;
        const randomInterval = baseInterval * (0.5 + Math.random());
        nextWayShotFrame = frameCount + randomInterval;
    }

    const stageSpeedMod = 1 + (stage - 1) * 0.08;
    const spawnInterval = Math.max(3, Math.floor(config.cometSpawnInterval / (1 + (stage - 1) * 0.2)));
    if (frameCount % spawnInterval === 0) {
        for (let i = 0; i < config.cometSpawnAmount; i++) {
            comets.push({
                x: Math.random() * config.canvasWidth,
                y: -config.cometCoreRadius,
                radius: config.cometCoreRadius,
                isGlazed: false
            });
        }
    }
    
    // Monster Spawning (Standard Mode only)
    if (gameMode === 'STANDARD MODE') {
        // Looper Spawning
        if (looperSpawnFrame !== -1 && frameCount >= looperSpawnFrame && !hasLooperSpawnedThisStage) {
            hasLooperSpawnedThisStage = true;
            monsters.push({
                type: 'looper',
                hp: 1,
                angle: Math.random() * Math.PI * 2,
                speed: (1.5 + (stage * 0.1)) * (4/9), 
                direction: Math.random() < 0.5 ? 1 : -1,
                width: 14 * 6,
                height: 14 * 6,
                shootCooldown: 0,
                shootAngle: Math.random() * Math.PI * 2
            });
        }
        
        const spawnCheckInterval = 120;
        if (frameCount % spawnCheckInterval === 0) {
            // UFO Spawning
            if (stage % 3 === 0 && !hasUFOSpawnedThisStage && Math.random() < 0.2) {
                hasUFOSpawnedThisStage = true;
                const startX = Math.random() < 0.5 ? -30 : config.canvasWidth + 30;
                const speedX = startX < 0 ? 250 : -250;
                monsters.push({
                    type: 'ufo',
                    x: startX,
                    y: 50 + Math.random() * 100,
                    vx: speedX,
                    vy: 0,
                    width: 14 * 4,
                    height: 14 * 4,
                    shootCooldown: 30 + Math.random() * 15,
                });
            }

            // Invader Spawning
            const hasInvaderOnScreen = monsters.some(m => m.type === 'invader');
            if (invadersSpawnedThisStage < invaderSpawnCountForStage && !hasInvaderOnScreen && Math.random() < 0.5) {
                invadersSpawnedThisStage++;
                monsters.push({
                    type: 'invader',
                    x: Math.random() * config.canvasWidth,
                    y: -30,
                    vx: 0,
                    vy: 150,
                    width: 14 * 4,
                    height: 14 * 4,
                    shootCooldown: 30 + Math.random() * 30,
                });
            }
        }
    }

    // Energy Item Spawning (STARTRAIL MODE„Åß„ÅØ„Çπ„Ç≠„ÉÉ„Éó)
    if (gameMode !== 'STARTRAIL MODE') {
        const comboMultiplier = chainCount > 1 ? Math.pow(1.1, chainCount - 1) : 1;
        const totalMultiplier = stageMultiplier * comboMultiplier;
        const currentNormalThreshold = config.energyItemScoreNormal * totalMultiplier;
        const currentSpecialThreshold = config.energyItemScoreSpecial * totalMultiplier;

        if (!hasSpawned5000PointItem && score >= 5000) {
            items.push({ x: Math.random() * config.canvasWidth, y: -20, type: 'normal' });
            hasSpawned5000PointItem = true;
        }
        while (score >= nextSpecialItemScore) {
            items.push({ x: Math.random() * config.canvasWidth, y: -20, type: 'special' });
            nextSpecialItemScore += currentSpecialThreshold;
            nextItemScore = Math.floor(score / currentNormalThreshold) * currentNormalThreshold + currentNormalThreshold;
        }
        while (score >= nextItemScore) {
            if (nextItemScore < nextSpecialItemScore) {
                items.push({ x: Math.random() * config.canvasWidth, y: -20, type: 'normal' });
            }
            nextItemScore += currentNormalThreshold;
        }
    }


    // Update Comets
    for (let i = comets.length - 1; i >= 0; i--) {
        const c = comets[i];
        if (c.vx !== undefined && c.vy !== undefined) {
            c.x += c.vx * dt_sec;
            c.y += c.vy * dt_sec;
        } else {
            c.y += currentCometSpeed * stageSpeedMod * dt_sec;
        }

        if (c.y - c.radius > config.canvasHeight || c.x < -c.radius || c.x > config.canvasWidth + c.radius) {
            comets.splice(i, 1);
            continue;
        }

        const dx = player.x - c.x;
        const dy = player.y - c.y;
        const d = Math.sqrt(dx * dx + dy * dy);

        if (isPlayerInvincible) {
            if (d < config.playerVisualSize + c.radius) {
                const baseBonusScore = 1500;
                const comboMultiplier = chainCount > 1 ? Math.pow(1.1, chainCount - 1) : 1;
                const bonusScore = Math.floor(baseBonusScore * stageMultiplier * comboMultiplier);
                score += bonusScore;
                scoreTexts.push({ x: player.x, y: player.y - 30, text: `+${bonusScore}`, life: 60, type: 'bonus' });
                audioHandler.playSound('invincibleHit');
                comets.splice(i, 1);
                continue;
            }
        } else {
            if (d < player.radius + c.radius) {
                gameOver('collision');
                return;
            }
        }

        const currentGlazeDistance = player.invincibleTimer > 0 ? config.glazeDistance * 1.5 : config.glazeDistance;
        if (!c.isGlazed && d < player.radius + c.radius + currentGlazeDistance) {
            c.isGlazed = true;
            const points = Math.floor(config.glazeScore * stageMultiplier);
            score += points;
            scoreTexts.push({ x: c.x, y: c.y, text: `+${points}`, life: 60, type: 'glaze' });
            audioHandler.playSound('glaze');
        }
    }
    
    // Update Monsters (Standard Mode only)
    if (gameMode === 'STANDARD MODE') {
        for (let i = monsters.length - 1; i >= 0; i--) {
            const m = monsters[i];
            
            // Movement Update
            if (m.type === 'looper') {
                m.angle += m.speed * m.direction * dt_sec;
                m.x = config.canvasWidth / 2 + Math.cos(m.angle) * (config.canvasWidth / 2.5);
                m.y = (config.canvasHeight / 4) + Math.sin(m.angle) * (config.canvasHeight / 5);
            } else {
                m.x += m.vx * dt_sec;
                m.y += m.vy * dt_sec;
            }

            // Monster shooting
            if (m.shootCooldown !== undefined) {
                m.shootCooldown -= 60 * dt_sec;
                if (m.shootCooldown <= 0) {
                     if (m.type === 'looper') {
			// ‚ñº‚ñº‚ñº „É´„Éº„Éó„ÉâÊîªÊíÉ„Éë„Çø„Éº„É≥Â§âÊõ¥ ‚ñº‚ñº‚ñº
                        m.shootAngle += (Math.PI / 6); // 30Â∫¶„Åö„Å§ÂõûËª¢
                        const bulletSpeed = 200;
                        enemyBullets.push({
                            x: m.x, y: m.y, 
                            vx: bulletSpeed * Math.cos(m.shootAngle), 
                            vy: bulletSpeed * Math.sin(m.shootAngle), 
                            radius: 4, isGlazed: false
                        });
                        // 1Áßí„Å´16Áô∫„Å´„Å™„Çã„Çà„ÅÜ„Å´„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥„ÇíË®≠ÂÆö (1/16=0.0625)
                        m.shootCooldown = 60 * 0.0625;
                        // ‚ñ≤‚ñ≤‚ñ≤ „É´„Éº„Éó„ÉâÊîªÊíÉ„Éë„Çø„Éº„É≥Â§âÊõ¥ ‚ñ≤‚ñ≤‚ñ≤
                    } else if (m.type === 'ufo') {
                        const angles = [-0.4, -0.2, 0, 0.2, 0.4]; // 5-way
                        angles.forEach(angle => {
                            enemyBullets.push({x: m.x, y: m.y, vx: 250 * Math.sin(angle), vy: 250 * Math.cos(angle), radius: 4, isGlazed: false});
                        });
                        m.shootCooldown = 45 + Math.random() * 15;
                    } else if (m.type === 'invader') {
                        const angleToPlayer = Math.atan2(player.y - m.y, player.x - m.x);
                        const spread = Math.PI / 8;
                        const angles = [angleToPlayer - spread, angleToPlayer, angleToPlayer + spread];
                        const bulletSpeed = 350;
                        angles.forEach(angle => {
                            enemyBullets.push({
                                x: m.x, y: m.y, 
                                vx: bulletSpeed * Math.cos(angle), 
                                vy: bulletSpeed * Math.sin(angle), 
                                radius: 4, isGlazed: false
                            });
                        });
                        m.shootCooldown = 90 + Math.random() * 40;
                    }
                }
            }

            // Check collision with player bullet
            if (playerBullet) {
                if (playerBullet.x > m.x - m.width / 2 && playerBullet.x < m.x + m.width / 2 &&
                    playerBullet.y > m.y - m.height / 2 && playerBullet.y < m.y + m.height / 2) {
                    
                    playerBullet = null;
                    audioHandler.playSound('invincibleHit');
                    const comboMultiplier = chainCount > 1 ? Math.pow(1.1, chainCount - 1) : 1;
                    
                    if (m.hp) {
                        m.hp--;
                        if (m.hp <= 0) {
                             const baseScore = config.monsterLooperBaseScore;
                             const earnedScore = Math.floor(baseScore * stageMultiplier * comboMultiplier);
                             score += earnedScore;
                             scoreTexts.push({ x: m.x, y: m.y, text: `+${earnedScore}`, life: 60, type: 'bonus' });
                             audioHandler.playSound('enemyDestroy');
                             screenShake = { intensity: 15, duration: 30 };
                             effects.push({ type: 'shockwave', x: m.x, y: m.y, life: 15, maxLife: 15, radius: 10 });
                             monsters.splice(i, 1);
                             triggerSpecialItemEffect();
                        }
                    } else {
                        const baseScore = m.type === 'ufo' ? config.monsterUFOBaseScore : config.monsterInvaderBaseScore;
                        const earnedScore = Math.floor(baseScore * stageMultiplier * comboMultiplier);
                        score += earnedScore;
                        scoreTexts.push({ x: m.x, y: m.y, text: `+${earnedScore}`, life: 60, type: 'bonus' });
                        
                        audioHandler.playSound('enemyDestroy');
                        if(m.type === 'ufo') {
                            screenShake = { intensity: 15, duration: 30 };
                        }
                        effects.push({ type: 'shockwave', x: m.x, y: m.y, life: 15, maxLife: 15, radius: 10 });
                        monsters.splice(i, 1);
                        
                        if (m.type === 'ufo') {
                            triggerSpecialItemEffect();
                        } else {
                            triggerNormalItemEffect();
                        }
                    }
                    continue;
                }
            }
            
            // Check collision with player
            const dx = player.x - m.x;
            const dy = player.y - m.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (isPlayerInvincible) {
                if (dist < player.radius + m.width / 2) {
                    const comboMultiplier = chainCount > 1 ? Math.pow(1.1, chainCount - 1) : 1;
                    const bonusScore = Math.floor(config.monsterCollisionBonus * stageMultiplier * comboMultiplier);
                    score += bonusScore;
                    scoreTexts.push({ x: player.x, y: player.y - 30, text: `+${bonusScore}`, life: 60, type: 'bonus' });
                    audioHandler.playSound('invincibleHit');
                    if (m.type === 'ufo' || m.type === 'looper') {
                        screenShake = { intensity: 15, duration: 30 };
                        triggerSpecialItemEffect();
                    } else {
                        triggerNormalItemEffect();
                    }
                    monsters.splice(i, 1);
                    continue;
                }
            } else {
                 if (dist < player.radius + m.width / 2) {
                    gameOver('collision');
                    return;
                }
            }

            // Despawn if off-screen (for UFO and Invader)
            if (m.type !== 'looper' && (m.y > config.canvasHeight + 50 || m.x < -50 || m.x > config.canvasWidth + 50)) {
                monsters.splice(i, 1);
            }
        }

        // Update Enemy Bullets
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const eb = enemyBullets[i];
            eb.x += eb.vx * dt_sec;
            eb.y += eb.vy * dt_sec;

            const dx = player.x - eb.x;
            const dy = player.y - eb.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (isPlayerInvincible) {
                 if (dist < config.playerVisualSize + eb.radius) {
                    const baseBonusScore = 1500;
                    const comboMultiplier = chainCount > 1 ? Math.pow(1.1, chainCount - 1) : 1;
                    const bonusScore = Math.floor(baseBonusScore * stageMultiplier * comboMultiplier);
                    score += bonusScore;
                    scoreTexts.push({ x: player.x, y: player.y - 30, text: `+${bonusScore}`, life: 60, type: 'bonus' });
                    audioHandler.playSound('invincibleHit');
                    enemyBullets.splice(i, 1);
                    continue;
                }
            } else {
                if (dist < player.radius + eb.radius) {
                    gameOver('collision');
                    return;
                }
            }

            const currentGlazeDistance = player.invincibleTimer > 0 ? config.glazeDistance * 1.5 : config.glazeDistance;
            if (!eb.isGlazed && dist < player.radius + eb.radius + currentGlazeDistance) {
                eb.isGlazed = true;
                const points = Math.floor(config.glazeScore * stageMultiplier);
                score += points;
                scoreTexts.push({ x: eb.x, y: eb.y, text: `+${points}`, life: 60, type: 'glaze' });
                audioHandler.playSound('glaze');
            }

            if (eb.y > config.canvasHeight + 20 || eb.y < -20 || eb.x < -20 || eb.x > config.canvasWidth + 20) {
                enemyBullets.splice(i, 1);
            }
        }
    }


    // Update Items
    for (let index = items.length - 1; index >= 0; index--) {
        const item = items[index];
        item.y += config.energyItemSpeed * dt_sec;
        const dist = Math.sqrt(Math.pow(player.x - item.x, 2) + Math.pow(player.y - item.y, 2));

        if (dist < config.playerVisualSize + config.energyItemSize) {
            if (item.type === 'special') {
                triggerSpecialItemEffect();
            } else {
                triggerNormalItemEffect();
            }
            items.splice(index, 1);
            continue;
        }
        if (item.y > config.canvasHeight + 20) {
            items.splice(index, 1);
        }
    }

    // Update Score Texts
    for (let i = scoreTexts.length - 1; i >= 0; i--) {
        const st = scoreTexts[i];
        st.life--;
        st.y -= 0.5;
        if (st.life <= 0) {
            scoreTexts.splice(i, 1);
        }
    }
}

function update(timestamp) {
    if (gameState !== 'paused') {
        if (!lastTimestamp) {
            lastTimestamp = timestamp;
        }
        const dt_ms = timestamp - lastTimestamp;
        const dt_sec = Math.min(dt_ms / 1000, 1 / 30);
        lastTimestamp = timestamp;

        pollInput();
        updateInstructions();
        
        if (screenShake.duration > 0) {
            screenShake.duration--;
            if (screenShake.duration <= 0) {
                screenShake.intensity = 0;
            }
        }

        if (grayscaleAnimation.isActive && grayscaleAnimation.progress < 1) {
            grayscaleAnimation.progress += dt_sec / 1.0;
            if (grayscaleAnimation.progress > 1) {
                grayscaleAnimation.progress = 1;
            }
        }

        if (gameState === 'playing' && input.pauseTrigger) {
            gameState = 'paused';
            if (audioHandler.ctx) {
                audioHandler.masterGain.gain.exponentialRampToValueAtTime(0.001, audioHandler.ctx.currentTime + 0.2);
            }
            return;
        }

        // Toggle invincibility cheat
        const isMPressed = keyState['KeyM'];
        if (isMPressed && !wasMPressed) {
            if (gameState === 'playing') {
                isInvincible = !isInvincible;
                if (isInvincible) hasUsedInvincibility = true;
            }
        }
        wasMPressed = isMPressed;


        const previousVisualBeat = visualBeat;
        visualBeat *= 0.85;
        if (visualBeat < 0.01) {
            visualBeat = 0;
        }

        updateBackground(dt_sec);
        
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life--;
            if (p.life <= 0) {
                particles.splice(i, 1);
            } else {
                if (p.gravityMultiplier) {
                    p.vy += config.gravity * p.gravityMultiplier * dt_sec;
                }
                p.x += p.vx * dt_sec;
                p.y += p.vy * dt_sec;
            }
        }
        
        for (let i = effects.length - 1; i >= 0; i--) {
            const e = effects[i];
            e.life--;
            if (e.life <= 0) {
                effects.splice(i, 1);
            }
        }

        if (gameState === 'playing') {
            frameCount++;
            audioHandler.scheduleBGM();
            elapsedTime += dt_ms;
            updatePlayingState(dt_sec);

            if (chainEffectPending && visualBeat >= 1.0 && previousVisualBeat < 1.0) {
                effects.push({ type: 'shockwave', x: 150, y: 65, life: 20, maxLife: 20, radius: 20 });
                effects.push({ type: 'screenFlash', life: 8, maxLife: 8 });
                chainEffectPending = false;
            }

        } else if (gameState === 'title') {
            frameCount++;

            // --- „Çø„Ç§„Éû„ÉºÊõ¥Êñ∞ ---
            if (effectTimer > 0) {
                effectTimer--;
            }
            if (descriptionTimer > 0) {
                descriptionTimer--;
                if (descriptionTimer === 0) {
                    // Ë™¨ÊòéË°®Á§∫ÊúüÈñì„ÅåÂÆåÂÖ®„Å´ÁµÇ‰∫Ü„Åó„Åü„ÅÆ„Åß„ÄÅÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Å´Êàª„Çã„Åü„ÇÅ„ÅÆ„Ç®„Éï„Çß„ÇØ„Éà„ÇíÈñãÂßã
                    effectTimer = EFFECT_DURATION;
                }
            }

            // --- ÂÖ•ÂäõÂá¶ÁêÜ ---
            const prevMenuIndex = titleMenuIndex;
            if (input.upTrigger) {
                titleMenuIndex = (titleMenuIndex - 1 + titleMenuItems.length) % titleMenuItems.length;
            }
            if (input.downTrigger) {
                titleMenuIndex = (titleMenuIndex + 1) % titleMenuItems.length;
            }

            if (prevMenuIndex !== titleMenuIndex) {
                // „É°„Éã„É•„Éº„ÅåÂ§âÊõ¥„Åï„Çå„Åü„ÅÆ„Åß„ÄÅ„Ç®„Éï„Çß„ÇØ„Éà„Å®Ë™¨Êòé„Çø„Ç§„Éû„Éº„ÇíÈñãÂßã
                effectTimer = EFFECT_DURATION;
                descriptionTimer = DESCRIPTION_DISPLAY_DURATION;
            }

            // --- Ë°®Á§∫„ÉÜ„Ç≠„Çπ„Éà„ÅÆÊ±∫ÂÆö ---
            let targetText;
            if (descriptionTimer > 0) {
                targetText = MODE_DESCRIPTIONS[titleMenuIndex];
            } else {
                targetText = lastInputDevice === 'keyboard' ? 'Press Enter to Start' : 'Press Start Button to Start';
            }

            if (effectTimer > 0) {
                let randomText = '';
                // Ë°®Á§∫„Åï„Çå„Çã„ÉÜ„Ç≠„Çπ„Éà„ÅÆÈï∑„Åï„Å´Âêà„Çè„Åõ„Å¶„É©„É≥„ÉÄ„É†„Å™ÊñáÂ≠óÂàó„ÇíÁîüÊàê
                for (let i = 0; i < targetText.length; i++) {
                    randomText += RANDOM_CHARS[Math.floor(Math.random() * RANDOM_CHARS.length)];
                }
                titleBottomText = randomText;
            } else {
                titleBottomText = targetText;
            }
            
            // --- „Ç≤„Éº„É†ÈñãÂßãÂá¶ÁêÜ ---
            if (input.replayTrigger) {
                audioHandler.initialize();
                startGame(titleMenuItems[titleMenuIndex]);
            }
        } else if (gameState === 'gameOver') {
            frameCount++; // Keep frameCount running for animations
            if (input.titleTrigger) {
                 gameState = 'title';
                 init();
            } else if (input.replayTrigger) {
                startGame(gameMode);
            }
        }
    } else { // Paused
        pollInput();
        updateInstructions();
        if (input.pauseTrigger) {
            gameState = 'playing';
            lastTimestamp = 0;
            if (!audioHandler.isMuted && audioHandler.ctx) {
                audioHandler.masterGain.gain.exponentialRampToValueAtTime(audioHandler.volume, audioHandler.ctx.currentTime + 0.2);
            }
        } else if (input.titleTrigger) {
             audioHandler.stopBgm();
             if (audioHandler.masterGain && !audioHandler.isMuted && audioHandler.ctx) {
                 audioHandler.masterGain.gain.setValueAtTime(audioHandler.volume, audioHandler.ctx.currentTime);
             }
             gameState = 'title';
             init();
        }
    }
}

function drawRoundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}

function drawWithGlow(ctx, drawFunc, color, useBeat = false) {
    // ‚ñº‚ñº‚ñº „Åì„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Çí‰øÆÊ≠£ ‚ñº‚ñº‚ñº
    if (!isEffectsEnabled) {
        drawFunc(); // EFX OFFÊôÇ„ÅØ„Ç∞„É≠„Éº„ÇíÈÅ©Áî®„Åõ„Åö„ÄÅÊèèÁîªÈñ¢Êï∞„ÅÆ„ÅøÂÆüË°å
        return;
    }
    // ‚ñ≤‚ñ≤‚ñ≤ ‰øÆÊ≠£„ÅØ„Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤
    const blurAmount = useBeat ? (config.glowBlur + visualBeat * 8) : config.glowBlur;
    ctx.shadowColor = color;
    ctx.shadowBlur = blurAmount;
    drawFunc();
    ctx.shadowBlur = 0;
}

function drawGrid(ctx, color) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.globalAlpha = 0.06 + visualBeat * 0.04;
    ctx.lineWidth = 1;
    for (let i = 0; i < config.canvasHeight; i += 20) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(config.canvasWidth, i);
        ctx.stroke();
    }
    for (let i = 0; i < config.canvasWidth; i += 20) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, config.canvasHeight);
        ctx.stroke();
    }
    ctx.restore();
}

function drawPixelArt(ctx, artData, centerX, centerY, pixelSize, palette) {
    const artHeight = artData.length;
    const artWidth = artData[0].length;
    const totalWidth = artWidth * pixelSize;
    const totalHeight = artHeight * pixelSize;
    const startX = centerX - totalWidth / 2;
    const startY = centerY - totalHeight / 2;

    for (let r = 0; r < artHeight; r++) {
        for (let c = 0; c < artWidth; c++) {
            const colorCode = artData[r][c];
            if (colorCode !== 0) {
                ctx.fillStyle = palette[colorCode];
                ctx.fillRect(startX + c * pixelSize, startY + r * pixelSize, pixelSize, pixelSize);
            }
        }
    }
}

function drawPlayer(ctx, color) {
    const basePixelSize = 2;
    const beatScale = visualBeat * 0.8;
    const pixelSize = basePixelSize + beatScale;

    const palette = {
        '1': color,
        '2': '#ffffff',
        '3': '#ffff00',
    };

    drawWithGlow(ctx, () => {
        drawPixelArt(ctx, PLAYER_PIXEL_ART, player.x, player.y, pixelSize, palette);
    }, color, true);

    if (input.slow) {
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        const slowMarkerRadius = PLAYER_PIXEL_ART[0].length * pixelSize * 0.15;
        ctx.arc(player.x, player.y, slowMarkerRadius, 0, Math.PI * 2);
        ctx.fill();
    }
}

function formatTime(ms) {
    if (isNaN(ms)) ms = 0;
    const m = Math.floor(ms / 60000);
    const s = Math.floor((ms % 60000) / 1000);
    const msec = Math.floor(ms % 1000);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${String(msec).padStart(3,'0')}`;
}

function drawChainComboText(renderCtx, count, alpha = 1.0) {
    const comboText = `${count} CHAIN COMBO!!`;
    const baseFontSize = 16;
    const sizeStep = 2;
    const maxChainForSizing = 30;
    const chainLevel = Math.floor((Math.min(count, maxChainForSizing) - 1) / 5);
    let fontSize = baseFontSize + chainLevel * sizeStep;
    
    const comboEffect = effects.find(e => e.type === 'chainComboUpdate');
    let textToDraw = comboText;
    if (comboEffect && alpha === 1.0) {
        const progress = 1 - (comboEffect.life / comboEffect.maxLife);
        fontSize = fontSize * 1.2 - (fontSize * 0.2) * progress;

        const chars = "!?#$ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        textToDraw = "";
        for (let i = 0; i < comboText.length; i++) {
            if (progress > (i / comboText.length) * 0.5 + (Math.random() * 0.1)) {
                textToDraw += comboText[i];
            } else {
                textToDraw += chars[Math.floor(Math.random() * chars.length)];
            }
        }
    }

    renderCtx.save();
    renderCtx.globalAlpha = alpha;
    renderCtx.font = `${fontSize}px ${config.fontFamily}`;
    renderCtx.textAlign = 'left';

    const textMetrics = renderCtx.measureText(textToDraw);
    const gradient = renderCtx.createLinearGradient(20, 0, 20 + textMetrics.width, 0);
    const numColors = 12;
    for (let i = 0; i < numColors; i++) {
        const hue = (Date.now() / 15 + i * (360 / numColors)) % 360;
        gradient.addColorStop(Math.max(0, Math.min(1, i / (numColors - 1))), `hsl(${hue}, 100%, 70%)`);
    }

    renderCtx.fillStyle = gradient;

    drawWithGlow(renderCtx, () => {
        renderCtx.fillText(textToDraw, 20, 70);
    }, '#ffffcc', true);

    renderCtx.restore();
}

function drawBackground(renderCtx) {
    let trailAlpha;
    if (gameState === 'playing' || gameState === 'paused') {
        const baseTrailAlpha = 0.15;
        const trailAlphaIncreasePerStage = 0.02;
        trailAlpha = Math.min(1.0, baseTrailAlpha + (stage - 1) * trailAlphaIncreasePerStage);
    } else {
        trailAlpha = 0.4;
    }
    renderCtx.fillStyle = `rgba(0,0,10,${trailAlpha})`;
    renderCtx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);

    const theme = themes[currentThemeIndex];
    drawGrid(renderCtx, theme.grid);
    
    // Êòü„ÅÆÊèèÁîª„Çí isEffectsEnabled „ÅÆÊù°‰ª∂ÂàÜÂ≤ê„ÅÆÂ§ñ„Å´Âá∫„Åô
    renderCtx.strokeStyle = '#808080';
    stars.forEach(s => {
        renderCtx.globalAlpha = s.speed / 100;
        renderCtx.lineWidth = s.width;
        renderCtx.beginPath();
        renderCtx.moveTo(s.x, s.y);
        renderCtx.lineTo(s.x, s.y - s.length);
        renderCtx.stroke();
    });
    renderCtx.globalAlpha = 1;
}

function drawTitleTextMorph(renderCtx, x, y, font, color) {
    const originalText = 'OUTBURST';
    const chars = "!?#$@%&<>*=/+ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    const now = Date.now();
    const cycle = 2000; // 2ÁßíÂë®Êúü
    const timeInCycle = now % cycle;
    let textToShow = '';

    // 0-999ms: ÈùôÁöÑË°®Á§∫
    if (timeInCycle < 1000) {
        textToShow = originalText;
    } else {
        // 1000-2000ms: „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
        const animProgress = (timeInCycle - 1000) / 1000; // 0.0 ~ 1.0

        if (animProgress > 0.8) {
            // ÊúÄÂæå„ÅÆ0.2Áßí„ÅßÂèéÊùü
            const convergeProgress = (animProgress - 0.8) / 0.2; // 0.0 ~ 1.0
            const len = 8 + Math.round(8 * (1 - convergeProgress)); // 16 -> 8
            for(let i = 0; i < len; i++) {
                textToShow += chars[Math.floor(Math.random() * chars.length)];
            }
        } else {
            // ÊúÄÂàù„ÅÆ0.8Áßí„ÅØÂÄç„ÅÆÈï∑„Åï
            const expandedLength = originalText.length * 2;
            for(let i = 0; i < expandedLength; i++) {
                textToShow += chars[Math.floor(Math.random() * chars.length)];
            }
        }
    }

    drawWithGlow(renderCtx, () => {
        renderCtx.font = font;
        renderCtx.fillStyle = color;
        renderCtx.fillText(textToShow, x, y);
    }, color);
}

function draw() {
    const renderCtx = offscreenCtx;
    const theme = themes[currentThemeIndex];

    drawBackground(renderCtx);

    if (gameState === 'playing' || gameState === 'paused' || gameState === 'title') {
        applyThemeStyles(theme);
    }
    
    // Draw Score Texts
    if (scoreTexts.length > 0) {
        renderCtx.save();
        renderCtx.textAlign = 'center';
        scoreTexts.forEach(st => {
            const fontSize = st.type === 'bonus' ? 14 : 10;
            renderCtx.font = `${fontSize}px ${config.fontFamily}`;
            const alpha = st.life / 60.0;
            const hue = (frameCount * 5 + st.x) % 360;
            const scoreColor = `hsla(${hue}, 100%, 70%, ${alpha})`;
            const glowColor = `hsla(${hue}, 100%, 70%, ${alpha / 2})`;

            renderCtx.globalAlpha = alpha;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = scoreColor;
                renderCtx.fillText(st.text, st.x, st.y);
            }, glowColor);
        });
        renderCtx.restore();
    }

    if (gameState === 'playing' || gameState === 'paused' || gameState === 'gameOver' || particles.length > 0 || comets.length > 0 || items.length > 0) {
        // Draw Particles
        particles.forEach(p => {
            const alpha = p.life / p.maxLife;
            renderCtx.globalAlpha = alpha;
            renderCtx.fillStyle = p.color;
            renderCtx.beginPath();
            renderCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            renderCtx.fill();
        });
        renderCtx.globalAlpha = 1;

        // Draw Items
        items.forEach(i => {
            const itemColor = i.type === 'special' ? `hsl(${(frameCount * 4) % 360}, 100%, 70%)` : '#00ff88';
            const itemPalette = { '1': '#ffffff', '2': itemColor };
            const pixelSize = 2;
            drawWithGlow(renderCtx, () => {
                drawPixelArt(renderCtx, ENERGY_ITEM_PIXEL_ART, i.x, i.y, pixelSize, itemPalette);
            }, itemColor, true);
        });

        // Draw Comets
        comets.forEach(c => {
            const cometBaseColor = c.isWay ? theme.player : theme.comet;
            const a = c.isGlazed ? '#ffffaa' : cometBaseColor;
            const o = '#ffffff';
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = a;
                renderCtx.beginPath();
                renderCtx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
                renderCtx.fill();
            }, a, true);
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = o;
                renderCtx.beginPath();
                renderCtx.arc(c.x, c.y, c.radius * 0.6, 0, Math.PI * 2);
                renderCtx.fill();
            }, o, true);
        });
        
        // Draw Monsters & Bullets (Standard Mode only)
        if (gameMode === 'STANDARD MODE') {
            monsters.forEach(m => {
                let art, palette, pixelSize;
                const hue1 = (frameCount * 2) % 360;
                if (m.type === 'ufo') {
                    art = UFO_PIXEL_ART_FINAL;
                    pixelSize = 4;
                    palette = { 
                        '1': `hsl(${hue1}, 80%, 70%)`, 
                        '2': `hsl(${hue1}, 50%, 40%)`,
                        '3': `hsl(${hue1}, 100%, 95%)`,
                        '4': `hsl(${(hue1 + 180) % 360}, 100%, 60%)`,
                    };
                } else if (m.type === 'looper') {
                    art = LOOPER_PIXEL_ART;
                    pixelSize = 6;
                    const color1 = '#9400D3'; // Purple
                    const color2 = '#FFFFFF';
                    const color3 = '#FFD700'; // Gold
                    palette = {
                        '1': color1,
                        '2': color2,
                        '3': color3,
                    };
                } else { // invader
                    art = INVADER_PIXEL_ART_GAMING;
                    pixelSize = 4;
                    const hue2 = (frameCount * 2 + 120) % 360;
                    const hue3 = (frameCount * 2 + 240) % 360;
                    palette = { 
                        '1': `hsl(${hue1}, 100%, 65%)`, 
                        '2': `hsl(${hue2}, 100%, 65%)`, 
                        '3': `hsl(${hue3}, 100%, 65%)`
                    };
                }
                drawWithGlow(renderCtx, () => {
                    drawPixelArt(renderCtx, art, m.x, m.y, pixelSize, palette);
                }, `hsl(${hue1}, 100%, 75%)`, true);
            });
            enemyBullets.forEach(eb => {
                const hue = (Date.now() / 10 + eb.y) % 360;
                const bulletColor = eb.isGlazed ? '#ffffaa' : `hsl(${hue}, 100%, 65%)`;
                renderCtx.fillStyle = bulletColor;
                drawWithGlow(renderCtx, () => {
                    renderCtx.beginPath();
                    renderCtx.arc(eb.x, eb.y, eb.radius, 0, Math.PI * 2);
                    renderCtx.fill();
                }, bulletColor);
            });
        }
    }
    
    // Draw Player Bullet (Both modes)
    if (playerBullet) {
        renderCtx.fillStyle = '#00ffff';
        drawWithGlow(renderCtx, () => {
            renderCtx.fillRect(playerBullet.x - playerBullet.width / 2, playerBullet.y, playerBullet.width, playerBullet.height);
        }, '#00ffff');
    }

    if (gameState === 'playing' || gameState === 'paused' || (gameState === 'gameOver' && gameOverReason === 'energy')) {
        // ‚ñº‚ñº‚ñº „Åì„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Çí‰øÆÊ≠£ ‚ñº‚ñº‚ñº
        const currentGlazeDistance = player.invincibleTimer > 0 ? config.glazeDistance * 1.5 : config.glazeDistance;
        const glazeRadius = player.radius + currentGlazeDistance;

        // „Ç∞„É¨„Ç§„Ç∫ÁØÑÂõ≤„ÅÆÊèèÁîªÔºàEFX OFF„Åß„ÇÇË°®Á§∫„Åï„Çå„Çã„Çà„ÅÜ„Å´Ôºâ
        renderCtx.save();
        if (isEffectsEnabled) {
            // EFX ON: ÂçäÈÄèÊòé„Åß„Éì„Éº„Éà„Å´ÈÄ£Âãï
            renderCtx.globalAlpha = 0.04 + visualBeat * 0.04;
            renderCtx.fillStyle = theme.player;
            renderCtx.beginPath();
            renderCtx.arc(player.x, player.y, glazeRadius, 0, Math.PI * 2);
            renderCtx.fill();
        } else {
            // EFX OFF: „Ç∑„É≥„Éó„É´„Å™Á∑ö„ÅßÊèèÁîª
            renderCtx.globalAlpha = 0.3;
            renderCtx.strokeStyle = theme.player;
            renderCtx.lineWidth = 1;
            renderCtx.beginPath();
            renderCtx.arc(player.x, player.y, glazeRadius, 0, Math.PI * 2);
            renderCtx.stroke();
        }
        renderCtx.restore();

        if (player.invincibleTimer > 0) {
            // ÁÑ°Êïµ„Ç∑„Éº„É´„Éâ„ÅÆÊèèÁîª
            renderCtx.save();
            if (player.invincibleTimer < 30 && frameCount % 10 < 5) {} else {
                const shieldRadius = config.playerVisualSize * 1.5;
                const shieldColor = '#FFFFFF';
                renderCtx.globalAlpha = 0.5 + Math.sin(frameCount * 0.2) * 0.2;
                renderCtx.lineWidth = 2;
                renderCtx.strokeStyle = shieldColor;
                drawWithGlow(renderCtx, () => {
                    renderCtx.beginPath();
                    renderCtx.arc(player.x, player.y, shieldRadius, 0, Math.PI * 2);
                    renderCtx.stroke();
                }, shieldColor);
            }
            renderCtx.restore();

            // ÁÑ°Êïµ„É°„Éº„Çø„Éº„ÅÆÊèèÁîª
            renderCtx.save();
            const meterRadius = glazeRadius + 5;
            const meterWidth = 3;
            const meterColor = `hsl(${(frameCount * 4) % 360}, 100%, 70%)`;
            const progress = player.invincibleTimer / player.maxInvincibleTimer;
            const startAngle = -Math.PI / 2;
            const endAngle = startAngle + (Math.PI * 2 * progress);
            renderCtx.lineWidth = meterWidth;
            renderCtx.strokeStyle = meterColor;
            if (player.invincibleTimer < 60 && frameCount % 10 < 5) {} else {
                drawWithGlow(renderCtx, () => {
                    renderCtx.beginPath();
                    renderCtx.arc(player.x, player.y, meterRadius, startAngle, endAngle, false);
                    renderCtx.stroke();
                }, meterColor);
            }
            renderCtx.restore();
        }

        if (gameState !== 'gameOver' || gameOverReason !== 'collision') {
            drawPlayer(renderCtx, theme.player);

            // „Éí„ÉÉ„Éà„Éú„ÉÉ„ÇØ„ÇπÔºàÂΩì„Åü„ÇäÂà§ÂÆöÔºâ„ÅÆË°®Á§∫
            renderCtx.save();
            renderCtx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // ÁôΩ„ÅÆÂçäÈÄèÊòé„ÅßÂ∏∏ÊôÇË°®Á§∫
            renderCtx.beginPath();
            renderCtx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            renderCtx.fill();
            renderCtx.restore();
        }
        // ‚ñ≤‚ñ≤‚ñ≤ ‰øÆÊ≠£„ÅØ„Åì„Åì„Åæ„Åß ‚ñ≤‚ñ≤‚ñ≤
    }

    // Draw UI
    drawWithGlow(renderCtx, () => {
        renderCtx.fillStyle = theme.ui;
        const mainFontSize = 20 + visualBeat * 2;
        const subFontSize = 18 + visualBeat * 2;
        renderCtx.font = `${mainFontSize}px ${config.fontFamily}`;
        renderCtx.textAlign = 'left';
        renderCtx.fillText(`SCORE: ${score}`, 20, 40);
        renderCtx.textAlign = 'center';
        renderCtx.fillText(formatTime(elapsedTime), config.canvasWidth / 2, 40);
        if (gameState === 'playing' || gameState === 'paused') {
            renderCtx.font = `${subFontSize}px ${config.fontFamily}`;
            renderCtx.fillText(`STAGE ${stage}`, config.canvasWidth / 2, config.canvasHeight - 20);
        }
    }, theme.ui, true);
    
    if (gameState === 'playing' || gameState === 'paused') {
    	const modeName = gameMode.replace(' MODE', '');
    	const modeFontSize = 20 + visualBeat * 2;
    	const modeColor = theme.ui;
    
    	renderCtx.font = `${modeFontSize}px ${config.fontFamily}`;
    	renderCtx.textAlign = 'right';
    
    	drawWithGlow(renderCtx, () => {
            renderCtx.fillStyle = modeColor;
            renderCtx.fillText(modeName, config.canvasWidth - 20, 40);
    	}, modeColor, true);
    }

    if (chainCount > 1 && player.invincibleTimer > 0) {
        drawChainComboText(renderCtx, chainCount, 1.0);
    }

    if ((gameState === 'playing' || gameState === 'paused') && gameMode !== 'STARTRAIL MODE') {
        const barW = 200, barH = 12, x = 20, y = config.canvasHeight - 35, r = 5;
        const energyRatio = Math.max(0, energy / config.energyTotal);
        const hue = energyRatio * 120;
        let energyColor = `hsl(${hue},100%,50%)`;

        if (lowEnergyWarningPlayed && frameCount % 10 < 5) {
            energyColor = '#FFFFFF';
        }

        renderCtx.strokeStyle = 'rgba(255,255,255,0.5)';
        renderCtx.lineWidth = 2;
        drawRoundRect(renderCtx, x, y, barW, barH, r);
        renderCtx.stroke();
        renderCtx.fillStyle = 'rgba(0,0,0,0.5)';
        drawRoundRect(renderCtx, x, y, barW, barH, r);
        renderCtx.fill();
        drawWithGlow(renderCtx, () => {
            renderCtx.fillStyle = energyColor;
            if (barW * energyRatio > 0) {
                renderCtx.beginPath();
                drawRoundRect(renderCtx, x, y, barW * energyRatio, barH, r);
                renderCtx.fill()
            }
        }, energyColor, true);

        if (player.invincibleTimer > 0) {
            const invincBarY = y + barH + 5;
            const invincBarH = 6;
            const invincRatio = player.invincibleTimer / player.maxInvincibleTimer;
            const invincColor = '#FFFFFF';
            renderCtx.strokeStyle = 'rgba(255,255,255,0.5)';
            renderCtx.lineWidth = 1;
            drawRoundRect(renderCtx, x, invincBarY, barW, invincBarH, r - 2);
            renderCtx.stroke();
            renderCtx.fillStyle = 'rgba(0,0,0,0.5)';
            drawRoundRect(renderCtx, x, invincBarY, barW, invincBarH, r - 2);
            renderCtx.fill();
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = invincColor;
                if (barW * invincRatio > 0) {
                    renderCtx.beginPath();
                    drawRoundRect(renderCtx, x, invincBarY, barW * invincRatio, invincBarH, r - 2);
                    renderCtx.fill()
                }
            }, invincColor, true);
        }
    }

    if (isInvincible) {
        let mutekiY = config.canvasHeight - 50;
        if (player.invincibleTimer > 0 && gameMode !== 'STARTRAIL MODE') {
            mutekiY = config.canvasHeight - 50 - 12 - 5 - 6;
        }
        const mutekiColor = `hsl(${(frameCount*3)%360},100%,70%)`;
        drawWithGlow(renderCtx, () => {
            renderCtx.fillStyle = mutekiColor;
            renderCtx.font = `16px ${config.fontFamily}`;
            renderCtx.textAlign = 'left';
            renderCtx.fillText('MUTEKI', 20, mutekiY);
        }, mutekiColor, true);
    }
    
    // Draw Effects
    effects.forEach(e => {
        if (e.type === 'stageClear' && gameState !== 'gameOver') {
            const l = e.life / e.maxLife;
            const a = Math.sin(l * Math.PI);
            renderCtx.globalAlpha = a;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = theme.ui;
                renderCtx.font = `32px ${config.fontFamily}`;
                renderCtx.textAlign = 'center';
                renderCtx.fillText(e.text, config.canvasWidth / 2, config.canvasHeight / 2);
            }, theme.ui, true);
            renderCtx.globalAlpha = 1;
        } else if (e.type === 'textMorph') {
            const lifeProgress = 1 - (e.life / e.maxLife);
            const chars = "!?#$ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            let displayText = "";
            const mainTextY = config.canvasHeight / 2 + 30;
            const subTextY = mainTextY + 25;
            const transitionStart = 0.25;
            const transitionEnd = 0.75;

            if (lifeProgress < transitionStart) {
                displayText = "INVINCIBLE!!";
            } else if (lifeProgress < transitionEnd) {
                const toText = "MUTEKI!!";
                const transitionProgress = (lifeProgress - transitionStart) / (transitionEnd - transitionStart);
                for (let i = 0; i < toText.length; i++) {
                    if (transitionProgress > (i / toText.length) + (Math.random() * 0.1)) {
                        displayText += toText[i];
                    } else {
                        displayText += chars[Math.floor(Math.random() * chars.length)];
                    }
                }
            } else {
                displayText = "MUTEKI!!";
            }
            
            renderCtx.save();
            renderCtx.textAlign = 'center';
            renderCtx.font = `24px ${config.fontFamily}`;
            const totalWidth = renderCtx.measureText(displayText).width;
            let currentX = config.canvasWidth / 2 - totalWidth / 2;

            for (let i = 0; i < displayText.length; i++) {
                const char = displayText[i];
                const charWidth = renderCtx.measureText(char).width;
                const hue = (frameCount * 5 + i * 25) % 360;
                const color = `hsl(${hue}, 100%, 70%)`;
                renderCtx.globalAlpha = 1;
                drawWithGlow(renderCtx, () => {
                    renderCtx.fillStyle = color;
                    renderCtx.fillText(char, currentX + charWidth / 2, mainTextY);
                }, color);
                currentX += charWidth;
            }

            renderCtx.font = `10px ${config.fontFamily}`;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = theme.ui;
                renderCtx.fillText("Bonus Points for Hitting a Comet!!", config.canvasWidth / 2, subTextY);
            }, theme.ui);
            renderCtx.restore();
        } else if (e.type === 'shockwave' && isEffectsEnabled) {
            const progress = 1 - e.life / e.maxLife;
            const radius = e.radius + progress * 300;
            const alpha = e.life / e.maxLife;
            renderCtx.save();
            renderCtx.globalAlpha = alpha * 0.8;
            renderCtx.strokeStyle = '#ffffff';
            renderCtx.lineWidth = 3 + (1 - alpha) * 5;
            renderCtx.beginPath();
            renderCtx.arc(e.x, e.y, radius, 0, Math.PI * 2);
            renderCtx.stroke();
            renderCtx.restore();
        } else if (e.type === 'comboFadeOut' && isEffectsEnabled) {
            drawChainComboText(renderCtx, e.count, e.life / e.maxLife);
        } else if (e.type === 'screenFlash' && isEffectsEnabled) {
            const alpha = e.life / e.maxLife;
            renderCtx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
            renderCtx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);
        } else if (e.type === 'energyGameOverFlash') {
            const progress = 1.0 - (e.life / e.maxLife);
            const alpha = Math.sin((1.0 - progress) * Math.PI) * 0.8;
            renderCtx.fillStyle = `rgba(224, 224, 224, ${alpha})`;
            renderCtx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);
        } else if (e.type === 'barLine' && isEffectsEnabled) {
            const progress = 1.0 - (e.life / e.maxLife);
            const y = config.canvasHeight * progress;
            const alpha = Math.sin((1.0 - progress) * Math.PI) * 0.3;
            renderCtx.save();
            renderCtx.globalAlpha = alpha;
            renderCtx.strokeStyle = theme.ui;
            renderCtx.lineWidth = 2;
            renderCtx.setLineDash([8, 8]);
            renderCtx.beginPath();
            renderCtx.moveTo(0, y);
            renderCtx.lineTo(config.canvasWidth, y);
            renderCtx.stroke();
            renderCtx.restore();
        }
    });

    // Draw Paused Screen
    if (gameState === 'paused') {
        renderCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        renderCtx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);
        
        const pauseMsg = 'PAUSED';
        const resumeKey = lastInputDevice === 'keyboard' ? 'P' : 'START';
        const quitMsg = `Press ${lastInputDevice === 'keyboard' ? 'Q' : 'Select'} to Title`;
        const resumeMsg = `Press ${resumeKey} to Resume`;
        
        renderCtx.font = `48px ${config.fontFamily}`;
        renderCtx.textAlign = 'center';
        
        const totalWidth = renderCtx.measureText(pauseMsg).width;
        let currentX = config.canvasWidth / 2 - totalWidth / 2;

        for (let i = 0; i < pauseMsg.length; i++) {
            const char = pauseMsg[i];
            const charWidth = renderCtx.measureText(char).width;
            const hue = (Date.now() / 15 + i * 30) % 360;
            const gamingColor = `hsl(${hue}, 100%, 70%)`;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = gamingColor;
                renderCtx.fillText(char, currentX + charWidth / 2, config.canvasHeight / 2 - 40);
            }, gamingColor);
            currentX += charWidth;
        }

        renderCtx.fillStyle = theme.ui;
        renderCtx.font = `20px ${config.fontFamily}`;
        drawWithGlow(renderCtx, () => {
            renderCtx.fillText(resumeMsg, config.canvasWidth / 2, config.canvasHeight / 2 + 30);
            renderCtx.fillText(quitMsg, config.canvasWidth / 2, config.canvasHeight / 2 + 60);
        }, theme.ui, true);

    } else if (gameState !== 'playing') {
        renderCtx.textAlign = 'center';
        if (gameState === 'title') {
            const titleColor = theme.player;
            const uiColor = theme.ui;

            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = titleColor;
                renderCtx.font = `60px ${config.fontFamily}`;
                renderCtx.fillText('COMET', config.canvasWidth / 2, config.canvasHeight / 2 - 120);
            }, titleColor);
            
            const outburstY = config.canvasHeight / 2 - 75;
            const outburstFont = `16px ${config.fontFamily}`;
            drawTitleTextMorph(renderCtx, config.canvasWidth / 2, outburstY, outburstFont, uiColor);

            // Draw Menu
            titleMenuItems.forEach((item, index) => {
                const y = config.canvasHeight / 2 + index * 40;
                if (index === titleMenuIndex) {
                    const selectorColor = `hsl(${(frameCount * 3) % 360}, 100%, 70%)`;
                    drawWithGlow(renderCtx, () => {
                        renderCtx.fillStyle = selectorColor;
                        renderCtx.font = `22px ${config.fontFamily}`;
                        renderCtx.fillText(`> ${item} <`, config.canvasWidth / 2, y);
                    }, selectorColor, true);
                } else {
                    renderCtx.fillStyle = '#cccccc';
                    renderCtx.font = `20px ${config.fontFamily}`;
                    renderCtx.fillText(item, config.canvasWidth / 2, y);
                }
            });
            
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = '#ffffff';
                renderCtx.font = `18px ${config.fontFamily}`;
                // ÂàùÂõûÊèèÁîªÊôÇ„Åæ„Åü„ÅØ„Çø„Ç§„Éû„Éº„ÅåÂàá„Çå„Åü„Å®„Åç„Å´„Éá„Éï„Ç©„É´„Éà„ÉÜ„Ç≠„Çπ„Éà„ÇíË®≠ÂÆö
                if (titleBottomText === "") {
                    titleBottomText = lastInputDevice === 'keyboard' ? 'Press Enter to Start' : 'Press Start Button to Start';
                }
                renderCtx.fillText(titleBottomText, config.canvasWidth / 2, config.canvasHeight / 2 + 160);
            }, '#ffffff');
            
            // High Score Display
            const highScoreY = config.canvasHeight / 2 + 220;
            const highScoreCycle = frameCount % 360; 
            if (highScoreCycle < 120) {
                 drawWithGlow(renderCtx, () => {
                    renderCtx.fillStyle = theme.ui;
                    renderCtx.font = `14px ${config.fontFamily}`;
                    renderCtx.fillText(`HI-SCORE (STANDARD): ${highScoreStandard}`, config.canvasWidth / 2, highScoreY);
                }, theme.ui);
            } else if (highScoreCycle < 240) {
                 drawWithGlow(renderCtx, () => {
                    renderCtx.fillStyle = theme.ui;
                    renderCtx.font = `14px ${config.fontFamily}`;
                    renderCtx.fillText(`HI-SCORE (JOURNEY): ${highScoreJourney}`, config.canvasWidth / 2, highScoreY);
                }, theme.ui);
            } else {
                 drawWithGlow(renderCtx, () => {
                    renderCtx.fillStyle = theme.ui;
                    renderCtx.font = `14px ${config.fontFamily}`;
                    renderCtx.fillText(`HI-SCORE (STARTRAIL): ${highScoreStartrail}`, config.canvasWidth / 2, highScoreY);
                }, theme.ui);
            }

        } else { // gameState === 'gameOver'
            renderCtx.textBaseline = 'middle';
            const gameOverColor = '#ff3333';
            const gameOverY = config.canvasHeight / 2 - 150;
            
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = gameOverColor;
                renderCtx.font = `60px ${config.fontFamily}`;
                renderCtx.fillText('GAME OVER', config.canvasWidth / 2, gameOverY);
            }, gameOverColor);

            if (newHighScoreAchieved) {
                const newRecordColor = `hsl(${(frameCount*3)%360},100%,70%)`;
                const newRecordY = gameOverY + 80;
                drawWithGlow(renderCtx, () => {
                    renderCtx.fillStyle = newRecordColor;
                    renderCtx.font = `30px ${config.fontFamily}`;
                    renderCtx.fillText('NEW RECORD!', config.canvasWidth / 2, newRecordY);
                }, newRecordColor);
            }
            
            const scoreY = config.canvasHeight / 2;
            let currentHighScore;
            switch(gameMode) {
                case 'STANDARD MODE': currentHighScore = highScoreStandard; break;
                case 'JOURNEY MODE': currentHighScore = highScoreJourney; break;
                case 'STARTRAIL MODE': currentHighScore = highScoreStartrail; break;
                default: currentHighScore = 0;
            }

            drawWithGlow(renderCtx, () => {
                renderCtx.font = `30px ${config.fontFamily}`;
                renderCtx.fillStyle = theme.ui;
                renderCtx.fillText(`SCORE: ${score}`, config.canvasWidth / 2, scoreY);
            }, theme.ui);
            drawWithGlow(renderCtx, () => {
                renderCtx.font = `20px ${config.fontFamily}`;
                renderCtx.fillStyle = theme.ui;
                renderCtx.fillText(`HI-SCORE: ${currentHighScore}`, config.canvasWidth / 2, scoreY + 50);
            }, theme.ui);
            
            let titleText, replayText;
            if (lastInputDevice === 'keyboard') {
                titleText = 'Press Q to Title';
                replayText = 'Press Enter to Replay';
            } else {
                titleText = 'Press Select Button to Title';
                replayText = 'Press Start Button to Replay';
            }
            const replayY = scoreY + 120;
            drawWithGlow(renderCtx, () => {
                renderCtx.font = `18px ${config.fontFamily}`;
                renderCtx.fillStyle = '#ffffff';
                renderCtx.fillText(replayText, config.canvasWidth / 2, replayY);
                renderCtx.fillText(titleText, config.canvasWidth / 2, replayY + 30);
            }, '#ffffff');

            renderCtx.textBaseline = 'alphabetic';
        }
    }

    if (gameState === 'gameOver' && gameOverReason === 'energy') {
        const progress = grayscaleAnimation.progress;
        const filterValue = `grayscale(${progress}) brightness(${1 - progress * 0.2})`;
        canvas.style.filter = filterValue;
        canvas.style.webkitFilter = filterValue;
    } else {
        if (canvas.style.filter !== 'none') {
            canvas.style.filter = 'none';
            canvas.style.webkitFilter = 'none';
        }
    }

    ctx.drawImage(offscreenCanvas, 0, 0);
    ctx.restore();

    if (gameState === 'playing' && player.invincibleTimer > 0) {
        if (player.invincibleTimer < 30 && frameCount % 10 < 5) {} else {
            const alpha = 0.05;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);
        }
    }
}

function gameLoop(timestamp) {
    update(timestamp);
    draw();
    requestAnimationFrame(gameLoop);
}

soundToggleButton.addEventListener('click', () => {
    if (!audioHandler.isInitialized) {
        audioHandler.initialize();
    }
    const isMuted = audioHandler.toggleMute();
    soundToggleButton.textContent = isMuted ? 'SOUND OFF' : 'SOUND ON';
});

effectsToggleButton.addEventListener('click', () => {
    isEffectsEnabled = !isEffectsEnabled;
    effectsToggleButton.textContent = isEffectsEnabled ? 'EFX ON' : 'EFX OFF';
});

function toggleFullScreen() {
    const e = document.getElementById('fullscreen-root');
    if (!document.fullscreenElement) {
        e.requestFullscreen().catch(err => {
            alert(`„Éï„É´„Çπ„ÇØ„É™„Éº„É≥„É¢„Éº„Éâ„Å´„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü: ${err.message}`);
        });
    } else {
        document.exitFullscreen();
    }
}

function updateScale() {
    const r = document.getElementById('fullscreen-root');
    const w = document.getElementById('game-wrapper');
    if (document.fullscreenElement === r) {
        const instructionHeight = document.getElementById('instructions-container').offsetHeight;
        const totalGameHeight = document.getElementById('gameCanvas').offsetHeight + instructionHeight;
        const margin = 20;
        const effectiveWidth = w.offsetWidth + margin;
        const effectiveHeight = totalGameHeight + margin;
        const scaleX = r.clientWidth / effectiveWidth;
        const scaleY = r.clientHeight / effectiveHeight;
        const scale = Math.min(scaleX, scaleY);
        w.style.setProperty('--scale-factor', scale);
    } else {
        w.style.removeProperty('--scale-factor');
    }
}

window.addEventListener('fullscreenchange', updateScale);
window.addEventListener('resize', updateScale);
init();
gameLoop();

</script>
</body>
</html>
