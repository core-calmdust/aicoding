<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript バックギャモン (最終版)</title>
    <style>
        :root { --checker-size: 36px; --point-width: 45px; --point-height: 190px; }
        body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: #263238; color: white; margin: 0; padding: 20px; }
        h1 { margin-bottom: 20px; font-weight: 300; font-size: 2.5em; color: #eceff1; text-align: center; }
        .container { display: flex; gap: 30px; align-items: flex-start; flex-wrap: wrap; justify-content: center; width: 100%; }
        .board-container { display: flex; padding: 15px; background-color: #37474F; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .board-layout { display: flex; flex-direction: column; background-color: #dec9a7; position: relative; }
        .board-half { display: flex; }
        .bar { width: 40px; background-color: #37474F; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 5px 0; }
        .bar h4 { margin: 5px 0; font-size: 14px; }
        .quadrant { display: flex; }
        .point { width: var(--point-width); height: var(--point-height); position: relative; display: flex; flex-direction: column; align-items: center; }
        .point::before { content: ''; position: absolute; width: 0; height: 0; z-index: 0; }
        .point.top-row { justify-content: flex-start; }
        .point.bottom-row { justify-content: flex-end; }
        .point.top-row::before { border-left: calc(var(--point-width) / 2) solid transparent; border-right: calc(var(--point-width) / 2) solid transparent; border-top-style: solid; border-top-width: var(--point-height); top: 0; }
        .point.bottom-row::before { border-left: calc(var(--point-width) / 2) solid transparent; border-right: calc(var(--point-width) / 2) solid transparent; border-bottom-style: solid; border-bottom-width: var(--point-height); bottom: 0; }
        .point.p-light::before { border-color: transparent transparent #e3d4b5 transparent; }
        .point.p-dark::before { border-color: transparent transparent #b08968 transparent; }
        .point.top-row.p-light::before { border-color: #e3d4b5 transparent transparent transparent; }
        .point.top-row.p-dark::before { border-color: #b08968 transparent transparent transparent; }
        .checker { width: var(--checker-size); height: var(--checker-size); border-radius: 50%; box-sizing: border-box; position: absolute; cursor: pointer; transition: transform 0.2s, outline 0.2s; box-shadow: 0 3px 5px rgba(0,0,0,0.4); z-index: 1; }
        .checker.red { background: radial-gradient(circle at 65% 35%, #e57373, #c62828); border: 2px solid #b71c1c; }
        .checker.black { background: radial-gradient(circle at 65% 35%, #616161, #212121); border: 2px solid #1a1a1a; }
        .point.top-row .checker { top: calc(var(--checker-size) * var(--i) * 0.75); }
        .point.bottom-row .checker { bottom: calc(var(--checker-size) * var(--i) * 0.75); }
        .bar .checker, .home-area .checker { position: relative; margin: 2px 0; }
        .home-area { width: 50px; background-color: #455A64; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; padding-top: 10px; }
        .home-area h4 { margin: 5px 0; writing-mode: vertical-rl; }
        .point-number-row { position: absolute; left: 0; right: 0; display: flex; pointer-events: none; }
        .point-number-row.top { top: -20px; }
        .point-number-row.bottom { bottom: -20px; }
        .point-number-quadrant { display: flex; flex-basis: 50%; justify-content: space-around; }
        .point-number { font-size: 12px; color: #eee; width: var(--point-width); text-align: center; }
        .selected { transform: scale(1.1); outline: 3px solid #03a9f4; outline-offset: 2px; }
        .point.valid-move::after, .home-area.valid-move::after { content:''; position: absolute; top:0; left:0; right:0; bottom:0; background:rgba(76, 175, 80, 0.5); cursor: pointer; z-index: 2;}
        .sidebar { display: flex; flex-direction: column; }
        .game-setup, .turn-controls, .game-info { background-color: #455A64; color: white; padding: 15px; border-radius: 8px; width: 220px; box-sizing: border-box; margin-bottom: 20px; }
        .turn-controls { margin-bottom: 0; }
        .game-setup button { width: 100%; padding: 8px; border-radius: 4px; border: none; background-color: #607D8B; color: white; cursor: pointer; }
        .game-setup select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; margin-bottom: 10px; }
        /* 先攻・後攻選択UIのスタイル */
        .player-color-selector { margin-top: 15px; margin-bottom: 15px; border-top: 1px solid #546E7A; padding-top: 15px; }
        .radio-group { display: flex; justify-content: space-around; }
        .radio-group label { display: flex; align-items: center; cursor: pointer; margin: 0; }
        .radio-group input { margin-right: 5px; }
        .game-info p, .turn-controls p { margin: 0 0 10px 0; font-size: 16px; display: flex; justify-content: space-between; align-items: center; }
        .turn-controls p { justify-content: center; gap: 8px; margin-bottom: 10px; }
        .turn-controls button { display: block; width: 100%; margin: 10px 0; padding: 10px; border-radius: 4px; border: none; font-size: 16px; cursor: pointer; }
        #roll-button { background-color: #f44336; color: white; }
        #undo-button { background-color: #FFC107; color: black; margin-top: 0; }
        .turn-controls button:disabled { background-color: #555; cursor: not-allowed; color: #999; }
        .dice-area { display: flex; justify-content: space-around; align-items: center; margin-bottom: 10px; height: 50px; }
        .die { width: 40px; height: 40px; background-color: white; color: black; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 24px; font-weight: bold; }
        #message-area { margin-top: 15px; font-size: 18px; font-weight: bold; color: #ffeb3b; height: 25px; text-align: center; }
    </style>
</head>
<body>
    <h1>JavaScript バックギャモン ver 2.0</h1>
    <div class="container">
        <div class="sidebar">
            <div class="game-setup">
                <label for="cpu-level">CPUレベル:</label>
                <select id="cpu-level">
                    <option value="1">入門</option><option value="2">初級</option><option value="3">中級</option><option value="4" selected>上級</option>
                    <option value="5">熟練</option><option value="6">達人</option><option value="7">師範</option>
                </select>
                <!-- ★★★ 先攻・後攻選択UIを追加 ★★★ -->
                <div class="player-color-selector">
                    <label>あなたの色:</label>
                    <div class="radio-group">
                        <label><input type="radio" name="player_color" value="red" checked> 先攻(赤)</label>
                        <label><input type="radio" name="player_color" value="black"> 後攻(黒)</label>
                    </div>
                </div>
                <button id="start-button">ゲーム開始 / リセット</button>
            </div>
            <div class="game-info">
                <p>ターン: <span id="current-turn"></span></p>
                <!-- ★★★ ラベル部分をspanで囲む ★★★ -->
                <p><span id="red-label">赤 (YOU)</span> バー:<span id="bar-red-score">0</span> / ゴール:<span id="borne-off-red-score">0</span></p>
                <p><span id="black-label">黒 (CPU)</span> バー:<span id="bar-black-score">0</span> / ゴール:<span id="borne-off-black-score">0</span></p>
            </div>
            <div class="turn-controls">
                <div class="dice-area"><div class="die" id="die1">?</div><div class="die" id="die2">?</div></div>
                <p>残りの手: <span id="moves-left-display">-</span></p>
                <button id="roll-button">サイコロを振る</button>
                <button id="undo-button">一手戻す</button>
                <div id="message-area">ゲームを開始してください</div>
            </div>
        </div>
        <div class="board-container">
            <div class="board-layout" id="main-board"></div>
            <div class="home-area" id="home-area"><h4>ゴール</h4></div>
        </div>
    </div>

    <script>
        const BOARD_POINTS = 24; const CHECKERS_PER_PLAYER = 15;
        // 定数PLAYER, CPUは廃止し、動的な変数playerColor, cpuColorを使用する
        const START_POS = [ {p:23,c:2,pl:'red'},{p:12,c:5,pl:'red'},{p:7,c:3,pl:'red'},{p:5,c:5,pl:'red'},{p:0,c:2,pl:'black'},{p:11,c:5,pl:'black'},{p:16,c:3,pl:'black'},{p:18,c:5,pl:'black'} ];
        const dom = { board: document.getElementById('main-board'), home: document.getElementById('home-area'), die1: document.getElementById('die1'), die2: document.getElementById('die2'), rollBtn: document.getElementById('roll-button'), startBtn: document.getElementById('start-button'), msg: document.getElementById('message-area'), turn: document.getElementById('current-turn'), barP: document.getElementById('bar-red-score'), borneP: document.getElementById('borne-off-red-score'), barC: document.getElementById('bar-black-score'), borneC: document.getElementById('borne-off-black-score'), level: document.getElementById('cpu-level'), undoBtn: document.getElementById('undo-button'), movesLeft: document.getElementById('moves-left-display'), redLabel: document.getElementById('red-label'), blackLabel: document.getElementById('black-label') };
        let state;

        async function initGame() {
            const playerColor = document.querySelector('input[name="player_color"]:checked').value;
            const cpuColor = playerColor === 'red' ? 'black' : 'red';
            
            state = { board: Array(BOARD_POINTS).fill(null).map(() => ({ player: null, count: 0 })), bar: { [playerColor]: 0, [cpuColor]: 0 }, borneOff: { [playerColor]: 0, [cpuColor]: 0 }, dice: [], movesLeft: [], currentPlayer: 'red', turnState: 'ROLLING', selectedPoint: null, gameOver: false, cpuLevel: parseInt(dom.level.value, 10), turnStartState: null, playerColor: playerColor, cpuColor: cpuColor };
            START_POS.forEach(pos => state.board[pos.p] = { player: pos.pl, count: pos.c });
            
            dom.rollBtn.disabled = false; dom.undoBtn.disabled = true;
            renderAll(); // 先に描画
            
            if (state.currentPlayer === state.cpuColor) {
                dom.msg.textContent = 'CPUのターンです。';
                setTimeout(cpuTurn, 1000);
            } else {
                dom.msg.textContent = 'あなたの番です。サイコロを振ってください。';
            }
        }
        
        function updateInfo() {
            dom.turn.textContent = state.currentPlayer === state.playerColor ? "あなたのターン" : "CPUのターン";
            dom.redLabel.textContent = state.playerColor === 'red' ? '赤 (あなた)' : '赤 (CPU)';
            dom.blackLabel.textContent = state.playerColor === 'black' ? '黒 (あなた)' : '黒 (CPU)';
            dom.barP.textContent = state.bar[state.playerColor]; dom.borneP.textContent = state.borneOff[state.playerColor];
            dom.barC.textContent = state.bar[state.cpuColor]; dom.borneC.textContent = state.borneOff[state.cpuColor];
            dom.die1.textContent = state.dice[0] || '?'; dom.die2.textContent = state.dice[1] || '?';
            if (state.currentPlayer === state.playerColor && state.turnState === 'MOVING') { dom.movesLeft.textContent = state.movesLeft.length > 0 ? state.movesLeft.join(', ') : 'なし'; } else { dom.movesLeft.textContent = '-'; }
        }

        async function onRollClick() {
            if (state.turnState !== 'ROLLING' || state.currentPlayer !== state.playerColor) return;
            dom.rollBtn.disabled = true; state.turnState = 'ANIMATING';
            /* ... アニメーションロジック (変更なし) ... */
            await new Promise(r => setTimeout(r, 800));
            state.dice = [Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)];
            state.movesLeft = (state.dice[0] === state.dice[1]) ? Array(4).fill(state.dice[0]) : state.dice.slice();
            state.turnState = 'MOVING'; dom.msg.textContent = '駒を動かしてください。';
            state.turnStartState = { board: JSON.parse(JSON.stringify(state.board)), bar: { ...state.bar }, movesLeft: [...state.movesLeft] };
            if (generateAllMoveSequences(state.board, state.bar, state.playerColor, state.movesLeft).length === 0) { dom.msg.textContent = '動かせる手がありません。'; setTimeout(switchTurn, 1500); }
            renderAll();
        }

        function handlePlayerAction(target) {
            if (state.turnState !== 'MOVING' || state.currentPlayer !== state.playerColor) return;
            const sequences = generateAllMoveSequences(state.board, state.bar, state.playerColor, state.movesLeft);
            if (state.selectedPoint !== null) {
                const firstMove = sequences.flatMap(s => s.moves).find(m => m.from === state.selectedPoint && m.to === target);
                if (firstMove) {
                    executeMove(state, firstMove); dom.undoBtn.disabled = false;
                    const isTurnOver = state.movesLeft.length === 0 || generateAllMoveSequences(state.board, state.bar, state.playerColor, state.movesLeft).length === 0;
                    if (!state.gameOver && isTurnOver) setTimeout(switchTurn, 500);
                }
                state.selectedPoint = null;
            } else {
                if (sequences.flatMap(s => s.moves).some(m => m.from === target)) state.selectedPoint = target;
            }
            renderAll();
        }

        function switchTurn() {
            if (state.gameOver) return;
            state.currentPlayer = state.currentPlayer === 'red' ? 'black' : 'red';
            state.turnState = 'ROLLING'; state.dice = []; state.movesLeft = []; state.selectedPoint = null; state.turnStartState = null; dom.undoBtn.disabled = true;
            if (state.currentPlayer === state.playerColor) {
                dom.rollBtn.disabled = false; dom.msg.textContent = 'あなたの番です。サイコロを振ってください。';
            } else {
                dom.rollBtn.disabled = true; dom.msg.textContent = 'CPUのターンです。'; setTimeout(cpuTurn, 1000);
            }
            renderAll();
        }

        async function cpuTurn() {
            /* ... アニメーションロジック (変更なし) ... */
            await new Promise(r => setTimeout(r, 800));
            state.dice = [Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)];
            state.movesLeft = (state.dice[0] === state.dice[1]) ? Array(4).fill(state.dice[0]) : state.dice.slice();
            renderAll(); await new Promise(r => setTimeout(r, 600));
            const bestSequence = findBestCpuMoveSequence();
            if (bestSequence && bestSequence.moves.length > 0) {
                for (const move of bestSequence.moves) { executeMove(state, move); renderAll(); await new Promise(r => setTimeout(r, 800)); }
            } else { dom.msg.textContent = 'CPUは動けません。'; await new Promise(r => setTimeout(r, 1500)); }
            if (!state.gameOver) switchTurn();
        }

        function findBestCpuMoveSequence() {
            const sequences = generateAllMoveSequences(state.board, state.bar, state.cpuColor, state.movesLeft);
            if (sequences.length === 0) return null; let bestSeq = sequences[0]; let bestScore = -Infinity;
            for (const seq of sequences) {
                const score = evaluateBoard(seq.finalBoard, seq.finalBar) * (state.cpuLevel / 2) + seq.hits * 5 * state.cpuLevel + seq.borneOff * 2 * state.cpuLevel;
                if (score > bestScore) { bestScore = score; bestSeq = seq; }
            }
            return bestSeq;
        }

        function evaluateBoard(board, bar) {
            let cpuPipCount = 0, playerPipCount = 0;
            for(let i=0; i<BOARD_POINTS; i++) {
                if(board[i].player === state.cpuColor) cpuPipCount += (state.cpuColor === 'black' ? (i + 1) : (24 - i)) * board[i].count;
                else if(board[i].player === state.playerColor) playerPipCount += (state.playerColor === 'black' ? (i + 1) : (24 - i)) * board[i].count;
            }
            cpuPipCount += bar[state.cpuColor] * 25; playerPipCount += bar[state.playerColor] * 25;
            return playerPipCount - cpuPipCount; // CPUは差を最大化したい(相手のpipを増やし、自分のを減らす)
        }

        function generateSingleMoves(board, bar, player, uniqueDice) {
            let moves = []; const opponent = player === 'red' ? 'black' : 'red';
            if (bar[player] > 0) {
                for (const die of uniqueDice) {
                    const entryPoint = player === 'red' ? 24 - die : die - 1;
                    const target = board[entryPoint];
                    if (target.player === player || target.count <= 1) moves.push({ from: 'bar', to: entryPoint, die, isHit: target.player === opponent });
                }
                return moves;
            }
            const canBearOff = canPlayerBearOff(board, player, bar);
            for(let i=0; i<BOARD_POINTS; i++) {
                if(board[i].player === player) {
                    for (const die of uniqueDice) {
                        const toIndex = player === 'red' ? i - die : i + die;
                        if (canBearOff) {
                            const homePos = player === 'red' ? i + 1 : 24 - i;
                            if (homePos <= die && (homePos === die || findHighestCheckerInHome(board, player) === i)) { moves.push({ from: i, to: 'home', die, isHit: false}); continue; }
                        }
                        if(toIndex >= 0 && toIndex < BOARD_POINTS) { const target = board[toIndex]; if(target.player === player || target.count <= 1) moves.push({ from: i, to: toIndex, die, isHit: target.player === opponent }); }
                    }
                }
            }
            return moves;
        }

        function canPlayerBearOff(board, player, bar) {
            if (bar[player] > 0) return false;
            let totalCount = state.borneOff[player];
            const homeRange = player === 'red' ? {start: 0, end: 5} : {start: 18, end: 23};
            for(let i=0; i<BOARD_POINTS; i++) {
                if(board[i].player === player) {
                    if (i < homeRange.start || i > homeRange.end) return false;
                    totalCount += board[i].count;
                }
            }
            return totalCount === CHECKERS_PER_PLAYER;
        }

        function findHighestCheckerInHome(board, player) {
            if(player === 'red') { for(let i = 5; i >= 0; i--) if(board[i].player === player) return i; }
            else { for(let i = 18; i <= 23; i++) if(board[i].player === player) return i; }
            return -1;
        }
        
        // --- 以下の関数は前回の安定版から変更ありません ---
        function onUndoClick() { if (!state.turnStartState || state.currentPlayer !== state.playerColor || state.turnState !== 'MOVING') return; state.board = JSON.parse(JSON.stringify(state.turnStartState.board)); state.bar = { ...state.turnStartState.bar }; state.movesLeft = [...state.turnStartState.movesLeft]; state.selectedPoint = null; dom.undoBtn.disabled = true; dom.msg.textContent = '手を元に戻しました。'; renderAll(); }
        function executeMove(gameState, move) { const { from, to, die, isHit } = move; const player = gameState.currentPlayer; if (from === 'bar') gameState.bar[player]--; else { gameState.board[from].count--; if (gameState.board[from].count === 0) gameState.board[from].player = null; } if (to === 'home') gameState.borneOff[player]++; else { const opponent = player === 'red' ? 'black' : 'red'; if (isHit) { gameState.board[to] = { player, count: 1 }; gameState.bar[opponent]++; } else { gameState.board[to].player = player; gameState.board[to].count++; } } const dieIndex = gameState.movesLeft.findIndex(d => d === die); if (dieIndex > -1) gameState.movesLeft.splice(dieIndex, 1); if (gameState.borneOff[player] === CHECKERS_PER_PLAYER) endGame(); }
        function endGame() { state.gameOver = true; dom.msg.textContent = `${state.currentPlayer === state.playerColor ? "あなた" : "CPU"} の勝ちです！`; dom.rollBtn.disabled = true; dom.undoBtn.disabled = true; }
        function generateAllMoveSequences(initialBoard, initialBar, player, dice) { const sequences = []; function find(currentBoard, currentBar, diceLeft, movesSoFar) { const possibleMoves = generateSingleMoves(currentBoard, currentBar, player, [...new Set(diceLeft)]); if (diceLeft.length === 0 || possibleMoves.length === 0) { if (movesSoFar.length > 0 || dice.length === 0) sequences.push({ moves: movesSoFar, finalBoard: currentBoard, finalBar: currentBar, hits: movesSoFar.filter(m => m.isHit).length, borneOff: movesSoFar.filter(m => m.to === 'home').length }); return; } for (const move of possibleMoves) { const nextBoard = JSON.parse(JSON.stringify(currentBoard)); const nextBar = { ...currentBar }; const opponent = player === 'red' ? 'black' : 'red'; if (move.from === 'bar') { nextBar[player]--; } else { nextBoard[move.from].count--; if (nextBoard[move.from].count === 0) nextBoard[move.from].player = null; } if (move.to === 'home') {} else { if (move.isHit) { nextBoard[move.to] = { player, count: 1 }; nextBar[opponent]++; } else { nextBoard[move.to].player = player; nextBoard[move.to].count++; } } const nextDice = [...diceLeft]; nextDice.splice(nextDice.findIndex(d => d === move.die), 1); find(nextBoard, nextBar, nextDice, [...movesSoFar, move]); } } find(JSON.parse(JSON.stringify(initialBoard)), { ...initialBar }, dice, []); if (sequences.length === 0 && generateSingleMoves(initialBoard, initialBar, player, [...new Set(dice)]).length === 0) return []; return sequences.sort((a,b) => b.moves.length - a.moves.length).filter((s, i, arr) => s.moves.length === arr[0].moves.length); }
        function highlightValidMoves() { document.querySelectorAll('.point.valid-move, .home-area.valid-move').forEach(p => p.classList.remove('valid-move')); if (state.currentPlayer !== state.playerColor || state.turnState !== 'MOVING') return; const sequences = generateAllMoveSequences(state.board, state.bar, state.playerColor, state.movesLeft); const allPossibleFirstMoves = [...new Map(sequences.flatMap(s => s.moves[0] ? [s.moves[0]] : []).map(m => [`${m.from}-${m.to}`, m])).values()]; if (state.selectedPoint !== null) { allPossibleFirstMoves.filter(m => m.from === state.selectedPoint).forEach(m => { if (m.to === 'home') dom.home.classList.add('valid-move'); else document.querySelector(`.point[data-index='${m.to}']`)?.classList.add('valid-move'); }); } }
        
        dom.startBtn.addEventListener('click', initGame);
        dom.rollBtn.addEventListener('click', onRollClick);
        dom.undoBtn.addEventListener('click', onUndoClick);
        dom.home.addEventListener('click', () => handlePlayerAction('home'));
        initGame();
    </script>
</body>
</html>
