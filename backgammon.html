<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript バックギャモン</title>
    <style>
        :root { --checker-size: 36px; --point-width: 45px; --point-height: 190px; }
        body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: #263238; color: white; margin: 0; padding: 20px; }
        h1 { margin-bottom: 20px; font-weight: 300; font-size: 2.5em; color: #eceff1; text-align: center; }
        .container { display: flex; gap: 30px; align-items: flex-start; flex-wrap: wrap; justify-content: center; width: 100%; }
        .board-container { display: flex; padding: 15px; background-color: #37474F; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .board-layout { display: flex; flex-direction: column; background-color: #dec9a7; position: relative; }
        .board-half { display: flex; }
        .bar { width: 40px; background-color: #37474F; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 5px 0; }
        .bar h4 { margin: 5px 0; font-size: 14px; }
        .quadrant { display: flex; }
        .point { width: var(--point-width); height: var(--point-height); position: relative; display: flex; flex-direction: column; align-items: center; }
        .point::before { content: ''; position: absolute; width: 0; height: 0; z-index: 0; }
        .point.top-row { justify-content: flex-start; }
        .point.bottom-row { justify-content: flex-end; }
        .point.top-row::before { border-left: calc(var(--point-width) / 2) solid transparent; border-right: calc(var(--point-width) / 2) solid transparent; border-top-style: solid; border-top-width: var(--point-height); top: 0; }
        .point.bottom-row::before { border-left: calc(var(--point-width) / 2) solid transparent; border-right: calc(var(--point-width) / 2) solid transparent; border-bottom-style: solid; border-bottom-width: var(--point-height); bottom: 0; }
        .point.p-light::before { border-color: transparent transparent #e3d4b5 transparent; }
        .point.p-dark::before { border-color: transparent transparent #b08968 transparent; }
        .point.top-row.p-light::before { border-color: #e3d4b5 transparent transparent transparent; }
        .point.top-row.p-dark::before { border-color: #b08968 transparent transparent transparent; }
        .checker { width: var(--checker-size); height: var(--checker-size); border-radius: 50%; box-sizing: border-box; position: absolute; cursor: pointer; transition: transform 0.2s, outline 0.2s; box-shadow: 0 3px 5px rgba(0,0,0,0.4); z-index: 1; }
        .checker.red { background: radial-gradient(circle at 65% 35%, #e57373, #c62828); border: 2px solid #b71c1c; }
        .checker.black { background: radial-gradient(circle at 65% 35%, #616161, #212121); border: 2px solid #1a1a1a; }
        .point.top-row .checker { top: calc(var(--checker-size) * var(--i) * 0.75); }
        .point.bottom-row .checker { bottom: calc(var(--checker-size) * var(--i) * 0.75); }
        .bar .checker, .home-area .checker { position: relative; margin: 2px 0; }
        .home-area { width: 50px; background-color: #455A64; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; padding-top: 10px; }
        .home-area h4 { margin: 5px 0; writing-mode: vertical-rl; }
        .point-number-row { position: absolute; left: 0; right: 0; display: flex; pointer-events: none; }
        .point-number-row.top { top: -20px; }
        .point-number-row.bottom { bottom: -20px; }
        .point-number-quadrant { display: flex; flex-basis: 50%; justify-content: space-around; }
        .point-number { font-size: 12px; color: #eee; width: var(--point-width); text-align: center; }
        .selected { transform: scale(1.1); outline: 3px solid #03a9f4; outline-offset: 2px; }
        .point.valid-move::after, .home-area.valid-move::after { content:''; position: absolute; top:0; left:0; right:0; bottom:0; background:rgba(76, 175, 80, 0.5); cursor: pointer; z-index: 2;}
        .sidebar { display: flex; flex-direction: column; }
        .game-setup, .turn-controls, .game-info { background-color: #455A64; color: white; padding: 15px; border-radius: 8px; width: 220px; box-sizing: border-box; margin-bottom: 20px; }
        .turn-controls { margin-bottom: 0; }
        .game-setup button { width: 100%; padding: 8px; border-radius: 4px; border: none; background-color: #607D8B; color: white; cursor: pointer; }
        .game-setup select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; margin-bottom: 10px; }
        .game-info p, .turn-controls p { margin: 0 0 10px 0; font-size: 16px; display: flex; justify-content: space-between; align-items: center; }
        .turn-controls p { justify-content: center; gap: 8px; margin-bottom: 10px; }
        .turn-controls button { display: block; width: 100%; margin: 10px 0; padding: 10px; border-radius: 4px; border: none; font-size: 16px; cursor: pointer; }
        #roll-button { background-color: #f44336; color: white; }
        #undo-button { background-color: #FFC107; color: black; margin-top: 0; }
        .turn-controls button:disabled { background-color: #555; cursor: not-allowed; color: #999; }
        .dice-area { display: flex; justify-content: space-around; align-items: center; margin-bottom: 10px; height: 50px; }
        .die { width: 40px; height: 40px; background-color: white; color: black; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 24px; font-weight: bold; }
        #message-area { margin-top: 15px; font-size: 18px; font-weight: bold; color: #ffeb3b; height: 25px; text-align: center; }
    </style>
</head>
<body>
    <h1>JavaScript バックギャモン</h1>
    <div class="container">
        <div class="sidebar">
            <div class="game-setup">
                <label for="cpu-level">CPUレベル:</label>
                <select id="cpu-level">
                    <option value="1">入門</option><option value="2">初級</option><option value="3">中級</option><option value="4" selected>上級</option>
                    <option value="5">熟練</option><option value="6">達人</option><option value="7">師範</option>
                </select>
                <button id="start-button">ゲーム開始 / リセット</button>
            </div>
            <div class="game-info">
                <p>ターン: <span id="current-turn"></span></p>
                <p>赤(YOU) バー:<span id="bar-red-score">0</span> / ゴール:<span id="borne-off-red-score">0</span></p>
                <p>黒(CPU) バー:<span id="bar-black-score">0</span> / ゴール:<span id="borne-off-black-score">0</span></p>
            </div>
            <div class="turn-controls">
                <div class="dice-area"><div class="die" id="die1">?</div><div class="die" id="die2">?</div></div>
                <p>残りの手: <span id="moves-left-display">-</span></p>
                <button id="roll-button">サイコロを振る</button>
                <button id="undo-button">一手戻す</button>
                <div id="message-area">ゲームを開始してください</div>
            </div>
        </div>
        <div class="board-container">
            <div class="board-layout" id="main-board"></div>
            <div class="home-area" id="home-area"><h4>ゴール</h4></div>
        </div>
    </div>

    <script>
        // --- 定数 ---
        const BOARD_POINTS = 24;
        const CHECKERS_PER_PLAYER = 15;
        const PLAYER = 'red', CPU = 'black';
        const START_POS = [ {p:23,c:2,pl:PLAYER},{p:12,c:5,pl:PLAYER},{p:7,c:3,pl:PLAYER},{p:5,c:5,pl:PLAYER},{p:0,c:2,pl:CPU},{p:11,c:5,pl:CPU},{p:16,c:3,pl:CPU},{p:18,c:5,pl:CPU} ];
        
        /**
         * バックギャモンゲームのメインクラス
         * ゲームの状態(state)とロジック(メソッド)を管理する
         */
        class BackgammonGame {
            constructor(domElements) {
                this.dom = domElements;
                this.state = {};
                this.initGame();
                this.attachEventListeners();
            }

            // --- ゲーム進行 ---
            
            /**
             * ゲームを初期化またはリセットする
             */
            initGame() {
                this.state = {
                    board: Array(BOARD_POINTS).fill(null).map(() => ({ player: null, count: 0 })),
                    bar: { [PLAYER]: 0, [CPU]: 0 },
                    borneOff: { [PLAYER]: 0, [CPU]: 0 },
                    dice: [],
                    movesLeft: [],
                    currentPlayer: PLAYER,
                    turnState: 'ROLLING', // ROLLING, ANIMATING, MOVING
                    selectedPoint: null,
                    gameOver: false,
                    cpuLevel: parseInt(this.dom.level.value, 10),
                    turnStartState: null
                };
                START_POS.forEach(pos => this.state.board[pos.p] = { player: pos.pl, count: pos.c });
                
                this.dom.rollBtn.disabled = false;
                this.dom.undoBtn.disabled = true;
                this.dom.msg.textContent = 'あなたの番です。サイコロを振ってください。';
                this.renderAll();
            }
            
            /**
             * プレイヤーとCPUのターンを切り替える
             */
            switchTurn() {
                if (this.state.gameOver) return;
                this.state.currentPlayer = this.state.currentPlayer === PLAYER ? CPU : PLAYER;
                this.state.turnState = 'ROLLING';
                this.state.dice = [];
                this.state.movesLeft = [];
                this.state.selectedPoint = null;
                this.state.turnStartState = null;
                this.dom.undoBtn.disabled = true;

                if (this.state.currentPlayer === PLAYER) {
                    this.dom.rollBtn.disabled = false;
                    this.dom.msg.textContent = 'あなたの番です。サイコロを振ってください。';
                } else {
                    this.dom.rollBtn.disabled = true;
                    this.dom.msg.textContent = 'CPUのターンです。';
                    setTimeout(() => this.cpuTurn(), 1000);
                }
                this.renderAll();
            }

            /**
             * ゲームを終了させ、勝敗メッセージを表示する
             */
            endGame() {
                this.state.gameOver = true;
                this.dom.msg.textContent = `${this.state.currentPlayer === PLAYER ? "あなた" : "CPU"} の勝ちです！`;
                this.dom.rollBtn.disabled = true;
                this.dom.undoBtn.disabled = true;
            }

            // --- プレイヤー操作 ---
            
            /**
             * 「サイコロを振る」ボタンの処理
             */
            async handleRoll() {
                if (this.state.turnState !== 'ROLLING' || this.state.currentPlayer !== PLAYER) return;
                this.dom.rollBtn.disabled = true;
                this.state.turnState = 'ANIMATING';
                
                await this.showDiceAnimation();

                this.state.dice = [Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)];
                this.state.movesLeft = (this.state.dice[0] === this.state.dice[1]) ? Array(4).fill(this.state.dice[0]) : this.state.dice.slice();
                this.state.turnState = 'MOVING';
                this.dom.msg.textContent = '駒を動かしてください。';
                
                // Undo用にターン開始時の状態を保存
                this.state.turnStartState = { board: JSON.parse(JSON.stringify(this.state.board)), bar: { ...this.state.bar }, movesLeft: [...this.state.movesLeft] };
                
                if (this.rules.generateAllMoveSequences(this.state.board, this.state.bar, PLAYER, this.state.movesLeft).length === 0) {
                    this.dom.msg.textContent = '動かせる手がありません。';
                    setTimeout(() => this.switchTurn(), 1500);
                }
                this.renderAll();
            }
            
            /**
             * 「一手戻す」ボタンの処理
             */
            handleUndo() {
                if (!this.state.turnStartState || this.state.currentPlayer !== PLAYER || this.state.turnState !== 'MOVING') return;
                this.state.board = JSON.parse(JSON.stringify(this.state.turnStartState.board));
                this.state.bar = { ...this.state.turnStartState.bar };
                this.state.movesLeft = [...this.state.turnStartState.movesLeft];
                this.state.selectedPoint = null;
                this.dom.undoBtn.disabled = true;
                this.dom.msg.textContent = '手を元に戻しました。';
                this.renderAll();
            }
            
            /**
             * プレイヤーのクリック操作(ポイント、駒、バー)を処理する
             * @param {number|string} target - クリックされた対象 (ポイントのインデックスまたは'bar','home')
             */
            handlePlayerAction(target) {
                if (this.state.turnState !== 'MOVING' || this.state.currentPlayer !== PLAYER) return;
                const sequences = this.rules.generateAllMoveSequences(this.state.board, this.state.bar, PLAYER, this.state.movesLeft);
                
                if (this.state.selectedPoint !== null) {
                    const firstMove = sequences.flatMap(s => s.moves).find(m => m.from === this.state.selectedPoint && m.to === target);
                    if (firstMove) {
                        this.rules.executeMove(this.state, firstMove);
                        this.dom.undoBtn.disabled = false;
                        const isTurnOver = this.state.movesLeft.length === 0 || this.rules.generateAllMoveSequences(this.state.board, this.state.bar, PLAYER, this.state.movesLeft).length === 0;
                        if (!this.state.gameOver && isTurnOver) setTimeout(() => this.switchTurn(), 500);
                    }
                    this.state.selectedPoint = null;
                } else {
                    if (sequences.flatMap(s => s.moves).some(m => m.from === target)) {
                        this.state.selectedPoint = target;
                    }
                }
                this.renderAll();
            }

            // --- AIロジック ---

            /**
             * CPUのターンを実行する
             */
            async cpuTurn() {
                this.dom.rollBtn.disabled = true; this.state.turnState = 'ANIMATING';
                await this.showDiceAnimation();
                
                this.state.dice = [Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)];
                this.state.movesLeft = (this.state.dice[0] === this.state.dice[1]) ? Array(4).fill(this.state.dice[0]) : this.state.dice.slice();
                this.renderAll();
                await new Promise(r => setTimeout(r, 600));
                
                const bestSequence = this.ai.findBestCpuMoveSequence();
                if (bestSequence && bestSequence.moves.length > 0) {
                    for (const move of bestSequence.moves) {
                        this.rules.executeMove(this.state, move); this.renderAll();
                        await new Promise(r => setTimeout(r, 800));
                    }
                } else {
                    this.dom.msg.textContent = 'CPUは動けません。';
                    await new Promise(r => setTimeout(r, 1500));
                }
                if (!this.state.gameOver) this.switchTurn();
            }

            // --- イベントリスナー設定 ---
            
            attachEventListeners() {
                this.dom.startBtn.addEventListener('click', () => this.initGame());
                this.dom.rollBtn.addEventListener('click', () => this.handleRoll());
                this.dom.undoBtn.addEventListener('click', () => this.handleUndo());
                this.dom.home.addEventListener('click', () => this.handlePlayerAction('home'));
            }

            // --- 描画とUI更新 ---
            renderAll = () => renderAll(this.state, this.dom, (target) => this.handlePlayerAction(target));
            showDiceAnimation = () => showDiceAnimation(this.dom);
        }

        // --- UI / 描画ロジック (クラス外の純粋な関数として定義) ---

        function renderAll(state, dom, handlePlayerAction) {
            dom.board.innerHTML = ''; dom.home.innerHTML = '<h4>ゴール</h4>';
            const topHalf = document.createElement('div'); topHalf.className = 'board-half';
            const bottomHalf = document.createElement('div'); bottomHalf.className = 'board-half';
            const barEl = document.createElement('div'); barEl.className = 'bar'; barEl.id = 'bar'; barEl.innerHTML = '<h4>バー</h4>';
            barEl.addEventListener('click', () => handlePlayerAction('bar'));
            const quadrants = Array(4).fill(null).map(() => document.createElement('div'));
            quadrants.forEach(q => q.className = 'quadrant');
            for (let i = 12; i <= 17; i++) quadrants[0].appendChild(createPointEl(i, state, handlePlayerAction));
            for (let i = 18; i <= 23; i++) quadrants[1].appendChild(createPointEl(i, state, handlePlayerAction));
            for (let i = 11; i >= 6; i--) quadrants[2].appendChild(createPointEl(i, state, handlePlayerAction));
            for (let i = 5; i >= 0; i--) quadrants[3].appendChild(createPointEl(i, state, handlePlayerAction));
            topHalf.append(quadrants[0], quadrants[1]);
            bottomHalf.append(quadrants[2], quadrants[3]);
            dom.board.append(createPointNumberRow('top'), topHalf, barEl, bottomHalf, createPointNumberRow('bottom'));
            for (const player of [PLAYER, CPU]) {
                for(let i=0; i<state.bar[player]; i++) barEl.appendChild(createChecker(player, 'bar', handlePlayerAction));
                for(let i=0; i<state.borneOff[player]; i++) dom.home.appendChild(createChecker(player, 'home', handlePlayerAction));
            }
            updateInfo(state, dom);
            highlightValidMoves(state, dom);
        }
        function createPointEl(index, state, handlePlayerAction) { const point = document.createElement('div'); point.className = `point ${(index < 12) ? 'bottom-row' : 'top-row'} ${(index % 2 !== (index < 12 ? 1 : 0)) ? 'p-dark' : 'p-light'}`; point.dataset.index = index; point.addEventListener('click', () => handlePlayerAction(index)); if (state.board[index].count > 0) { for (let j = 0; j < state.board[index].count; j++) { const checker = createChecker(state.board[index].player, index, handlePlayerAction); if (j === state.board[index].count - 1 && state.selectedPoint === index) checker.classList.add('selected'); checker.style.setProperty('--i', j); point.appendChild(checker); } } return point; }
        function createChecker(player, from, handlePlayerAction) { const checker = document.createElement('div'); checker.className = `checker ${player}`; checker.dataset.from = from; checker.addEventListener('click', (e) => { e.stopPropagation(); handlePlayerAction(from); }); return checker; }
        function createPointNumberRow(pos) { const row = document.createElement('div'); row.className = `point-number-row ${pos}`; const leftQuad = document.createElement('div'); leftQuad.className = 'point-number-quadrant'; const rightQuad = document.createElement('div'); rightQuad.className = 'point-number-quadrant'; const start = pos === 'top' ? 12 : 11, end = pos === 'top' ? 23 : 0, dir = pos === 'top' ? 1 : -1; let numbers = []; for (let i = start; (pos === 'top' ? i <= end : i >= end); i += dir) { numbers.push(i + 1); } numbers.forEach(num => { const numEl = document.createElement('div'); numEl.className = 'point-number'; numEl.textContent = num; if ((pos === 'top' && num >= 19) || (pos === 'bottom' && num <= 6)) { rightQuad.appendChild(numEl); } else { leftQuad.appendChild(numEl); } }); row.append(leftQuad, document.createElement('div'), rightQuad); return row; }
        function updateInfo(state, dom) { dom.turn.textContent = `${state.currentPlayer === PLAYER ? "あなた(赤)" : "CPU(黒)"}のターン`; dom.barP.textContent = state.bar[PLAYER]; dom.borneP.textContent = state.borneOff[PLAYER]; dom.barC.textContent = state.bar[CPU]; dom.borneC.textContent = state.borneOff[CPU]; dom.die1.textContent = state.dice[0] || '?'; dom.die2.textContent = state.dice[1] || '?'; if (state.currentPlayer === PLAYER && state.turnState === 'MOVING') { dom.movesLeft.textContent = state.movesLeft.length > 0 ? state.movesLeft.join(', ') : 'なし'; } else { dom.movesLeft.textContent = '-'; } }
        function highlightValidMoves(state, dom) { document.querySelectorAll('.point.valid-move, .home-area.valid-move').forEach(p => p.classList.remove('valid-move')); if (state.currentPlayer !== PLAYER || state.turnState !== 'MOVING') return; const sequences = game.rules.generateAllMoveSequences(state.board, state.bar, PLAYER, state.movesLeft); const allPossibleFirstMoves = [...new Map(sequences.flatMap(s => s.moves[0] ? [s.moves[0]] : []).map(m => [`${m.from}-${m.to}`, m])).values()]; if (state.selectedPoint !== null) { allPossibleFirstMoves.filter(m => m.from === state.selectedPoint).forEach(m => { if (m.to === 'home') dom.home.classList.add('valid-move'); else document.querySelector(`.point[data-index='${m.to}']`)?.classList.add('valid-move'); }); } }
        async function showDiceAnimation(dom) { const animationTime = 800; const interval = setInterval(() => { dom.die1.textContent = Math.ceil(Math.random() * 6); dom.die2.textContent = Math.ceil(Math.random() * 6); }, 80); await new Promise(resolve => setTimeout(resolve, animationTime)); clearInterval(interval); }
        
        // --- ゲームの初期化 ---
        document.addEventListener('DOMContentLoaded', () => {
            const game = new BackgammonGame(dom);
            
            // ルールとAIのロジックをクラスのプロパティとして設定
            // これらは状態(state)に依存しない純粋な関数なので、クラスの外で定義し、インスタンスに注入する
            game.rules = { executeMove, generateAllMoveSequences, generateSingleMoves, canPlayerBearOff, findHighestCheckerInHome };
            game.ai = { findBestCpuMoveSequence, evaluateBoard };

            // イベントリスナーをインスタンスのメソッドにバインド
            dom.startBtn.addEventListener('click', () => game.initGame());
            dom.rollBtn.addEventListener('click', () => game.handleRoll());
            dom.undoBtn.addEventListener('click', () => game.handleUndo());
            dom.home.addEventListener('click', () => game.handlePlayerAction('home'));
        });
    </script>
</body>
</html>
