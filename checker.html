<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒã‚§ãƒƒã‚«ãƒ¼ (AIè¶…å¼·åŒ–ç‰ˆ)</title>
    <style>
        body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; flex-direction: column; background-color: #f0f0f0; margin: 0; padding: 20px; }
        h1 { color: #333; text-align: center; margin-bottom: 20px;}
        .container { display: flex; gap: 30px; align-items: flex-start; flex-wrap: wrap; justify-content: center; }
        #board { display: grid; grid-template-columns: repeat(8, 55px); grid-template-rows: repeat(8, 55px); border: 3px solid #8B4513; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }
        .cell { width: 55px; height: 55px; box-sizing: border-box; display: flex; justify-content: center; align-items: center; font-size: 30px; color: #FFD700; }
        .light { background-color: #F5DEB3; } .dark { background-color: #A0522D; }
        .disc { width: 85%; height: 85%; border-radius: 50%; box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3); cursor: pointer; }
        .white-man { background-color: #f8f8f8; }
        .red-man { background: radial-gradient(circle at 65% 35%, #e57373, #c62828); border: 2px solid #b71c1c; }
        .king::after { content: 'ğŸ‘‘'; position: absolute; transform: translateY(-5px); text-shadow: 0 0 3px black; pointer-events: none; }
        .selected { background-color: #64b5f6 !important; }
        .valid-move { background-color: rgba(144, 238, 144, 0.7) !important; cursor: pointer; }
        .sidebar { display: flex; flex-direction: column; }
        .controls, .game-info { background-color: white; color: #333; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); width: 220px; box-sizing: border-box; margin-bottom: 20px; }
        .controls label, .controls select, .controls button { display: block; width: 100%; margin-bottom: 10px; }
        .controls select, .controls button { padding: 8px; border-radius: 4px; border: 1px solid #ccc; }
        .controls button { background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .controls button:hover { background-color: #45a049; }
        .player-color-selector { margin-top: 15px; margin-bottom: 15px; border-top: 1px solid #eee; padding-top: 15px; }
        .radio-group { display: flex; justify-content: space-around; }
        .radio-group label { display: flex; align-items: center; cursor: pointer; margin: 0; }
        .radio-group input { margin-right: 5px; }
        .game-info p { margin: 0 0 10px 0; font-size: 16px; display: flex; justify-content: space-between; }
        #message-area { margin-top: 15px; font-size: 18px; font-weight: bold; color: #d32f2f; height: 25px; text-align: center; }
    </style>
</head>
<body>
    <h1>ãƒã‚§ãƒƒã‚«ãƒ¼ ver2.0</h1>
    <div class="container">
        <div class="sidebar">
            <div class="controls">
                <label for="cpu-level">CPUãƒ¬ãƒ™ãƒ«:</label>
                <!-- â˜…â˜…â˜… AIãƒ¬ãƒ™ãƒ«ã‚’8æ®µéšã« â˜…â˜…â˜… -->
                <select id="cpu-level">
                    <option value="1">ãƒ¬ãƒ™ãƒ«1 (å…¥é–€)</option><option value="2">ãƒ¬ãƒ™ãƒ«2 (åˆç´š)</option><option value="3">ãƒ¬ãƒ™ãƒ«3 (ä¸­ç´š)</option>
                    <option value="4">ãƒ¬ãƒ™ãƒ«4 (ä¸Šç´š)</option><option value="5">ãƒ¬ãƒ™ãƒ«5 (ç†Ÿç·´)</option><option value="6">ãƒ¬ãƒ™ãƒ«6 (é”äºº)</option>
                    <option value="7" selected>ãƒ¬ãƒ™ãƒ«7 (å¸«ç¯„)</option><option value="8">ãƒ¬ãƒ™ãƒ«8 (é¬¼ç¥)</option>
                </select>
                <div class="player-color-selector">
                    <label>ã‚ãªãŸã®è‰²:</label>
                    <div class="radio-group">
                        <label><input type="radio" name="player_color" value="white" checked> å…ˆæ”»(ç™½)</label>
                        <label><input type="radio" name="player_color" value="red"> å¾Œæ”»(èµ¤)</label>
                    </div>
                </div>
                <button id="start-button">ã‚²ãƒ¼ãƒ é–‹å§‹ / ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            <div class="game-info">
                <p>æ‰‹æ•°: <span id="turn-count">0</span></p>
                <p><span id="white-label">ç™½ (ã‚ãªãŸ)</span>: <span id="white-score">12</span></p>
                <p><span id="red-label">èµ¤ (CPU)</span>: <span id="red-score">12</span></p>
                <p>ã‚¿ãƒ¼ãƒ³: <span id="current-turn"></span></p>
            </div>
            <div id="message-area"></div>
        </div>
        <div id="board"></div>
    </div>

    <script>
        class CheckerGame {
            constructor() {
                this.BOARD_SIZE = 8;
                this.PIECES = { EMPTY: 0, WHITE_MAN: 1, BLACK_MAN: 2, WHITE_KING: 3, BLACK_KING: 4 };
                this.dom = {
                    board: document.getElementById('board'), turnCount: document.getElementById('turn-count'),
                    whiteScore: document.getElementById('white-score'), redScore: document.getElementById('red-score'),
                    whiteLabel: document.getElementById('white-label'), redLabel: document.getElementById('red-label'),
                    currentTurn: document.getElementById('current-turn'), message: document.getElementById('message-area'),
                    level: document.getElementById('cpu-level'), startBtn: document.getElementById('start-button')
                };
                this.state = {};
                this.attachEventListeners();
                this.initGame();
            }

            // --- ã‚²ãƒ¼ãƒ é€²è¡Œ (å¤‰æ›´ãªã—) ---
            initGame() { /* ... */ }
            async switchTurn() { /* ... */ }
            endGame(isStalemate = false) { /* ... */ }

            // --- æç”»ã¨UIæ›´æ–° (å¤‰æ›´ãªã—) ---
            renderAll() { /* ... */ }
            renderBoard() { /* ... */ }
            updateInfo() { /* ... */ }

            // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œ (å¤‰æ›´ãªã—) ---
            onCellClick(r, c) { /* ... */ }

            // --- AIãƒ­ã‚¸ãƒƒã‚¯ ---
            
            async cpuTurn() {
                if (this.state.gameOver) return;
                let move = this.findBestCpuMove();
                if (move) {
                    this.performMove(this.state.board, move);
                    this.renderAll();
                    let wasJump = move.isJump;
                    let lastPos = move.to;
                    while (wasJump) {
                        const nextJumps = this.getJumpsFrom(this.state.board, lastPos.r, lastPos.c);
                        if(nextJumps.length > 0) {
                            await new Promise(r => setTimeout(r, 800));
                            this.performMove(this.state.board, nextJumps[0]);
                            this.renderAll();
                            lastPos = nextJumps[0].to;
                        } else {
                            wasJump = false;
                        }
                    }
                }
                this.switchTurn();
            }

            findBestCpuMove() {
                const moves = this.state.validMoves;
                if(moves.length === 0) return null;
                if(moves.length === 1) return moves[0];
                if(this.state.cpuLevel === 1) return moves[Math.floor(Math.random() * moves.length)];
                
                // â˜…â˜…â˜… æ¢ç´¢æ·±åº¦ã‚’ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦è¨­å®š â˜…â˜…â˜…
                const depthMap = { 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8 };
                const depth = depthMap[this.state.cpuLevel] || 2;
                return this.alphaBeta(this.state.board, depth, -Infinity, Infinity, true).move;
            }

            alphaBeta(currentBoard, depth, alpha, beta, maximizingPlayer) {
                const player = maximizingPlayer ? this.state.cpuColor : this.state.playerColor;
                const possibleMoves = this.updateAllValidMoves(currentBoard, player, null, true); // è©•ä¾¡ãƒ¢ãƒ¼ãƒ‰ã§å‘¼ã³å‡ºã—
                
                if (depth === 0 || possibleMoves.length === 0) {
                    return { score: this.evaluateBoard(currentBoard), move: null };
                }
                
                let bestMove = null;
                let bestValue = maximizingPlayer ? -Infinity : Infinity;
                for (const move of possibleMoves) {
                    const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                    this.performMove(tempBoard, move);
                    const result = this.alphaBeta(tempBoard, depth - 1, alpha, beta, !maximizingPlayer);

                    if (maximizingPlayer) {
                        if (result.score > bestValue) { bestValue = result.score; bestMove = move; }
                        alpha = Math.max(alpha, bestValue);
                    } else {
                        if (result.score < bestValue) { bestValue = result.score; bestMove = move; }
                        beta = Math.min(beta, bestValue);
                    }
                    if (beta <= alpha) break; // æåˆˆã‚Š
                }
                return { score: bestValue, move: bestMove || possibleMoves[0] };
            }
            
            // â˜…â˜…â˜… è¶…å¼·åŒ–ã•ã‚ŒãŸè©•ä¾¡é–¢æ•° â˜…â˜…â˜…
            evaluateBoard(currentBoard) {
                let score = 0;
                const cpu = this.state.cpuColor;
                const player = this.state.playerColor;

                // --- ãƒ¬ãƒ™ãƒ«7ä»¥ä¸Š: æ©Ÿå‹•åŠ›è©•ä¾¡ ---
                if (this.state.cpuLevel >= 7) {
                    const cpuMoves = this.updateAllValidMoves(currentBoard, cpu, null, true).length;
                    const playerMoves = this.updateAllValidMoves(currentBoard, player, null, true).length;
                    score += (cpuMoves - playerMoves) * 10;
                }

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = currentBoard[r][c];
                        const color = this.getPieceColor(piece);
                        if (!color) continue;
                        
                        let pieceScore = 0;
                        // é§’ã®ä¾¡å€¤
                        pieceScore += this.isKing(piece) ? 200 : 100;
                        
                        // å‰é€²åº¦
                        if (color === 'red') pieceScore += r * 5;
                        else pieceScore += (7 - r) * 5;

                        // --- ãƒ¬ãƒ™ãƒ«8ä»¥ä¸Š: é…ç½®è©•ä¾¡ ---
                        if (this.state.cpuLevel >= 8) {
                            // ãƒãƒƒã‚¯ãƒ­ã‚¦(ä¸€ç•ªå¥¥ã®åˆ—)ã«ã„ã‚‹é§’ã¯å®‰å…¨ãªã®ã§é«˜è©•ä¾¡
                            if ((color === 'white' && r === 0) || (color === 'red' && r === 7)) {
                                pieceScore += 25;
                            }
                            // ä¸­å¤®ã®åˆ—(c=2~5)ã‚’æ”¯é…ã—ã¦ã„ã‚‹ã¨æœ‰åˆ©
                            if (c >= 2 && c <= 5) {
                                pieceScore += 10;
                            }
                        }
                        
                        score += (color === cpu) ? pieceScore : -pieceScore;
                    }
                }
                return score;
            }
            
            // --- ãƒ«ãƒ¼ãƒ«åˆ¤å®šã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (isEvaluationãƒ•ãƒ©ã‚°ã®è¿½åŠ ) ---
            
            updateAllValidMoves(currentBoard, player, fromPos = null, isEvaluation = false) {
                if (fromPos && !isEvaluation) {
                    const moves = this.getJumpsFrom(currentBoard, fromPos.r, fromPos.c);
                    if (currentBoard === this.state.board) this.state.validMoves = moves;
                    return moves;
                }
                let allJumps = [], allSteps = [];
                for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                    if (this.getPieceColor(currentBoard[r][c]) === player) {
                        allJumps.push(...this.getJumpsFrom(currentBoard, r, c));
                        allSteps.push(...this.getStepsFrom(currentBoard, r, c));
                    }
                }
                const result = allJumps.length > 0 ? allJumps : allSteps;
                if (!isEvaluation && currentBoard === this.state.board) {
                    this.state.validMoves = result;
                }
                return result;
            }

            // --- æ®‹ã‚Šã®é–¢æ•° (å¤‰æ›´ãªã—) ---
            performMove(board, move) { /* ... */ }
            getJumpsFrom(board, r, c) { /* ... */ }
            getStepsFrom(board, r, c) { /* ... */ }
            getPieceColor(piece) { /* ... */ }
            isKing(piece) { /* ... */ }
            attachEventListeners() { /* ... */ }
        }
        
        // --- çœç•¥ã—ãŸé–¢æ•°ã®å±•é–‹ã¨å®Ÿè¡Œ ---
        CheckerGame.prototype.initGame = function() { const playerColor = document.querySelector('input[name="player_color"]:checked').value; this.state = { board: Array.from({ length: this.BOARD_SIZE }, () => Array(this.BOARD_SIZE).fill(this.PIECES.EMPTY)), currentPlayer: 'white', turnCount: 0, cpuLevel: parseInt(this.dom.level.value, 10), gameOver: false, selectedPiece: null, validMoves: [], isContinuousJump: false, playerColor: playerColor, cpuColor: playerColor === 'white' ? 'red' : 'white', }; for (let r = 0; r < 3; r++) for (let c = 0; c < 8; c++) if ((r + c) % 2 !== 0) this.state.board[r][c] = this.PIECES.BLACK_MAN; for (let r = 5; r < 8; r++) for (let c = 0; c < 8; c++) if ((r + c) % 2 !== 0) this.state.board[r][c] = this.PIECES.WHITE_MAN; this.updateAllValidMoves(this.state.board, this.state.currentPlayer); this.renderAll(); if (this.state.currentPlayer === this.state.cpuColor) { this.dom.message.textContent = 'CPUãŒæ€è€ƒä¸­...'; setTimeout(() => this.cpuTurn(), 1000); }};
        CheckerGame.prototype.switchTurn = async function() { this.state.currentPlayer = this.state.currentPlayer === 'white' ? 'red' : 'white'; this.updateAllValidMoves(this.state.board, this.state.currentPlayer); if (this.state.validMoves.length === 0) { this.endGame(true); return; } this.renderAll(); if (!this.state.gameOver && this.state.currentPlayer === this.state.cpuColor) { this.dom.message.textContent = 'CPUãŒæ€è€ƒä¸­...'; await new Promise(r => setTimeout(r, 500)); this.cpuTurn(); } };
        CheckerGame.prototype.endGame = function(isStalemate = false) { this.state.gameOver = true; let message; if (isStalemate) { const winner = this.state.currentPlayer === this.state.playerColor ? "CPUã®" : "ã‚ãªãŸã®"; message = `${this.state.currentPlayer === this.state.playerColor ? 'ã‚ãªãŸ' : 'CPU'}ã¯å‹•ã‘ã¾ã›ã‚“ã€‚${winner}å‹ã¡ã§ã™ï¼`; } else { const whiteCount = this.state.board.flat().filter(p => this.getPieceColor(p) === 'white').length; message = (whiteCount === 0) ? "CPUã®å‹ã¡ã§ã™ï¼" : "ã‚ãªãŸã®å‹ã¡ã§ã™ï¼"; } this.dom.message.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ ${message}`; this.updateInfo(); };
        CheckerGame.prototype.renderAll = function() { this.renderBoard(); this.updateInfo(); };
        CheckerGame.prototype.renderBoard = function() { this.dom.board.innerHTML = ''; for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) { const cell = document.createElement('div'); cell.className = `cell ${(r + c) % 2 === 0 ? 'light' : 'dark'}`; const piece = this.state.board[r][c]; if (piece !== this.PIECES.EMPTY) { const disc = document.createElement('div'); disc.className = 'disc'; const color = this.getPieceColor(piece); disc.classList.add(`${color}-man`); if(this.isKing(piece)) disc.classList.add('king'); cell.appendChild(disc); } if (this.state.selectedPiece && this.state.selectedPiece.r === r && this.state.selectedPiece.c === c) cell.classList.add('selected'); if (this.state.validMoves.some(m => m.to.r === r && m.to.c === c && (!this.state.selectedPiece || (this.state.selectedPiece.r === m.from.r && this.state.selectedPiece.c === m.from.c)))) cell.classList.add('valid-move'); cell.addEventListener('click', () => this.onCellClick(r, c)); this.dom.board.appendChild(cell); } };
        CheckerGame.prototype.updateInfo = function() { let whiteCount = 0, redCount = 0; this.state.board.flat().forEach(p => { if (this.getPieceColor(p) === 'white') whiteCount++; if (this.getPieceColor(p) === 'red') redCount++; }); this.dom.turnCount.textContent = this.state.turnCount; this.dom.whiteScore.textContent = whiteCount; this.dom.redScore.textContent = redCount; this.dom.whiteLabel.textContent = this.state.playerColor === 'white' ? 'ç™½ (ã‚ãªãŸ)' : 'ç™½ (CPU)'; this.dom.redLabel.textContent = this.state.playerColor === 'red' ? 'èµ¤ (ã‚ãªãŸ)' : 'èµ¤ (CPU)'; this.dom.currentTurn.textContent = this.state.gameOver ? 'çµ‚äº†' : (this.state.currentPlayer === this.state.playerColor ? 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³' : 'CPUã®ã‚¿ãƒ¼ãƒ³'); if(!this.state.gameOver && this.state.currentPlayer === this.state.playerColor && !this.state.isContinuousJump) this.dom.message.textContent = 'ã‚ãªãŸã®ç•ªã§ã™'; };
        CheckerGame.prototype.onCellClick = function(r, c) { if (this.state.gameOver || this.state.currentPlayer !== this.state.playerColor) return; if (this.state.selectedPiece) { const move = this.state.validMoves.find(m => m.from.r === this.state.selectedPiece.r && m.from.c === this.state.selectedPiece.c && m.to.r === r && m.to.c === c); if (move) { this.performMove(this.state.board, move); const nextJumps = this.getJumpsFrom(this.state.board, move.to.r, move.to.c); if (move.isJump && nextJumps.length > 0) { this.state.isContinuousJump = true; this.state.selectedPiece = { r: move.to.r, c: move.to.c }; this.dom.message.textContent = 'ç¶šã‘ã¦ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¦ãã ã•ã„ï¼'; this.updateAllValidMoves(this.state.board, this.state.currentPlayer, this.state.selectedPiece); this.renderAll(); } else { this.state.isContinuousJump = false; this.state.selectedPiece = null; this.switchTurn(); } } else { this.state.selectedPiece = null; if (this.getPieceColor(this.state.board[r][c]) === this.state.playerColor) this.state.selectedPiece = { r, c }; this.renderBoard(); } } else { if (this.getPieceColor(this.state.board[r][c]) === this.state.playerColor) { this.state.selectedPiece = { r, c }; this.renderBoard(); } } };
        CheckerGame.prototype.performMove = function(board, move) { const { from, to, isJump, jumpedPiece } = move; const piece = board[from.r][from.c]; board[to.r][to.c] = piece; board[from.r][from.c] = this.PIECES.EMPTY; if (isJump) board[jumpedPiece.r][jumpedPiece.c] = this.PIECES.EMPTY; const color = this.getPieceColor(piece); if ((color === 'white' && to.r === 0) || (color === 'red' && to.r === 7)) { board[to.r][to.c] = color === 'white' ? this.PIECES.WHITE_KING : this.PIECES.BLACK_KING; } if(board === this.state.board) this.state.turnCount++; };
        CheckerGame.prototype.getJumpsFrom = function(board, r, c) { const jumps = [], piece = board[r][c], color = this.getPieceColor(piece); if(!color) return []; const dirs = this.isKing(piece) ? [[-1,-1],[-1,1],[1,-1],[1,1]] : (color === 'white' ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]); for (const [dr, dc] of dirs) { const opponentR = r + dr, opponentC = c + dc, landingR = r + dr * 2, landingC = c + dc * 2; if (landingR >= 0 && landingR < 8 && landingC >= 0 && landingC < 8 && board[landingR][landingC] === 0) { const opponentPiece = board[opponentR][opponentC]; if (opponentPiece !== 0 && this.getPieceColor(opponentPiece) !== color) jumps.push({ from: {r,c}, to: {r:landingR,c:landingC}, isJump: true, jumpedPiece: {r:opponentR,c:opponentC}}); } } return jumps; };
        CheckerGame.prototype.getStepsFrom = function(board, r, c) { const steps = [], piece = board[r][c], color = this.getPieceColor(piece); if(!color) return []; const dirs = this.isKing(piece) ? [[-1,-1],[-1,1],[1,-1],[1,1]] : (color === 'white' ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]); for (const [dr, dc] of dirs) { const newR = r + dr, newC = c + dc; if (newR >= 0 && newR < 8 && newC >= 0 && newC < 8 && board[newR][newC] === 0) steps.push({ from: {r,c}, to: {r:newR,c:newC}, isJump: false }); } return steps; };
        CheckerGame.prototype.getPieceColor = function(piece) { const { WHITE_MAN, WHITE_KING, BLACK_MAN, BLACK_KING } = this.PIECES; if (piece === WHITE_MAN || piece === WHITE_KING) return 'white'; if (piece === BLACK_MAN || piece === BLACK_KING) return 'red'; return null; };
        CheckerGame.prototype.isKing = function(piece) { return piece === this.PIECES.WHITE_KING || piece === this.PIECES.BLACK_KING; };
        CheckerGame.prototype.attachEventListeners = function() { this.dom.startBtn.addEventListener('click', () => this.initGame()); };
        
        document.addEventListener('DOMContentLoaded', () => { new CheckerGame(); });
    </script>
</body>
</html>
