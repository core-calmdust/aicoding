<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript ãƒã‚§ãƒƒã‚«ãƒ¼ (AIå¼·åŒ–ç‰ˆ)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }

        .container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 55px);
            grid-template-rows: repeat(8, 55px);
            border: 3px solid #8B4513; /* SaddleBrown */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .cell {
            width: 55px;
            height: 55px;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: #FFD700; /* Gold */
        }

        .light { background-color: #F5DEB3; /* Wheat */ }
        .dark { background-color: #A0522D; /* Sienna */ }

        .disc {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            box-shadow: inset 0 -3px 5px rgba(0,0,0,0.4), 0 2px 3px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        .white-man { background-color: #f8f8f8; }
        .black-man { background-color: #333333; }
        
        .king::after {
            content: 'ğŸ‘‘'; /* ç‹å† ã®çµµæ–‡å­— */
            position: absolute;
            transform: translateY(-5px);
            text-shadow: 0 0 3px black;
        }

        /* ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤º */
        .selected {
            background-color: #64b5f6 !important; /* æ˜ã‚‹ã„é’ */
        }
        .valid-move {
            background-color: rgba(144, 238, 144, 0.7) !important; /* LightGreen */
            cursor: pointer;
        }

        /* --- UI & Controls --- */
        .controls, .game-info {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 220px;
            box-sizing: border-box;
        }
        .controls { margin-bottom: 20px; }
        .controls label, .controls select, .controls button { display: block; width: 100%; margin-bottom: 10px; }
        .controls select, .controls button { padding: 8px; border-radius: 4px; border: 1px solid #ccc; }
        .controls button { background-color: #4CAF50; color: white; border: none; cursor: pointer; }
        .controls button:hover { background-color: #45a049; }
        .game-info p { margin: 0 0 10px 0; font-size: 16px; display: flex; justify-content: space-between; }
        #message-area { margin-top: 15px; font-size: 18px; font-weight: bold; color: #d32f2f; height: 25px; text-align: center; }

        @media (max-width: 768px) {
            .container { flex-direction: column; align-items: center; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>JavaScript ãƒã‚§ãƒƒã‚«ãƒ¼</h1>
            <div class="controls">
                <label for="cpu-level">CPUãƒ¬ãƒ™ãƒ«:</label>
                <select id="cpu-level">
                    <option value="1">ãƒ¬ãƒ™ãƒ«1 (ãƒ©ãƒ³ãƒ€ãƒ )</option>
                    <option value="2">ãƒ¬ãƒ™ãƒ«2 (åŸºæœ¬è©•ä¾¡)</option>
                    <option value="3">ãƒ¬ãƒ™ãƒ«3 (Î±-Î²æ³• å¼±)</option>
                    <option value="4" selected>ãƒ¬ãƒ™ãƒ«4 (Î±-Î²æ³• å¼·)</option>
                </select>
                <button id="start-button">ã‚²ãƒ¼ãƒ é–‹å§‹ / ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            <div class="game-info">
                <p>æ‰‹æ•°: <span id="turn-count">0</span></p>
                <p>ç™½ (ã‚ãªãŸ): <span id="white-score">12</span></p>
                <p>é»’ (CPU): <span id="black-score">12</span></p>
                <p>ã‚¿ãƒ¼ãƒ³: <span id="current-turn"></span></p>
            </div>
        </div>
        <div class="game-area">
            <div id="board"></div>
            <div id="message-area"></div>
        </div>
    </div>

    <script>
        // --- Constants ---
        const BOARD_SIZE = 8;
        const EMPTY = 0, WHITE_MAN = 1, BLACK_MAN = 2, WHITE_KING = 3, BLACK_KING = 4;
        const PLAYER = 'white', CPU = 'black';

        // --- DOM Elements ---
        const boardEl = document.getElementById('board');
        const turnCountEl = document.getElementById('turn-count');
        const whiteScoreEl = document.getElementById('white-score');
        const blackScoreEl = document.getElementById('black-score');
        const currentTurnEl = document.getElementById('current-turn');
        const messageAreaEl = document.getElementById('message-area');
        const cpuLevelSelect = document.getElementById('cpu-level');
        const startButton = document.getElementById('start-button');

        // --- Game State ---
        let board = [];
        let currentPlayer;
        let turnCount;
        let cpuLevel;
        let gameOver;
        let selectedPiece = null;
        let validMoves = [];
        let isContinuousJump = false;

        function initGame() {
            // ... (å¤‰æ›´ãªã—) ...
            board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
            for (let r = 0; r < 3; r++) { for (let c = 0; c < BOARD_SIZE; c++) { if ((r + c) % 2 !== 0) board[r][c] = BLACK_MAN; } }
            for (let r = 5; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { if ((r + c) % 2 !== 0) board[r][c] = WHITE_MAN; } }
            currentPlayer = PLAYER;
            turnCount = 0;
            cpuLevel = parseInt(cpuLevelSelect.value, 10);
            gameOver = false;
            selectedPiece = null;
            isContinuousJump = false;
            messageAreaEl.textContent = 'ã‚ãªãŸã®ç•ªã§ã™';
            updateAllValidMoves(board, currentPlayer);
            renderBoard();
            updateInfo();
        }

        // --- Helper Functions (getPieceColor, isKing) ---
        function getPieceColor(piece) {
            if (piece === WHITE_MAN || piece === WHITE_KING) return 'white';
            if (piece === BLACK_MAN || piece === BLACK_KING) return 'black';
            return null;
        }
        function isKing(piece) { return piece === WHITE_KING || piece === BLACK_KING; }

        function renderBoard() {
            // ... (å¤‰æ›´ãªã—) ...
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    const piece = board[r][c];
                    if (piece !== EMPTY) {
                        const disc = document.createElement('div');
                        disc.className = 'disc';
                        if (piece === WHITE_MAN) disc.classList.add('white-man');
                        else if (piece === BLACK_MAN) disc.classList.add('black-man');
                        else if (piece === WHITE_KING) disc.classList.add('white-man', 'king');
                        else if (piece === BLACK_KING) disc.classList.add('black-man', 'king');
                        cell.appendChild(disc);
                    }
                    if (selectedPiece && selectedPiece.r === r && selectedPiece.c === c) cell.classList.add('selected');
                    if (validMoves.some(m => m.to.r === r && m.to.c === c && (!selectedPiece || (selectedPiece.r === m.from.r && selectedPiece.c === m.from.c)))) cell.classList.add('valid-move');
                    cell.addEventListener('click', () => onCellClick(r, c));
                    boardEl.appendChild(cell);
                }
            }
        }

        function updateInfo() { /* ... (å¤‰æ›´ãªã—) ... */ }

        function onCellClick(r, c) {
            if (gameOver || currentPlayer !== PLAYER) return;
            if (selectedPiece) {
                const move = validMoves.find(m => m.from.r === selectedPiece.r && m.from.c === selectedPiece.c && m.to.r === r && m.to.c === c);
                if (move) {
                    performMove(board, move);
                    // é€£ç¶šã‚¸ãƒ£ãƒ³ãƒ—ã®ãƒã‚§ãƒƒã‚¯
                    if (move.isJump && getJumpsFrom(board, move.to.r, move.to.c).length > 0) {
                        isContinuousJump = true;
                        currentPlayer = PLAYER;
                        selectedPiece = { r: move.to.r, c: move.to.c };
                        messageAreaEl.textContent = 'ç¶šã‘ã¦ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¦ãã ã•ã„ï¼';
                        updateAllValidMoves(board, currentPlayer);
                        renderBoard();
                    } else {
                        isContinuousJump = false;
                        switchTurn();
                    }
                } else {
                    selectedPiece = null;
                    if (getPieceColor(board[r][c]) === PLAYER) selectedPiece = { r, c };
                    renderBoard();
                }
            } else {
                if (getPieceColor(board[r][c]) === PLAYER) {
                    selectedPiece = { r, c };
                    renderBoard();
                }
            }
        }
        
        // é§’ã‚’å‹•ã‹ã™ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç‹¬ç«‹ã—ãŸé–¢æ•°ã«
        function performMove(currentBoard, move) {
            const { from, to, isJump, jumpedPiece } = move;
            const piece = currentBoard[from.r][from.c];
            currentBoard[to.r][to.c] = piece;
            currentBoard[from.r][from.c] = EMPTY;
            if (isJump) currentBoard[jumpedPiece.r][jumpedPiece.c] = EMPTY;
            // ã‚­ãƒ³ã‚°ã¸ã®æ˜‡æ ¼
            if ((piece === WHITE_MAN && to.r === 0) || (piece === BLACK_MAN && to.r === 7)) {
                currentBoard[to.r][to.c] = (getPieceColor(piece) === 'white') ? WHITE_KING : BLACK_KING;
            }
            if(currentBoard === board) turnCount++;
        }

        async function switchTurn() {
            selectedPiece = null;
            currentPlayer = (currentPlayer === PLAYER) ? CPU : PLAYER;
            updateAllValidMoves(board, currentPlayer);

            if (validMoves.length === 0) { endGame(true); return; }

            renderBoard();
            updateInfo();
            
            if (!gameOver && currentPlayer === CPU) {
                messageAreaEl.textContent = 'CPUãŒæ€è€ƒä¸­...';
                await new Promise(r => setTimeout(r, 100)); // UIæ›´æ–°ç”¨
                cpuTurn();
            } else {
                 messageAreaEl.textContent = 'ã‚ãªãŸã®ç•ªã§ã™';
            }
        }
        
        async function cpuTurn() {
            if (gameOver) return;

            const bestMove = findBestMoveForCPU();
            
            if (bestMove) {
                 performMove(board, bestMove);
                 
                 // CPUã®é€£ç¶šã‚¸ãƒ£ãƒ³ãƒ—
                 let currentPos = bestMove.to;
                 let wasJump = bestMove.isJump;
                 while(wasJump) {
                     updateAllValidMoves(board, CPU, currentPos); // ã‚¸ãƒ£ãƒ³ãƒ—å…ƒã‚’é™å®š
                     if (validMoves.length > 0 && validMoves[0].isJump) {
                         const nextJump = validMoves[0]; // é€£ç¶šã‚¸ãƒ£ãƒ³ãƒ—ã¯1æŠã®ã¯ãš
                         await new Promise(r => setTimeout(r, 400)); // é€£ç¶šã‚¸ãƒ£ãƒ³ãƒ—ã‚’è¦–è¦šçš„ã«è¦‹ã›ã‚‹
                         performMove(board, nextJump);
                         currentPos = nextJump.to;
                         renderBoard();
                     } else {
                         wasJump = false;
                     }
                 }
            }
            
            switchTurn();
        }

        function findBestMoveForCPU() {
            if (validMoves.length === 0) return null;
            if (validMoves.length === 1) return validMoves[0]; // é¸æŠè‚¢ãŒ1ã¤ãªã‚‰å³æ±º

            if (cpuLevel === 1) return validMoves[Math.floor(Math.random() * validMoves.length)];
            
            if (cpuLevel === 2) {
                let bestMove = null;
                let bestScore = -Infinity;
                for (const move of validMoves) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    performMove(tempBoard, move);
                    const score = evaluateBoard(tempBoard, CPU);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return bestMove;
            }
            
            // --- â˜… ãƒ¬ãƒ™ãƒ«3, 4ã¯Î±-Î²æ³•ã‚’ä½¿ç”¨ ---
            const depth = (cpuLevel === 3) ? 3 : 5;
            return alphaBeta(board, depth, -Infinity, Infinity, true).move;
        }

        // --- â˜… æ”¹è‰¯ã•ã‚ŒãŸè©•ä¾¡é–¢æ•° ---
        function evaluateBoard(currentBoard, player) {
            let playerScore = 0, opponentScore = 0;
            const opponent = (player === CPU) ? PLAYER : CPU;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const p = currentBoard[r][c];
                    const color = getPieceColor(p);
                    const pieceValue = isKing(p) ? 200 : 100; // ã‚­ãƒ³ã‚°ã®ä¾¡å€¤ã‚’é«˜ã

                    if (color === player) {
                        playerScore += pieceValue;
                        // å‰é€²ãƒœãƒ¼ãƒŠã‚¹
                        playerScore += (player === CPU) ? r * 5 : (7-r) * 5;
                        // ã‚µã‚¤ãƒ‰ã«ã„ã‚‹é§’ã¯å°‘ã—å®‰å…¨
                        if (c === 0 || c === 7) playerScore += 10;
                    } else if (color === opponent) {
                        opponentScore += pieceValue;
                        opponentScore += (opponent === CPU) ? r * 5 : (7-r) * 5;
                        if (c === 0 || c === 7) opponentScore += 10;
                    }
                }
            }
             // é§’ãŒå°‘ãªã„å ´åˆã¯ã€ç·æ•°ã§ã®è©•ä¾¡ã‚’ã‚ˆã‚Šé‡è¦–
            const totalPieces = (playerScore + opponentScore) / 100;
            if (totalPieces < 8) {
                return (playerScore - opponentScore) * 2;
            }
            return playerScore - opponentScore;
        }
        
        // --- â˜… Î±-Î²æ³•ã®å®Ÿè£… ---
        function alphaBeta(currentBoard, depth, alpha, beta, maximizingPlayer) {
            const player = maximizingPlayer ? CPU : PLAYER;
            const possibleMoves = updateAllValidMoves(currentBoard, player);

            if (depth === 0 || possibleMoves.length === 0) {
                return { score: evaluateBoard(currentBoard, CPU), move: null };
            }

            let bestMove = null;
            let bestValue = maximizingPlayer ? -Infinity : Infinity;

            for (const move of possibleMoves) {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                performMove(tempBoard, move);

                // é€£ç¶šã‚¸ãƒ£ãƒ³ãƒ—ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                let wasJump = move.isJump;
                let lastPos = move.to;
                while(wasJump) {
                    const nextJumps = getJumpsFrom(tempBoard, lastPos.r, lastPos.c);
                    if (nextJumps.length > 0) {
                        const nextJump = nextJumps[0];
                        performMove(tempBoard, nextJump);
                        lastPos = nextJump.to;
                    } else {
                        wasJump = false;
                    }
                }

                const result = alphaBeta(tempBoard, depth - 1, alpha, beta, !maximizingPlayer);

                if (maximizingPlayer) {
                    if (result.score > bestValue) {
                        bestValue = result.score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, bestValue);
                } else {
                    if (result.score < bestValue) {
                        bestValue = result.score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, bestValue);
                }

                if (beta <= alpha) {
                    break; // æåˆˆã‚Š
                }
            }
            return { score: bestValue, move: bestMove };
        }


        // --- åˆæ³•æ‰‹åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ (å¼•æ•°ã«boardã‚’è¿½åŠ ) ---
        function updateAllValidMoves(currentBoard, player, fromPos = null) {
            // é€£ç¶šã‚¸ãƒ£ãƒ³ãƒ—ä¸­ã¯ã€ãã®é§’ã‹ã‚‰ã®ã‚¸ãƒ£ãƒ³ãƒ—ã®ã¿
            if(isContinuousJump && selectedPiece) {
                validMoves = getJumpsFrom(currentBoard, selectedPiece.r, selectedPiece.c);
                return validMoves;
            }
            // CPUã®é€£ç¶šã‚¸ãƒ£ãƒ³ãƒ—ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
            if (fromPos) {
                 validMoves = getJumpsFrom(currentBoard, fromPos.r, fromPos.c);
                 return validMoves;
            }

            let allJumps = [], allSteps = [];
            for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) {
                if (getPieceColor(currentBoard[r][c]) === player) {
                    allJumps.push(...getJumpsFrom(currentBoard, r, c));
                    allSteps.push(...getStepsFrom(currentBoard, r, c));
                }
            }}
            
            const result = allJumps.length > 0 ? allJumps : allSteps;
            if(currentBoard === board) validMoves = result;
            return result;
        }

        function getJumpsFrom(currentBoard, r, c) {
            const jumps = [];
            const piece = currentBoard[r][c];
            const pieceColor = getPieceColor(piece);
            const moveDirs = isKing(piece) ? [[-1,-1],[-1,1],[1,-1],[1,1]] : (pieceColor === PLAYER ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]);
            for (const [dr, dc] of moveDirs) {
                const opponentR = r + dr, opponentC = c + dc;
                const landingR = r + dr * 2, landingC = c + dc * 2;
                if (landingR >= 0 && landingR < 8 && landingC >= 0 && landingC < 8 && currentBoard[landingR][landingC] === EMPTY) {
                    const opponentPiece = currentBoard[opponentR][opponentC];
                    if (opponentPiece !== EMPTY && getPieceColor(opponentPiece) !== pieceColor) {
                        jumps.push({ from: {r,c}, to: {r:landingR, c:landingC}, isJump: true, jumpedPiece: {r:opponentR, c:opponentC} });
                    }
                }
            }
            return jumps;
        }
        
        function getStepsFrom(currentBoard, r, c) {
            const steps = [];
            const piece = currentBoard[r][c];
            const pieceColor = getPieceColor(piece);
            const moveDirs = isKing(piece) ? [[-1,-1],[-1,1],[1,-1],[1,1]] : (pieceColor === PLAYER ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]]);
            for (const [dr, dc] of moveDirs) {
                const newR = r + dr, newC = c + dc;
                if (newR >= 0 && newR < 8 && newC >= 0 && newC < 8 && currentBoard[newR][newC] === EMPTY) {
                    steps.push({ from: {r,c}, to: {r:newR, c:newC}, isJump: false });
                }
            }
            return steps;
        }
        
        function endGame(isStalemate = false) { /* ... (å¤‰æ›´ãªã—) ... */ }

        // --- Event Listeners & Init ---
        startButton.addEventListener('click', initGame);
        cpuLevelSelect.addEventListener('change', () => { cpuLevel = parseInt(cpuLevelSelect.value, 10); });
        
        // initGameå†…ã®é–¢æ•°ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å±•é–‹
        updateInfo = function() {
             let whiteCount = 0, blackCount = 0;
            board.flat().forEach(p => {
                if (getPieceColor(p) === 'white') whiteCount++;
                if (getPieceColor(p) === 'black') blackCount++;
            });
            turnCountEl.textContent = turnCount;
            whiteScoreEl.textContent = whiteCount;
            blackScoreEl.textContent = blackCount;
            currentTurnEl.textContent = gameOver ? 'çµ‚äº†' : (currentPlayer === PLAYER ? 'ç™½ (ã‚ãªãŸ)' : 'é»’ (CPU)');
        }
        endGame = function(isStalemate = false) {
            gameOver = true;
            let message;
            if (isStalemate) {
                const winner = (currentPlayer === PLAYER) ? "CPUã®" : "ã‚ãªãŸã®";
                message = `${currentPlayer === PLAYER ? 'ã‚ãªãŸ' : 'CPU'}ã¯å‹•ã‘ã¾ã›ã‚“ã€‚${winner}å‹ã¡ã§ã™ï¼`;
            } else {
                 const whiteCount = board.flat().filter(p => getPieceColor(p) === 'white').length;
                 const blackCount = board.flat().filter(p => getPieceColor(p) === 'black').length;
                 if(whiteCount === 0) message = "CPUã®å‹ã¡ã§ã™ï¼";
                 else if(blackCount === 0) message = "ã‚ãªãŸã®å‹ã¡ã§ã™ï¼";
            }
            messageAreaEl.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ ${message}`;
            updateInfo();
        }

        initGame();
    </script>
</body>
</html>
