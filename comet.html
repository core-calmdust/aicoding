<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COMET OUTBURST</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            margin: 0;
            background-color: #00001a;
            font-family: 'Press Start 2P', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #fullscreen-root:fullscreen {
            background-color: #00001a;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #fullscreen-root:fullscreen #game-wrapper {
            transform: scale(var(--scale-factor, 1));
            transform-origin: center;
        }
        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; 
        }
        canvas {
            background-color: #000000;
            border: 2px solid #0088cc;
            box-shadow: 0 0 20px #0088cc;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
            transition: border-color 0.2s, box-shadow 0.2s, filter 1s ease-out, -webkit-filter 1s ease-out;
        }
        #instructions-container {
           color: #ccc;
           font-size: 12px;
           width: 800px;
           padding: 8px 15px;
           box-sizing: border-box;
           display: flex;
           justify-content: space-between;
           align-items: center;
           text-shadow: 0 0 10px #00ccff;
        }
        #extra-instruction {
            opacity: 0.8;
            padding-top: 4px;
        }
        #sound-toggle-button {
            position: absolute; 
            bottom: 65px;
            right: 20px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #00ccff;
            background-color: transparent;
            border: 2px solid #00ccff;
            padding: 5px 10px;
            border-radius: 4px;
            box-shadow: 0 0 10px #00ccff;
            cursor: pointer;
            user-select: none;
            text-shadow: 0 0 5px #00ccff;
            z-index: 100;
            opacity: 0.7;
            transition: opacity 0.2s, background-color 0.2s;
        }
        #sound-toggle-button:hover {
            opacity: 1.0;
            background-color: var(--button-hover-bg, rgba(0, 204, 255, 0.2));
        }
    </style>
</head>
<body>
    <div id="fullscreen-root">
        <div id="game-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="sound-toggle-button">SOUND ON</div>
            <div id="instructions-container">
                <div>
                    <div id="main-instruction"></div>
                    <div id="extra-instruction"></div>
                </div>
                <span id="controls-instruction"></span>
            </div>
        </div>
    </div>

<script>
// =================================================================================
// ▼▼▼ オンラインランキング用設定 ▼▼▼
// =================================================================================
const RANKING_CONFIG = {
    // 【重要】Nhostプロジェクトのダッシュボードで取得したGraphQL EndpointのURLをここに貼り付けてください
    API_ENDPOINT: "https://comet-outburst-ranking.nhost.run/v1/graphql", 
};
// =================================================================================
// ▲▲▲ オンラインランキング用設定 ▲▲▲
// =================================================================================

// =================================================================================
// ▼▼▼ Comet - A Synthwave dodging game (v76 - Online Ranking) ▼▼▼
// =================================================================================
//
// オンラインランキング機能を追加。
//

// ---------------------------------
// ゲーム設定
// ---------------------------------
const config = {
    canvasWidth: 800,
    canvasHeight: 600,
    playerSpeed: 300,
    playerSlowModeMultiplier: 0.5,
    playerHitboxRadius: 3, 
    playerVisualSize: 16,
    initialCometSpeed: 288,
    cometSpeedIncrease: 0.07,
    distanceScoreMultiplier: 1,
    cometSpawnInterval: 12,
    cometSpawnAmount: 3,
    cometCoreRadius: 5,
    starCount: 50,
    starScrollMultiplier: 16,
    starGlazeRadius: 20,
    glazeDistance: 40,
    glazeScore: 750,
    starGlazeScore: 500,
    highScoreKey: 'cometHighScore',
    lastPlayerNameKey: 'cometLastPlayerName',
    fontFamily: '"Press Start 2P", monospace',
    glowBlur: 12,
    energyTotal: 20 * 60,
    energyItemSpeed: 305,
    energyItemSize: 16,
    energyItemScoreNormal: 10000,
    energyItemScoreSpecial: 50000,
    gravity: 600,
};

// プレイヤーのドット絵データ (0:透明, 1:本体, 2:コックピット, 3:噴射口)
const PLAYER_PIXEL_ART = [
    [0,0,0,0,0,0,2,2,0,0,0,0,0,0],
    [0,0,0,0,0,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,1,1,0,0,0,0],
    [0,0,0,2,1,1,1,1,1,1,2,0,0,0],
    [0,0,1,1,1,1,1,1,1,1,1,1,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [2,1,1,0,1,1,1,1,1,1,0,1,1,2],
    [0,0,0,0,3,0,0,0,0,3,0,0,0,0],
];
// エネルギーアイテムのドット絵
const ENERGY_ITEM_PIXEL_ART = [
    [0,0,0,2,2,2,2,2,2,2,2,0,0,0],
    [0,0,2,2,2,2,2,2,2,2,2,2,0,0],
    [0,2,2,0,0,0,0,0,0,0,0,2,2,0],
    [2,2,0,0,1,1,1,1,1,1,0,0,2,2],
    [2,2,0,1,1,0,0,0,0,0,0,0,2,2],
    [2,2,0,1,1,0,0,0,0,0,0,0,2,2],
    [2,2,0,1,1,1,1,1,1,0,0,0,2,2],
    [2,2,0,1,1,1,1,1,1,0,0,0,2,2],
    [2,2,0,1,1,0,0,0,0,0,0,0,2,2],
    [2,2,0,1,1,0,0,0,0,0,0,0,2,2],
    [2,2,0,0,1,1,1,1,1,1,0,0,2,2],
    [0,2,2,0,0,0,0,0,0,0,0,2,2,0],
    [0,0,2,2,2,2,2,2,2,2,2,2,0,0],
    [0,0,0,2,2,2,2,2,2,2,2,0,0,0]
];

const STAGE_LENGTH_IN_FRAMES = 886; // (60sec / 130bpm) * 4 beats * 8 bars * 60fps

const themes = [
    { name: 'Synthwave', grid: '#ff00ff', player: '#00ffff', comet: '#00aaff', ui: '#00ccff' },
    { name: 'Outrun',    grid: '#ff8c00', player: '#ffdf00', comet: '#ff4500', ui: '#ffd700' },
    { name: 'Aurora', grid: '#4B0082', player: '#00FF7F', comet: '#9400D3', ui: '#7CFC00' },
    { name: 'Coral Reef', grid: '#1E90FF', player: '#FFD700', comet: '#FF4500', ui: '#00FFFF' },
    { name: 'Neon Jungle', grid: '#006400', player: '#FF00FF', comet: '#39FF14', ui: '#F0E68C' },
    { name: 'Midnight Sun', grid: '#483D8B', player: '#FFFFE0', comet: '#FF8C00', ui: '#FFDAB9' },
    { name: 'Deep Space', grid: '#191970', player: '#FFFFFF', comet: '#B0C4DE', ui: '#E6E6FA' },
    { name: 'Sakura', grid: '#3CB371', player: '#FFFFFF', comet: '#FFB6C1', ui: '#FFC0CB' },
    { name: 'Autumn', grid: '#8B4513', player: '#FFFF00', comet: '#FF4500', ui: '#FFA500' },
    { name: 'Tropical', grid: '#008080', player: '#ADFF2F', comet: '#FF1493', ui: '#F0E68C' },
    { name: 'Galaxy', grid: '#483D8B', player: '#FFD700', comet: '#DA70D6', ui: '#BA55D3' },
    { name: 'Inferno', grid: '#8B0000', player: '#FFFF00', comet: '#FF4500', ui: '#FF6347' },
    { name: 'Crystal Cave', grid: '#00008B', player: '#E0FFFF', comet: '#AFEEEE', ui: '#ADD8E6' },
    { name: 'Gilded Age', grid: '#2F4F4F', player: '#FFD700', comet: '#F0E68C', ui: '#DAA520' },
    { name: 'Cosmic',    grid: '#a953e6', player: '#ffffff', comet: '#68d9f5', ui: '#f06e8c' },
    { name: 'Monochrome',grid: '#888888', player: '#ffffff', comet: '#cccccc', ui: '#dddddd' }
];

// ---------------------------------
// オーディオハンドラ (完全版)
// ---------------------------------
class AudioHandler {
    constructor() {
        this.ctx = null; this.masterGain = null; this.bgmOscillators = [];
        this.isInitialized = false;
        this.bgmPlaying = false;
        this.nextNoteTime = 0;
        this.current16th = 0;
        this.seq3ChordProgression = [0, -2, 3, 5];
        this.seq4Melody = [12, 10, 7, 5, 3, 0, -2, 0];
        this.seq4MelodyIndex = 0;
        this.seq5Melody = [12, null, 15, 10, null, 12, 7, null, 14, null, 17, 12, null, 10, 5, null];
        this.seq5MelodyIndex = 0;
        this.hiHatPanIndex = 0;
        this.isMuted = false;
        this.volume = 0.4;
        this.barTrigger = false;
    }
    initialize() {
        if (this.isInitialized) return;
        try {
            this.ctx = new(window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.masterGain.gain.value = this.isMuted ? 0 : this.volume;
            this.isInitialized = true;
        } catch (e) { console.error("Web Audio API is not supported in this browser."); }
    }
    createSound(freq, dur, type, decay, vol, startTime, ramp) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain).connect(this.masterGain);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, startTime);
        if (ramp) osc.frequency.exponentialRampToValueAtTime(freq * 1.7, startTime + dur);
        gain.gain.setValueAtTime(vol, startTime);
        gain.gain.exponentialRampToValueAtTime(0.001, startTime + dur * decay);
        osc.start(startTime); osc.stop(startTime + dur);
    }
    
    playBgm() {
        if (!this.isInitialized || this.bgmPlaying) return;
        this.stopBgm();
        this.bgmPlaying = true;
        this.current16th = 0;
        this.seq4MelodyIndex = 0;
        this.seq5MelodyIndex = 0;
        this.hiHatPanIndex = 0;
        this.nextNoteTime = this.ctx.currentTime + 0.1;
    }
    
    scheduleBGM() {
        if (!this.bgmPlaying) return;

        const bgmStage = ((stage - 1) % 6) + 1;
        const bpm = 130;
        const sixteenth = 60 / bpm / 4;
        const rootNote = 27.50;

        const createKick = time => {
            const osc = this.ctx.createOscillator(),
                gain = this.ctx.createGain();
            const noise = this.ctx.createBufferSource(),
                noiseGain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(120, time);
            osc.frequency.exponentialRampToValueAtTime(40, time + 0.15);
            gain.gain.setValueAtTime(1.0, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            osc.connect(gain).connect(this.masterGain);
            const bufSize = this.ctx.sampleRate * 0.05;
            const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buf;
            noiseGain.gain.setValueAtTime(0.3, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.02);
            noise.connect(noiseGain).connect(this.masterGain);
            osc.start(time);
            osc.stop(time + 0.2);
            noise.start(time);
            noise.stop(time + 0.05);
            this.bgmOscillators.push(osc, gain, noise, noiseGain);
        };
        const createHiHat = (time, open = false) => {
            const noise = this.ctx.createBufferSource();
            const bufSize = this.ctx.sampleRate * 0.5;
            const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buf;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 8000;
            const panner = this.ctx.createStereoPanner();
            panner.pan.value = [-0.6, 0.6][this.hiHatPanIndex % 2];
            this.hiHatPanIndex++;
            const gain = this.ctx.createGain();
            const decayTime = open ? 0.3 : 0.05;
            gain.gain.setValueAtTime(open ? 0.3 : 0.2, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + decayTime);
            noise.connect(filter).connect(panner).connect(gain).connect(this.masterGain);
            noise.start(time);
            noise.stop(time + decayTime + 0.05);
            this.bgmOscillators.push(noise, filter, panner, gain);
        };
        const createSnare = time => {
            const noise = this.ctx.createBufferSource();
            const bufSize = this.ctx.sampleRate * 0.2;
            const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buf;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1500;
            filter.Q.value = 1;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            noise.connect(filter).connect(gain).connect(this.masterGain);
            noise.start(time);
            noise.stop(time + 0.1);
            this.bgmOscillators.push(noise, filter, gain);
        };
        const createStereoBass = (time, note) => {
            const oscL = this.ctx.createOscillator(),
                oscR = this.ctx.createOscillator();
            const pannerL = this.ctx.createStereoPanner(),
                pannerR = this.ctx.createStereoPanner();
            const filter = this.ctx.createBiquadFilter(),
                gain = this.ctx.createGain();
            oscL.type = 'square';
            oscL.frequency.value = note;
            oscR.type = 'sawtooth';
            oscR.frequency.value = note * 1.01;
            filter.type = 'lowpass';
            filter.Q.value = 5;
            filter.frequency.setValueAtTime(800, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + sixteenth * 0.8);
            gain.gain.setValueAtTime(0.6, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 0.9);
            pannerL.pan.value = -0.8;
            oscL.connect(pannerL).connect(filter);
            pannerR.pan.value = 0.8;
            oscR.connect(pannerR).connect(filter);
            filter.connect(gain).connect(this.masterGain);
            oscL.start(time);
            oscL.stop(time + sixteenth);
            oscR.start(time);
            oscR.stop(time + sixteenth);
            this.bgmOscillators.push(oscL, oscR, pannerL, pannerR, filter, gain);
        };
        const createSequence = (time, note) => {
            const osc = this.ctx.createOscillator(),
                panner = this.ctx.createStereoPanner(),
                gain = this.ctx.createGain(),
                delay = this.ctx.createDelay(),
                feedback = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.9;
            osc.type = 'triangle';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
            delay.delayTime.value = sixteenth * 3;
            feedback.gain.value = 0.5;
            osc.connect(panner).connect(gain);
            gain.connect(this.masterGain);
            gain.connect(delay);
            delay.connect(feedback).connect(delay);
            delay.connect(this.masterGain);
            osc.start(time);
            osc.stop(time + 0.1);
            this.bgmOscillators.push(osc, panner, gain, delay, feedback);
        };
        const createStereoPad = (time, note) => {
            const oscL = this.ctx.createOscillator(),
                oscR = this.ctx.createOscillator();
            const pannerL = this.ctx.createStereoPanner(),
                pannerR = this.ctx.createStereoPanner();
            const filter = this.ctx.createBiquadFilter(),
                gain = this.ctx.createGain();
            oscL.type = 'sawtooth';
            oscR.type = 'sawtooth';
            oscL.frequency.value = note;
            oscR.frequency.value = note;
            oscL.detune.value = -10;
            oscR.detune.value = 10;
            pannerL.pan.value = -1;
            pannerR.pan.value = 1;
            filter.type = 'lowpass';
            filter.Q.value = 1;
            filter.frequency.setValueAtTime(200, time);
            filter.frequency.linearRampToValueAtTime(1500, time + sixteenth * 64);
            filter.frequency.linearRampToValueAtTime(200, time + sixteenth * 128);
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.2, time + sixteenth * 4);
            gain.gain.setValueAtTime(0.2, time + sixteenth * 120);
            gain.gain.linearRampToValueAtTime(0, time + sixteenth * 128);
            oscL.connect(pannerL).connect(filter);
            oscR.connect(pannerR).connect(filter);
            filter.connect(gain).connect(this.masterGain);
            oscL.start(time);
            oscL.stop(time + sixteenth * 128);
            oscR.start(time);
            oscR.stop(time + sixteenth * 128);
            this.bgmOscillators.push(oscL, oscR, pannerL, pannerR, filter, gain);
        };
        const createSequence2 = (time, note) => {
            const osc = this.ctx.createOscillator(),
                panner = this.ctx.createStereoPanner(),
                gain = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.7;
            osc.type = 'sine';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.45, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 1.5);
            osc.connect(panner).connect(gain).connect(this.masterGain);
            osc.start(time);
            osc.stop(time + sixteenth * 1.5);
            this.bgmOscillators.push(osc, panner, gain);
        };
        const createSequence3 = (time, note) => {
            const osc = this.ctx.createOscillator(),
                panner = this.ctx.createStereoPanner(),
                gain = this.ctx.createGain(),
                delay = this.ctx.createDelay(),
                feedback = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.9;
            osc.type = 'triangle';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 2);
            delay.delayTime.value = sixteenth * 4;
            feedback.gain.value = 0.5;
            osc.connect(panner).connect(gain);
            gain.connect(this.masterGain);
            gain.connect(delay);
            delay.connect(feedback).connect(delay);
            delay.connect(this.masterGain);
            osc.start(time);
            osc.stop(time + sixteenth * 2);
            this.bgmOscillators.push(osc, panner, gain, delay, feedback);
        };
        const createSequence4 = (time, note) => {
            const osc = this.ctx.createOscillator(),
                panner = this.ctx.createStereoPanner(),
                gain = this.ctx.createGain(),
                delay = this.ctx.createDelay(),
                feedback = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.9;
            osc.type = 'sine';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.35, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 3.5);
            delay.delayTime.value = sixteenth * 3;
            feedback.gain.value = 0.4;
            osc.connect(panner).connect(gain);
            gain.connect(this.masterGain);
            gain.connect(delay);
            delay.connect(feedback).connect(delay);
            delay.connect(this.masterGain);
            osc.start(time);
            osc.stop(time + sixteenth * 3.5);
            this.bgmOscillators.push(osc, panner, gain, delay, feedback);
        };
        const createSequence5 = (time, note) => {
            const osc = this.ctx.createOscillator(),
                panner = this.ctx.createStereoPanner(),
                gain = this.ctx.createGain(),
                delay = this.ctx.createDelay(),
                feedback = this.ctx.createGain();
            panner.pan.value = (Math.random() * 2 - 1) * 0.9;
            osc.type = 'triangle';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + sixteenth * 4);
            delay.delayTime.value = sixteenth * 6;
            feedback.gain.value = 0.4;
            osc.connect(panner).connect(gain);
            gain.connect(this.masterGain);
            gain.connect(delay);
            delay.connect(feedback).connect(delay);
            delay.connect(this.masterGain);
            osc.start(time);
            osc.stop(time + sixteenth * 4);
            this.bgmOscillators.push(osc, panner, gain, delay, feedback);
        };

        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
            const beatInLoop = this.current16th % 128;
            const noteInMeasure = beatInLoop % 16;

            if (noteInMeasure === 0) {
                this.barTrigger = true;
            }
            if (noteInMeasure % 4 === 0) {
                createKick(this.nextNoteTime);
                visualBeat = 1.0;
            }
            if (noteInMeasure === 4 || noteInMeasure === 12) {
                createSnare(this.nextNoteTime);
            }
            if (noteInMeasure % 2 === 1) {
                createHiHat(this.nextNoteTime, false);
            }
            if (noteInMeasure === 14) {
                createHiHat(this.nextNoteTime, true);
            }
            if (beatInLoop === 0) {
                createStereoPad(this.nextNoteTime, rootNote * 2);
            }

            const measureIn8BarLoop = Math.floor(beatInLoop / 16);
            if (measureIn8BarLoop % 2 === 0) {
                if ([0, 8].includes(noteInMeasure)) {
                    createStereoBass(this.nextNoteTime, rootNote);
                }
            } else {
                if ([0, 6, 10, 14].includes(noteInMeasure)) {
                    createStereoBass(this.nextNoteTime, rootNote);
                }
            }

            if ([3, 7, 10, 15].includes(noteInMeasure)) {
                createSequence(this.nextNoteTime, [rootNote * 8, rootNote * 16][Math.floor(Math.random() * 2)]);
            }

            if (bgmStage >= 2) {
                if (noteInMeasure % 4 === 0) {
                    const degree = [0, 7, 3, 5][Math.floor(noteInMeasure / 4)];
                    createSequence2(this.nextNoteTime, rootNote * 8 * Math.pow(2, degree / 12));
                }
            }
            if (bgmStage >= 3) {
                if (beatInLoop === 62) {
                    const chordIndex = 1;
                    const chordRootDegree = this.seq3ChordProgression[chordIndex];
                    const note = rootNote * 16 * Math.pow(2, (chordRootDegree + 7) / 12);
                    createSequence3(this.nextNoteTime, note);
                }
                if (beatInLoop === 126) {
                    const chordIndex = 3;
                    const chordRootDegree = this.seq3ChordProgression[chordIndex];
                    const note = rootNote * 16 * Math.pow(2, (chordRootDegree + 2) / 12);
                    createSequence3(this.nextNoteTime, note);
                }
            }
            if (bgmStage >= 4) {
                if (beatInLoop % 8 === 0) {
                    const degree = this.seq4Melody[this.seq4MelodyIndex];
                    const note = rootNote * 16 * Math.pow(2, degree / 12);
                    createSequence4(this.nextNoteTime, note);
                    this.seq4MelodyIndex = (this.seq4MelodyIndex + 1) % this.seq4Melody.length;
                }
            }
            if (bgmStage >= 5) {
                if (beatInLoop % 4 === 0) {
                    const degree = this.seq5Melody[this.seq5MelodyIndex];
                    if (degree !== null) {
                        const note = rootNote * 8 * Math.pow(2, degree / 12);
                        createSequence5(this.nextNoteTime, note);
                    }
                    this.seq5MelodyIndex = (this.seq5MelodyIndex + 1) % this.seq5Melody.length;
                }
            }

            this.nextNoteTime += sixteenth;
            this.current16th = (this.current16th + 1) % 128;
        }
    }
    
    stopBgm() {
        this.bgmPlaying = false;
        this.bgmOscillators.forEach(o => { try { o.disconnect(); if(o.stop) o.stop(0); } catch(e){} });
        this.bgmOscillators = [];
    }
    
    playSound(type) {
        if (!this.isInitialized || this.isMuted) return;
        const now = this.ctx.currentTime;
        switch (type) {
            case 'itemGet': this.createSound(1046, 0.05, "triangle", 0.8, 0.7, now); setTimeout(() => this.createSound(1396, 0.1, "triangle", 0.7, 0.7, now + 0.08), 80); break;
            case 'waveClear': setTimeout(() => this.createSound(523, 0.1, 'sine', 0.9, 0.5, now), 0); setTimeout(() => this.createSound(659, 0.1, 'sine', 0.9, 0.5, now + 0.1), 100); setTimeout(() => this.createSound(783, 0.1, 'sine', 0.9, 0.5, now + 0.2), 200); setTimeout(() => this.createSound(1046, 0.2, 'sine', 0.8, 0.6, now + 0.3), 300); break;
            case 'start': [261.63, 329.63, 392].forEach((f, i) => this.createSound(f, 0.1, 'square', 0.9, 0.4, now + i * 0.08)); break;
            case 'glaze': this.createSound(880, 0.1, 'triangle', 0.8, 0.5, now, true); break;
            case 'explosion': const b = this.ctx.sampleRate * 0.5; const buf = this.ctx.createBuffer(1, b, this.ctx.sampleRate); const o = buf.getChannelData(0); for (let i = 0; i < b; i++) o[i] = Math.random() * 2 - 1; const s = this.ctx.createBufferSource(); s.buffer = buf; const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.setValueAtTime(2000, now); f.frequency.exponentialRampToValueAtTime(100, now + 0.3); const g = this.ctx.createGain(); g.gain.setValueAtTime(0.7, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.4); s.connect(f).connect(g).connect(this.masterGain); s.start(now); s.stop(now + 0.5); break;
            case 'invincibleHit': this.createSound(1568, 0.1, 'sine', 0.8, 0.8, now); setTimeout(() => this.createSound(2093, 0.15, 'sine', 0.7, 0.8, now + 0.07), 70); break;
        }
    }
    
    playJingle(type) {
        if (!this.isInitialized || this.isMuted) return;
        const now = this.ctx.currentTime;
        switch(type) {
            case 'gameOver': this.createSound(220, 0.8, 'sawtooth', 0.2, 0.8, now); setTimeout(() => this.createSound(110, 0.8, 'sawtooth', 0.4, 0.8, now + 0.1), 100); setTimeout(() => this.createSound(55, 0.8, 'sawtooth', 0.6, 0.8, now + 0.2), 200); break;
            case 'specialItemGet': [1046, 1318, 1567, 2093].forEach((f, i) => { this.createSound(f, 0.15, 'triangle', 0.8, 0.6, now + i * 0.07); }); break;
        }
    }

    toggleMute() {
        if (!this.isInitialized) return;
        this.isMuted = !this.isMuted;
        this.masterGain.gain.setValueAtTime(this.isMuted ? 0 : this.volume, this.ctx.currentTime);
        return this.isMuted;
    }
}

// ---------------------------------
// ゲームのメインロジック
// ---------------------------------
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const offscreenCanvas = document.createElement('canvas');
offscreenCanvas.width = config.canvasWidth;
offscreenCanvas.height = config.canvasHeight;
const offscreenCtx = offscreenCanvas.getContext('2d');

const audioHandler = new AudioHandler();
const instructionsContainer = document.getElementById('instructions-container');
const mainInstruction = document.getElementById('main-instruction');
const extraInstruction = document.getElementById('extra-instruction');
const controlsInstruction = document.getElementById('controls-instruction');
const soundToggleButton = document.getElementById('sound-toggle-button');

let gameState = 'title', score = 0, highScore = localStorage.getItem(config.highScoreKey) || 0, frameCount = 0;
const input = { left: false, right: false, slow: false, startTrigger: false, pauseTrigger: false, quitTrigger: false, upTrigger: false, downTrigger: false, confirmTrigger: false, backTrigger: false };
let wasStartPressed = false, wasPPressed = false, wasQPressed = false;
let wasGpUpPressed = false, wasGpDownPressed = false, wasGpConfirmPressed = false, wasGpBackPressed = false;
let player, comets, stars, particles, effects, items, scoreTexts;
let currentCometSpeed, lastInputDevice = 'keyboard';
let stage, stageClearFrame, currentThemeIndex;
let energy, nextItemScore, nextSpecialItemScore, newHighScoreAchieved;
let elapsedTime, lastTimestamp;
let visualBeat = 0;
let nextWayShotFrame;
let isInvincible = false, hasUsedInvincibility = false;
let wasMPressed = false;
let hasSpawned5000PointItem;
let gameOverReason = '';
let screenShake = { intensity: 0, duration: 0 };
let grayscaleAnimation = { progress: 0, duration: 1.0, isActive: false };
let chainCount = 0;
let chainEffectPending = false;

// オンラインランキング関連の変数
const selectableChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ';
let onlineHighScores = [];
let rankingStatus = 'loading'; // 'loading', 'loaded', 'error'
let playerName = "";
let nameEntryCursorBlink = 0;
let nameEntrySelectedCharIndex = 0;

function hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }

function applyThemeStyles(theme) {
    const borderAlpha = 0.7 + visualBeat * 0.3;
    const shadowSize = 15 + visualBeat * 20;
    canvas.style.borderColor = hexToRgba(theme.ui, borderAlpha);
    canvas.style.boxShadow = `0 0 ${shadowSize}px ${theme.ui}`;
    instructionsContainer.style.color = theme.ui;
    instructionsContainer.style.textShadow = `0 0 10px ${theme.ui}`;
    soundToggleButton.style.color = theme.ui;
    soundToggleButton.style.textShadow = `0 0 5px ${theme.ui}`;
    soundToggleButton.style.borderColor = theme.ui;
    soundToggleButton.style.boxShadow = `0 0 10px ${theme.ui}`;
    soundToggleButton.style.setProperty('--button-hover-bg', hexToRgba(theme.ui, 0.2));
}

// オンラインランキングAPI通信関数
async function fetchHighScores() {
    if (!RANKING_CONFIG.API_ENDPOINT.startsWith('https://')) {
        rankingStatus = 'error';
        console.error("API_ENDPOINTが正しく設定されていません。");
        return;
    }
    rankingStatus = 'loading';
    try {
        const query = `query GetScores { scores(limit: 10, order_by: {score: desc}) { name score } }`;
        const response = await fetch(RANKING_CONFIG.API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query })
        });
        if (!response.ok) throw new Error(`Network response was not ok (${response.status})`);
        const json = await response.json();
        if (json.errors) throw new Error(json.errors[0].message);
        onlineHighScores = json.data.scores;
        rankingStatus = 'loaded';
    } catch (error) {
        console.error("Failed to fetch high scores:", error);
        rankingStatus = 'error';
    }
}

async function submitHighScore(name, score) {
    if (!RANKING_CONFIG.API_ENDPOINT.startsWith('https://')) return;
    try {
        const mutation = `mutation InsertScore($name: String!, $score: bigint!) { insert_scores_one(object: {name: $name, score: $score}) { id } }`;
        await fetch(RANKING_CONFIG.API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: mutation, variables: { name, score } })
        });
        await fetchHighScores(); // 送信成功後、ランキングを再取得
    } catch (error) {
        console.error("Failed to submit high score:", error);
    }
}

function submitAndSaveName(name) {
    const finalName = name.padEnd(3, ' ');
    localStorage.setItem(config.lastPlayerNameKey, finalName.trim());
    submitHighScore(finalName, score).then(() => {
        gameState = 'gameOver';
    });
}

function init() {
    player = { x: config.canvasWidth / 2, y: config.canvasHeight - 80, radius: config.playerHitboxRadius, invincibleTimer: 0, maxInvincibleTimer: 0 };
    comets = []; particles = []; effects = []; items = []; scoreTexts = [];
    stars = Array.from({ length: config.starCount }, () => ({ x: Math.random()*config.canvasWidth, y:Math.random()*config.canvasHeight, width:Math.random()*1.5+1, length:Math.random()*10+5, speed:Math.random()*20+10, isGlazed:false, }));
    score = 0; frameCount = 0; elapsedTime = 0; lastTimestamp = 0;
    currentCometSpeed = config.initialCometSpeed;
    stage = 1; stageClearFrame = STAGE_LENGTH_IN_FRAMES; currentThemeIndex = 0;
    energy = config.energyTotal; nextItemScore = config.energyItemScoreNormal; nextSpecialItemScore = config.energyItemScoreSpecial; newHighScoreAchieved = false;
    nextWayShotFrame = (2 + Math.random() * 2) * 60;
    isInvincible = false; hasUsedInvincibility = false; hasSpawned5000PointItem = false;
    gameOverReason = '';
    screenShake = { intensity: 0, duration: 0 };
    grayscaleAnimation = { progress: 0, duration: 1.0, isActive: false };
    chainCount = 0; chainEffectPending = false;
    highScore = localStorage.getItem(config.highScoreKey) || 0;
    playerName = "";
    nameEntrySelectedCharIndex = 0;
    fetchHighScores();
    canvas.style.filter = 'none'; canvas.style.webkitFilter = 'none';
    applyThemeStyles(themes[currentThemeIndex]);
}

function startGame() {
    init();
    gameState = 'playing';
    audioHandler.playSound('start');
    audioHandler.playBgm();
}

function updateInstructions() {
    const pauseText = lastInputDevice === 'keyboard' ? 'PAUSE: P' : 'PAUSE: START';
    mainInstruction.textContent = `${pauseText} / FULLSCREEN: F`;
    extraInstruction.textContent = 'ENERGY BOX @ 10,000 PTS';
    const moveText = lastInputDevice === 'keyboard' ? 'MOVE: ARROWS' : 'MOVE: PAD';
    const slowText = lastInputDevice === 'keyboard' ? 'SLOW: Z/SHIFT' : 'SLOW: BUTTON';
    controlsInstruction.textContent = `${moveText} | ${slowText}`;
}

function pollInput() {
    const gamepads = navigator.getGamepads();
    let gpLeft = false, gpRight = false, gpStart = false, gpSlow = false, gpSelect = false;
    let gpUp = false, gpDown = false, gpConfirm = false, gpBack = false;

    for (const gp of gamepads) {
        if (!gp) continue;
        if (gp.buttons.some(b => b.pressed) || gp.axes.some(a => Math.abs(a) > 0.1)) lastInputDevice = 'gamepad';
        gpLeft = gp.buttons[14]?.pressed || gp.axes[0] < -0.5;
        gpRight = gp.buttons[15]?.pressed || gp.axes[0] > 0.5;
        gpUp = gp.buttons[12]?.pressed || gp.axes[1] < -0.5;
        gpDown = gp.buttons[13]?.pressed || gp.axes[1] > 0.5;
        gpStart = gp.buttons[9]?.pressed;
        gpConfirm = gp.buttons[0]?.pressed; // A button
        gpBack = gp.buttons[1]?.pressed; // B button
        gpSlow = gp.buttons[2]?.pressed || gp.buttons[3]?.pressed || gp.buttons[6]?.pressed || gp.buttons[7]?.pressed;
        gpSelect = gp.buttons[8]?.pressed;
    }
    input.left = keyState['ArrowLeft'] || gpLeft;
    input.right = keyState['ArrowRight'] || gpRight;
    input.slow = keyState['Shift'] || keyState['z'] || keyState['Z'] || gpSlow;
    
    const isStartPressed = keyState['Enter'] || gpStart;
    input.startTrigger = isStartPressed && !wasStartPressed;
    wasStartPressed = isStartPressed;
    
    const isPPressed = keyState['p'] || keyState['P'];
    input.pauseTrigger = (isPPressed && !wasPPressed) || (input.startTrigger && lastInputDevice === 'gamepad' && (gameState === 'playing' || gameState === 'paused'));
    wasPPressed = isPPressed;

    const isQPressed = keyState['q'] || keyState['Q'];
    input.quitTrigger = (isQPressed && !wasQPressed) || gpSelect;
    wasQPressed = isQPressed;

    // Name entry controls
    const isGpUpPressed = keyState['ArrowUp'] || gpUp;
    input.upTrigger = isGpUpPressed && !wasGpUpPressed;
    wasGpUpPressed = isGpUpPressed;

    const isGpDownPressed = keyState['ArrowDown'] || gpDown;
    input.downTrigger = isGpDownPressed && !wasGpDownPressed;
    wasGpDownPressed = isGpDownPressed;

    const isGpConfirmPressed = gpConfirm;
    input.confirmTrigger = isGpConfirmPressed && !wasGpConfirmPressed;
    wasGpConfirmPressed = isGpConfirmPressed;

    const isGpBackPressed = gpBack;
    input.backTrigger = isGpBackPressed && !wasGpBackPressed;
    wasGpBackPressed = isGpBackPressed;
}

function toggleInvincibility() {
    isInvincible = !isInvincible;
    if (isInvincible) { hasUsedInvincibility = true; } 
    else {
        let shouldGameOver = false;
        if (energy <= 0) shouldGameOver = true;
        for (const c of comets) {
            const dx = player.x - c.x, dy = player.y - c.y;
            if (Math.sqrt(dx*dx + dy*dy) < player.radius + c.radius) { shouldGameOver = true; break; }
        }
        if (shouldGameOver) gameOver('collision');
    }
}

function gameOver(reason) {
    if (gameState === 'gameOver' || gameState === 'nameEntry') return;
    
    gameOverReason = reason;
    audioHandler.stopBgm();
    
    const isTopTen = onlineHighScores.length < 10 || (onlineHighScores.length > 0 && score > onlineHighScores[onlineHighScores.length - 1].score);

    //if (score > 0 && isTopTen && score > highScore) {
    if (score > 0 && isTopTen) {
        gameState = 'nameEntry';
        playerName = "";
        nameEntryCursorBlink = 0;
        nameEntrySelectedCharIndex = 0;
    } else {
        gameState = 'gameOver';
    }
    
    audioHandler.playJingle('gameOver');
    
    if (reason === 'collision') {
        audioHandler.playSound('explosion');
        screenShake = { intensity: 25, duration: 45 };
        effects.push({ type: 'shockwave', x: player.x, y: player.y, life: 30, maxLife: 30, radius: 20 });
        effects.push({ type: 'screenFlash', life: 15, maxLife: 15 });
        for (let i = 0; i < 350; i++) { const angle = Math.random() * Math.PI * 2, speed = (Math.random() * 15 + 5) * 60, theme = themes[currentThemeIndex], color = [theme.player, theme.comet, theme.ui, '#ff3344', '#ffff00', '#ffffff'][Math.floor(Math.random() * 6)]; particles.push({ x: player.x, y: player.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: Math.random() * 100 + 80, maxLife: 180, color: color, size: Math.random() * 3.5 + 1.5, gravityMultiplier: Math.random() * 0.6 + 0.7, }); }
    } else if (reason === 'energy') {
        effects.push({ type: 'energyGameOverFlash', life: 8, maxLife: 8 });
        grayscaleAnimation.isActive = true;
        grayscaleAnimation.progress = 0;
    }

    if (score > highScore) {
        highScore = score;
        localStorage.setItem(config.highScoreKey, highScore);
        newHighScoreAchieved = true;
    }
}

function spawnWayComets() { const wayCount = Math.floor(Math.random() * (stage - 1)) + 2, startX = Math.random() * config.canvasWidth, startY = -config.cometCoreRadius * 2, targetX = player.x, targetY = player.y, angleToPlayer = Math.atan2(targetY - startY, targetX - startX), speed = currentCometSpeed * 0.75, spreadAngle = Math.PI / 8, totalAngle = spreadAngle * (wayCount - 1), startAngle = angleToPlayer - totalAngle / 2; for (let i = 0; i < wayCount; i++) { const angle = startAngle + i * spreadAngle; comets.push({ x: startX, y: startY, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: config.cometCoreRadius, isGlazed: false, isWay: true }); } }

function updateBackground(dt_sec) { let speedRatio = 0; if (gameState === 'playing') speedRatio = (currentCometSpeed / config.initialCometSpeed); else if (gameState === 'title') speedRatio = 0.3; if (speedRatio > 0) { stars.forEach(s => { s.y += s.speed * config.starScrollMultiplier * speedRatio * dt_sec; if (s.y > config.canvasHeight) { s.y = 0; s.x = Math.random()*config.canvasWidth; s.isGlazed = false; } }); } }

function updatePlayingState(dt_sec) {
    if (audioHandler.barTrigger) {
        effects.push({ type: 'barLine', life: 30, maxLife: 30 });
        audioHandler.barTrigger = false;
    }
    if (player.invincibleTimer > 0) {
        player.invincibleTimer -= 60 * dt_sec;
        if (player.invincibleTimer <= 0) {
            player.invincibleTimer = 0;
            if (chainCount > 1) {
                effects.push({ type: 'comboFadeOut', life: 12, maxLife: 12, count: chainCount });
            }
            chainCount = 0;
        }
    }
    const isPlayerTemporarilyInvincible = player.invincibleTimer > 0;
    const isPlayerInvincible = isInvincible || isPlayerTemporarilyInvincible;
    let currentSpeed = (input.slow ? config.playerSpeed * config.playerSlowModeMultiplier : config.playerSpeed) * dt_sec;
    if (player.invincibleTimer > 0) currentSpeed *= 1.1;
    if (input.left) player.x -= currentSpeed;
    if (input.right) player.x += currentSpeed;
    player.x = Math.max(0, Math.min(config.canvasWidth, player.x));
    const stageMultiplier = Math.pow(1.1, stage - 1);
    score += Math.floor(config.distanceScoreMultiplier * (currentCometSpeed / config.initialCometSpeed) * stageMultiplier);
    currentCometSpeed += config.cometSpeedIncrease * dt_sec;
    energy -= 0.9 * Math.pow(1.18, stage - 1) * 60 * dt_sec;
    if (energy <= 0 && !isPlayerInvincible) {
        gameOver('energy');
        return;
    }
    if (frameCount >= stageClearFrame) {
        stage++;
        currentThemeIndex = (currentThemeIndex + 1) % themes.length;
        stageClearFrame += STAGE_LENGTH_IN_FRAMES;
        effects.push({ type: 'stageClear', text: `STAGE ${stage} START`, life: 120, maxLife: 120 });
        audioHandler.playSound('waveClear');
    }
    if (stage >= 2 && frameCount >= nextWayShotFrame) {
        spawnWayComets();
        nextWayShotFrame = frameCount + Math.max(3, 10 - stage) * 15 * (0.5 + Math.random());
    }
    const comboMultiplier = chainCount > 1 ? Math.pow(1.1, chainCount - 1) : 1,
        totalMultiplier = stageMultiplier * comboMultiplier,
        currentNormalThreshold = config.energyItemScoreNormal * totalMultiplier,
        currentSpecialThreshold = config.energyItemScoreSpecial * totalMultiplier;
    if (!hasSpawned5000PointItem && score >= 5000) {
        items.push({ x: Math.random() * config.canvasWidth, y: -20, type: 'normal' });
        hasSpawned5000PointItem = true;
    }
    while (score >= nextSpecialItemScore) {
        items.push({ x: Math.random() * config.canvasWidth, y: -20, type: 'special' });
        nextSpecialItemScore += currentSpecialThreshold;
        nextItemScore = Math.floor(score / currentNormalThreshold) * currentNormalThreshold + currentNormalThreshold;
    }
    while (score >= nextItemScore) {
        if (nextItemScore < nextSpecialItemScore) {
            items.push({ x: Math.random() * config.canvasWidth, y: -20, type: 'normal' });
        }
        nextItemScore += currentNormalThreshold;
    }
    const spawnInterval = Math.max(3, Math.floor(config.cometSpawnInterval / (1 + (stage - 1) * 0.2)));
    if (frameCount % spawnInterval === 0) {
        for (let i = 0; i < config.cometSpawnAmount; i++) {
            comets.push({ x: Math.random() * config.canvasWidth, y: -config.cometCoreRadius, radius: config.cometCoreRadius, isGlazed: false });
        }
    }
    for (let i = comets.length - 1; i >= 0; i--) {
        const c = comets[i];
        if (c.vx !== undefined) {
            c.x += c.vx * dt_sec;
            c.y += c.vy * dt_sec;
        } else {
            c.y += currentCometSpeed * (1 + (stage - 1) * 0.08) * dt_sec;
        }
        if (c.y - c.radius > config.canvasHeight || c.x < -c.radius || c.x > config.canvasWidth + c.radius) {
            comets.splice(i, 1);
            continue;
        }
        const dx = player.x - c.x,
            dy = player.y - c.y,
            d = Math.sqrt(dx * dx + dy * dy);
        if (isPlayerInvincible) {
            if (d < config.playerVisualSize + c.radius) {
                const bonusScore = Math.floor(1500 * stageMultiplier * (chainCount > 1 ? Math.pow(1.1, chainCount - 1) : 1));
                score += bonusScore;
                scoreTexts.push({
                    x: player.x,
                    y: player.y - (player.radius + (player.invincibleTimer > 0 ? config.glazeDistance * 1.5 : config.glazeDistance)) - 15,
                    text: `+${bonusScore}`,
                    life: 60,
                    type: 'bonus'
                });
                audioHandler.playSound('invincibleHit');
                comets.splice(i, 1);
                continue;
            }
        } else {
            if (d < player.radius + c.radius) {
                gameOver('collision');
                return;
            }
        }
        const currentGlazeDistance = player.invincibleTimer > 0 ? config.glazeDistance * 1.5 : config.glazeDistance;
        if (!c.isGlazed && d < player.radius + c.radius + currentGlazeDistance) {
            c.isGlazed = true;
            const points = Math.floor(config.glazeScore * stageMultiplier);
            score += points;
            scoreTexts.push({ x: c.x, y: c.y, text: `+${points}`, life: 60, type: 'glaze' });
            audioHandler.playSound('glaze');
        }
    }
    items.forEach((item, index) => {
        item.y += config.energyItemSpeed * dt_sec;
        if (Math.sqrt(Math.pow(player.x - item.x, 2) + Math.pow(player.y - item.y, 2)) < config.playerVisualSize + config.energyItemSize) {
            if (player.invincibleTimer > 0) {
                chainCount++;
                effects.push({ type: 'chainComboUpdate', life: 60, maxLife: 60 });
                chainEffectPending = true;
            } else {
                chainCount = 1;
            }
            const timeReductionMultiplier = Math.pow(0.9, Math.floor((chainCount - 1) / 3));
            const newItemInvincibleFrames = Math.floor(((item.type === 'special') ? 150 : 90) * timeReductionMultiplier);
            player.invincibleTimer = (player.invincibleTimer > 0 ? Math.max(player.invincibleTimer, newItemInvincibleFrames) + 30 * timeReductionMultiplier : newItemInvincibleFrames);
            player.maxInvincibleTimer = player.invincibleTimer;
            if (item.type === 'special') {
                energy = config.energyTotal;
                audioHandler.playJingle('specialItemGet');
            } else {
                energy += config.energyTotal * 0.5;
                audioHandler.playSound('itemGet');
            }
            energy = Math.min(config.energyTotal, energy);
            effects.push({ type: 'textMorph', life: player.invincibleTimer, maxLife: player.invincibleTimer });
            items.splice(index, 1);
            return;
        }
        if (item.y > config.canvasHeight + 20) items.splice(index, 1);
    });
    scoreTexts.forEach((st, i) => {
        st.life--;
        st.y -= 0.5;
        if (st.life <= 0) scoreTexts.splice(i, 1);
    });
}

function updateNameEntryState() {
    nameEntryCursorBlink = (nameEntryCursorBlink + 1) % 60;

    // Controller input for name entry
    if (lastInputDevice === 'gamepad') {
        if (input.upTrigger) {
            nameEntrySelectedCharIndex = (nameEntrySelectedCharIndex - 1 + selectableChars.length) % selectableChars.length;
        }
        if (input.downTrigger) {
            nameEntrySelectedCharIndex = (nameEntrySelectedCharIndex + 1) % selectableChars.length;
        }
        if (input.backTrigger) {
            playerName = playerName.slice(0, -1);
        }
        if (input.confirmTrigger) {
            if (playerName.length < 3) {
                playerName += selectableChars[nameEntrySelectedCharIndex];
                nameEntrySelectedCharIndex = 0; // Reset for next character
            } else {
                 // Already 3 chars, A button confirms the name
                submitAndSaveName(playerName);
            }
        }
    }
}

function update(timestamp) {
    if (gameState !== 'paused') {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const dt_sec = Math.min((timestamp - lastTimestamp) / 1000, 1/30);
        lastTimestamp = timestamp;
        
        pollInput(); 
        updateInstructions();
        
        if (screenShake.duration > 0) {
            screenShake.duration--;
            if (screenShake.duration <= 0) screenShake.intensity = 0;
        }
        if (grayscaleAnimation.isActive && grayscaleAnimation.progress < 1) {
            grayscaleAnimation.progress = Math.min(1, grayscaleAnimation.progress + dt_sec / 1.0);
        }
        
        if (gameState === 'playing' && input.pauseTrigger) {
            gameState = 'paused';
            audioHandler.masterGain.gain.exponentialRampToValueAtTime(0.001, audioHandler.ctx.currentTime + 0.2);
            return;
        }

        const isMPressed = keyState['m'] || keyState['M'];
        if (isMPressed && !wasMPressed && gameState === 'playing') {
            toggleInvincibility();
        }
        wasMPressed = isMPressed;

        const previousVisualBeat = visualBeat;
        visualBeat *= 0.85;
        if (visualBeat < 0.01) visualBeat = 0;
        
        if (gameState === 'playing' || gameState === 'title' || gameState === 'gameOver') {
            updateBackground(dt_sec);
        }
        
        particles.forEach((p, i) => {
            p.life--;
            if (p.life <= 0) {
                particles.splice(i, 1);
            } else {
                if (p.gravityMultiplier) p.vy += config.gravity * p.gravityMultiplier * dt_sec;
                p.x += p.vx * dt_sec;
                p.y += p.vy * dt_sec;
            }
        });

        effects.forEach((e, i) => {
            e.life--;
            if (e.life <= 0) effects.splice(i, 1);
        });
        
        if (gameState === 'playing') {
            frameCount++;
            audioHandler.scheduleBGM();
            elapsedTime += (timestamp - lastTimestamp);
            updatePlayingState(dt_sec);
            if (chainEffectPending && visualBeat >= 1.0 && previousVisualBeat < 1.0) {
                effects.push({ type: 'shockwave', x: 150, y: 65, life: 20, maxLife: 20, radius: 20 });
                effects.push({ type: 'screenFlash', life: 8, maxLife: 8 });
                chainEffectPending = false;
            }
        } else if (gameState === 'title' && input.startTrigger) {
            audioHandler.initialize();
            startGame();
        } else if (gameState === 'gameOver' && input.startTrigger) {
            gameState = 'title';
            init();
        } else if (gameState === 'nameEntry') {
            updateNameEntryState();
             if (input.startTrigger) { // Use last name with START button
                const lastName = localStorage.getItem(config.lastPlayerNameKey) || 'AAA';
                submitAndSaveName(lastName);
            }
        }
    } else { // paused
        pollInput();
        updateInstructions();
        if (input.pauseTrigger) {
            gameState = 'playing';
            lastTimestamp = 0;
            if (!audioHandler.isMuted) audioHandler.masterGain.gain.exponentialRampToValueAtTime(audioHandler.volume, audioHandler.ctx.currentTime + 0.2);
        } else if (input.quitTrigger) {
            audioHandler.stopBgm();
            if (audioHandler.masterGain && !audioHandler.isMuted) audioHandler.masterGain.gain.setValueAtTime(audioHandler.volume, audioHandler.ctx.currentTime);
            gameState = 'title';
            init();
        }
    }
}

function drawRoundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) {
        r = w / 2;
    }
    if (h < 2 * r) {
        r = h / 2;
    }
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}

function drawWithGlow(ctx, drawFunc, color, useBeat = false) {
    const blurAmount = useBeat ? (config.glowBlur + visualBeat * 8) : config.glowBlur;
    ctx.shadowColor = color;
    ctx.shadowBlur = blurAmount;
    drawFunc();
    ctx.shadowBlur = 0;
}

function drawGrid(ctx, color) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.globalAlpha = 0.06 + visualBeat * 0.04;
    ctx.lineWidth = 1;
    for (let i = 0; i < config.canvasHeight; i += 20) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(config.canvasWidth, i);
        ctx.stroke();
    }
    for (let i = 0; i < config.canvasWidth; i += 20) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, config.canvasHeight);
        ctx.stroke();
    }
    ctx.restore();
}

function drawPixelArt(ctx, artData, centerX, centerY, pixelSize, palette) {
    const artHeight = artData.length;
    const artWidth = artData[0].length;
    const totalWidth = artWidth * pixelSize;
    const totalHeight = artHeight * pixelSize;
    const startX = centerX - totalWidth / 2;
    const startY = centerY - totalHeight / 2;

    for (let r = 0; r < artHeight; r++) {
        for (let c = 0; c < artWidth; c++) {
            const colorCode = artData[r][c];
            if (colorCode !== 0) {
                ctx.fillStyle = palette[colorCode];
                ctx.fillRect(startX + c * pixelSize, startY + r * pixelSize, pixelSize, pixelSize);
            }
        }
    }
}

function drawPlayer(ctx, color) {
    const pixelSize = 2;
    const palette = { '1': color, '2': '#ffffff', '3': '#ffff00' };
    drawWithGlow(ctx, () => {
        drawPixelArt(ctx, PLAYER_PIXEL_ART, player.x, player.y, pixelSize, palette);
    }, color, true);

    if (input.slow) {
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(player.x, player.y, PLAYER_PIXEL_ART[0].length * pixelSize * 0.15, 0, Math.PI * 2);
        ctx.fill();
    }
}

function formatTime(ms) {
    if (isNaN(ms)) ms = 0;
    const m = Math.floor(ms / 60000);
    const s = Math.floor((ms % 60000) / 1000);
    const msec = Math.floor(ms % 1000);
    return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}:${String(msec).padStart(3, '0')}`;
}

function drawChainComboText(renderCtx, count, alpha = 1.0) {
    const comboText = `${count} CHAIN COMBO!!`;
    const baseFontSize = 16, sizeStep = 2, maxChainForSizing = 30;
    let fontSize = baseFontSize + Math.floor((Math.min(count, maxChainForSizing) - 1) / 5) * sizeStep;
    const comboEffect = effects.find(e => e.type === 'chainComboUpdate');
    let textToDraw = comboText;

    if (comboEffect && alpha === 1.0) {
        const progress = 1 - (comboEffect.life / comboEffect.maxLife);
        fontSize = fontSize * 1.2 - (fontSize * 0.2) * progress;
        const chars = "!?#$ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        textToDraw = "";
        for (let i = 0; i < comboText.length; i++) {
            if (progress > (i / comboText.length) * 0.5 + (Math.random() * 0.1)) {
                textToDraw += comboText[i];
            } else {
                textToDraw += chars[Math.floor(Math.random() * chars.length)];
            }
        }
    }

    renderCtx.save();
    renderCtx.globalAlpha = alpha;
    renderCtx.font = `${fontSize}px ${config.fontFamily}`;
    renderCtx.textAlign = 'left';
    let currentX = 20;
    for (let i = 0; i < textToDraw.length; i++) {
        const char = textToDraw[i];
        const charWidth = renderCtx.measureText(char).width;
        const hue = (Date.now() / 15 + i * 20) % 360;
        const gamingColor = `hsl(${hue}, 100%, 75%)`;
        drawWithGlow(renderCtx, () => {
            renderCtx.fillStyle = gamingColor;
            renderCtx.fillText(char, currentX, 70);
        }, gamingColor);
        currentX += charWidth;
    }
    renderCtx.restore();
}

function drawBackground(renderCtx) {
    let trailAlpha;
    if (gameState === 'playing' || gameState === 'paused') {
        trailAlpha = Math.min(1.0, 0.15 + (stage - 1) * 0.02);
    } else {
        trailAlpha = 0.4;
    }
    renderCtx.fillStyle = `rgba(0, 0, 10, ${trailAlpha})`;
    renderCtx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);

    const theme = themes[currentThemeIndex];
    drawGrid(renderCtx, theme.grid);

    renderCtx.strokeStyle = '#808080';
    stars.forEach(s => {
        renderCtx.globalAlpha = s.speed / 100;
        renderCtx.lineWidth = s.width;
        renderCtx.beginPath();
        renderCtx.moveTo(s.x, s.y);
        renderCtx.lineTo(s.x, s.y - s.length);
        renderCtx.stroke();
    });
    renderCtx.globalAlpha = 1;
}

function drawRanking(renderCtx, x, y, theme) {
    renderCtx.save();
    renderCtx.textAlign = 'left';
    renderCtx.font = `14px ${config.fontFamily}`;
    drawWithGlow(renderCtx, () => {
        renderCtx.fillStyle = theme.ui;
        renderCtx.fillText("TOP 10 ONLINE", x, y);
    }, theme.ui);

    const textY = y + 30;
    if (rankingStatus === 'loading') {
        drawWithGlow(renderCtx, () => {
            renderCtx.fillStyle = '#aaaaaa';
            renderCtx.fillText("LOADING...", x, textY);
        }, '#aaaaaa');
    } else if (rankingStatus === 'error') {
        drawWithGlow(renderCtx, () => {
            renderCtx.fillStyle = '#ff5555';
            renderCtx.fillText("ERROR LOADING SCORES", x, textY);
        }, '#ff5555');
    } else {
        onlineHighScores.forEach((entry, index) => {
            const line = `${`${index + 1}`.padStart(2, ' ')}. ${entry.name.padEnd(3, ' ')} ${`${entry.score}`.padStart(8, ' ')}`;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = '#ffffff';
                renderCtx.fillText(line, x, textY + (index * 22));
            }, '#ffffff');
        });
    }
    renderCtx.restore();
}

function draw() {
    const renderCtx = offscreenCtx;
    const theme = themes[currentThemeIndex];
    
    drawBackground(renderCtx);
    
    if (gameState === 'playing' || gameState === 'paused' || gameState === 'title') {
        applyThemeStyles(theme);
    }
    
    if (scoreTexts.length > 0) {
        renderCtx.save();
        renderCtx.textAlign = 'center';
        scoreTexts.forEach(st => {
            const alpha = st.life / 60.0;
            const hue = (frameCount * 5 + st.x) % 360;
            const color = `hsla(${hue}, 100%, 70%, ${alpha})`;
            renderCtx.font = `${st.type === 'bonus' ? 14 : 10}px ${config.fontFamily}`;
            renderCtx.globalAlpha = alpha;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = color;
                renderCtx.fillText(st.text, st.x, st.y);
            }, `hsla(${hue}, 100%, 70%, ${alpha/2})`);
        });
        renderCtx.restore();
    }
    
    if (gameState === 'playing' || gameState === 'paused' || gameState === 'gameOver' || particles.length > 0 || comets.length > 0 || items.length > 0) {
        particles.forEach(p => {
            const a = p.life / p.maxLife;
            renderCtx.globalAlpha = a;
            renderCtx.fillStyle = p.color;
            renderCtx.beginPath();
            renderCtx.arc(p.x, p.y, p.size * a, 0, Math.PI * 2);
            renderCtx.fill();
        });
        renderCtx.globalAlpha = 1;
        
        items.forEach(i => {
            const color = i.type === 'special' ? `hsl(${(frameCount * 4) % 360}, 100%, 70%)` : '#00ff88';
            drawWithGlow(renderCtx, () => {
                drawPixelArt(renderCtx, ENERGY_ITEM_PIXEL_ART, i.x, i.y, 2, { '1': '#ffffff', '2': color });
            }, color, true);
        });
        
        comets.forEach(c => {
            const color = c.isGlazed ? '#ffffaa' : (c.isWay ? theme.player : theme.comet);
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = color;
                renderCtx.beginPath();
                renderCtx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
                renderCtx.fill();
            }, color, true);
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = '#ffffff';
                renderCtx.beginPath();
                renderCtx.arc(c.x, c.y, c.radius * 0.6, 0, Math.PI * 2);
                renderCtx.fill();
            }, '#ffffff', true);
        });
    }
    
    if (gameState === 'playing' || gameState === 'paused' || (gameState === 'gameOver' && gameOverReason === 'energy')) {
        const glazeRadius = player.radius + (player.invincibleTimer > 0 ? config.glazeDistance * 1.5 : config.glazeDistance);
        renderCtx.save();
        renderCtx.globalAlpha = 0.04 + visualBeat * 0.04;
        renderCtx.fillStyle = theme.player;
        renderCtx.beginPath();
        renderCtx.arc(player.x, player.y, glazeRadius, 0, Math.PI * 2);
        renderCtx.fill();
        renderCtx.restore();
        
        if (player.invincibleTimer > 0 && !(player.invincibleTimer < 30 && frameCount % 10 < 5)) {
            renderCtx.save();
            renderCtx.globalAlpha = 0.5 + Math.sin(frameCount * 0.2) * 0.2;
            renderCtx.lineWidth = 2;
            renderCtx.strokeStyle = '#FFFFFF';
            drawWithGlow(renderCtx, () => {
                renderCtx.beginPath();
                renderCtx.arc(player.x, player.y, config.playerVisualSize * 1.5, 0, Math.PI * 2);
                renderCtx.stroke();
            }, '#FFFFFF');
            renderCtx.restore();
            
            renderCtx.save();
            const meterRadius = glazeRadius + 5;
            const meterColor = `hsl(${(frameCount * 4) % 360}, 100%, 70%)`;
            renderCtx.lineWidth = 3;
            renderCtx.strokeStyle = meterColor;
            if (!(player.invincibleTimer < 60 && frameCount % 10 < 5)) {
                drawWithGlow(renderCtx, () => {
                    renderCtx.beginPath();
                    renderCtx.arc(player.x, player.y, meterRadius, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * (player.invincibleTimer / player.maxInvincibleTimer));
                    renderCtx.stroke();
                }, meterColor);
            }
            renderCtx.restore();
        }
        
        if (gameState !== 'gameOver' || gameOverReason !== 'collision') {
            drawPlayer(renderCtx, theme.player);
            renderCtx.save();
            renderCtx.fillStyle = `hsla(${(frameCount * 20) % 360}, 100%, 70%, 0.7)`;
            renderCtx.beginPath();
            renderCtx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            renderCtx.fill();
            renderCtx.restore();
        }
    }
    
    drawWithGlow(renderCtx, () => {
        renderCtx.fillStyle = theme.ui;
        const mainSize = 20 + visualBeat * 2;
        const subSize = 18 + visualBeat * 2;
        renderCtx.font = `${mainSize}px ${config.fontFamily}`;
        renderCtx.textAlign = 'left';
        renderCtx.fillText(`SCORE: ${score}`, 20, 40);
        renderCtx.textAlign = 'center';
        renderCtx.fillText(formatTime(elapsedTime), config.canvasWidth / 2, 40);
        if (gameState === 'playing' || gameState === 'paused') {
            renderCtx.font = `${subSize}px ${config.fontFamily}`;
            renderCtx.fillText(`STAGE ${stage}`, config.canvasWidth / 2, config.canvasHeight - 20);
        }
    }, theme.ui, true);
    
    if (chainCount > 1 && player.invincibleTimer > 0) {
        drawChainComboText(renderCtx, chainCount, 1.0);
    }
    
    if (gameState === 'playing' || gameState === 'paused') {
        const barW = 200, barH = 12, x = 20, y = config.canvasHeight - 35, r = 5;
        const energyRatio = energy / config.energyTotal;
        const energyColor = `hsl(${energyRatio * 120}, 100%, 50%)`;
        renderCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        renderCtx.lineWidth = 2;
        drawRoundRect(renderCtx, x, y, barW, barH, r);
        renderCtx.stroke();
        renderCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        drawRoundRect(renderCtx, x, y, barW, barH, r);
        renderCtx.fill();
        if (barW * energyRatio > 0) {
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = energyColor;
                renderCtx.beginPath();
                drawRoundRect(renderCtx, x, y, barW * energyRatio, barH, r);
                renderCtx.fill()
            }, energyColor, true);
        }
        if (player.invincibleTimer > 0) {
            const invBarY = y + barH + 5, invBarH = 6, invRatio = player.invincibleTimer / player.maxInvincibleTimer;
            renderCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            renderCtx.lineWidth = 1;
            drawRoundRect(renderCtx, x, invBarY, barW, invBarH, r - 2);
            renderCtx.stroke();
            renderCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            drawRoundRect(renderCtx, x, invBarY, barW, invBarH, r - 2);
            renderCtx.fill();
            if (barW * invRatio > 0) {
                drawWithGlow(renderCtx, () => {
                    renderCtx.fillStyle = '#FFFFFF';
                    renderCtx.beginPath();
                    drawRoundRect(renderCtx, x, invBarY, barW * invRatio, invBarH, r - 2);
                    renderCtx.fill()
                }, '#FFFFFF', true);
            }
        }
        if (isInvincible) {
            let mutekiY = config.canvasHeight - 50;
            if (player.invincibleTimer > 0) mutekiY = config.canvasHeight - 50 - 12 - 5 - 6;
            const mutekiColor = `hsl(${(frameCount * 3) % 360}, 100%, 70%)`;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = mutekiColor;
                renderCtx.font = `16px ${config.fontFamily}`;
                renderCtx.textAlign = 'left';
                renderCtx.fillText('MUTEKI', 20, mutekiY);
            }, mutekiColor, true);
        }
    }
    
    effects.forEach(e => { /* effect drawing logic can be added here */ });
    
    if (gameState === 'paused') {
        renderCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        renderCtx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);
        const msg = 'PAUSED';
        const resKey = lastInputDevice === 'keyboard' ? 'P' : 'START';
        const quitKey = lastInputDevice === 'keyboard' ? 'Q' : 'SELECT';
        renderCtx.font = `48px ${config.fontFamily}`;
        renderCtx.textAlign = 'center';
        let currentX = config.canvasWidth / 2 - renderCtx.measureText(msg).width / 2;
        for (let i = 0; i < msg.length; i++) {
            const char = msg[i];
            const charW = renderCtx.measureText(char).width;
            const hue = (Date.now() / 15 + i * 30) % 360;
            const color = `hsl(${hue}, 100%, 70%)`;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = color;
                renderCtx.fillText(char, currentX + charW / 2, config.canvasHeight / 2 - 40);
            }, color);
            currentX += charW;
        }
        renderCtx.fillStyle = theme.ui;
        renderCtx.font = `20px ${config.fontFamily}`;
        drawWithGlow(renderCtx, () => {
            renderCtx.fillText(`Press ${resKey} to Resume`, config.canvasWidth / 2, config.canvasHeight / 2 + 30);
            renderCtx.fillText(`Press ${quitKey} to Title`, config.canvasWidth / 2, config.canvasHeight / 2 + 60);
        }, theme.ui, true);
    } else if (gameState !== 'playing') {
        renderCtx.textAlign = 'center';
        if (gameState === 'title') {
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = theme.player;
                renderCtx.font = `60px ${config.fontFamily}`;
                renderCtx.fillText('COMET', config.canvasWidth / 2, config.canvasHeight / 2 - 90);
            }, theme.player);
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = theme.ui;
                renderCtx.font = `16px ${config.fontFamily}`;
                renderCtx.fillText('OUTBURST', config.canvasWidth / 2, config.canvasHeight / 2 - 45);
            }, theme.ui);
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = theme.ui;
                renderCtx.font = `20px ${config.fontFamily}`;
                renderCtx.fillText(`HI-SCORE: ${highScore}`, config.canvasWidth / 2, config.canvasHeight / 2 + 30);
            }, theme.ui);
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = '#ffffff';
                renderCtx.font = `18px ${config.fontFamily}`;
                renderCtx.fillText('Press Enter or Start to Start', config.canvasWidth / 2, config.canvasHeight - 60);
            }, '#ffffff');
            drawRanking(renderCtx, 30, 80, theme);
        } else if (gameState === 'nameEntry') {
            renderCtx.textBaseline = 'middle';
            const color = `hsl(${(frameCount * 3) % 360}, 100%, 70%)`;
            const y = config.canvasHeight / 2 - 120;
            
            drawWithGlow(renderCtx, () => { renderCtx.fillStyle=color; renderCtx.font=`36px ${config.fontFamily}`; renderCtx.fillText('NEW HIGH SCORE!', config.canvasWidth/2, y); }, color);
            drawWithGlow(renderCtx, () => { renderCtx.font=`24px ${config.fontFamily}`; renderCtx.fillStyle=theme.ui; renderCtx.fillText(`SCORE: ${score}`, config.canvasWidth/2, y + 60); }, theme.ui);
            drawWithGlow(renderCtx, () => { renderCtx.font=`20px ${config.fontFamily}`; renderCtx.fillStyle='#ffffff'; renderCtx.fillText('ENTER YOUR NAME (3 CHARS)', config.canvasWidth/2, y + 110); }, '#ffffff');
            
            let displayName = playerName;
            if (lastInputDevice === 'gamepad' && playerName.length < 3) {
                 if (nameEntryCursorBlink < 30) {
                    displayName += selectableChars[nameEntrySelectedCharIndex];
                 } else {
                    displayName += ' ';
                 }
            }
            displayName = displayName.padEnd(3, '_');
            
            renderCtx.font = `48px ${config.fontFamily}`;
            drawWithGlow(renderCtx, () => { renderCtx.fillStyle = '#ffffff'; renderCtx.fillText(displayName, config.canvasWidth / 2, y + 170); }, '#ffffff');

            renderCtx.font = `12px ${config.fontFamily}`;
            renderCtx.fillStyle = '#cccccc';
            if (lastInputDevice === 'keyboard') {
                 drawWithGlow(renderCtx, () => { renderCtx.fillText('TYPE: A-Z 0-9 | DELETE: BACKSPACE', config.canvasWidth/2, y + 230); }, '#cccccc');
                 drawWithGlow(renderCtx, () => { renderCtx.fillText('SUBMIT: ENTER', config.canvasWidth/2, y + 250); }, '#cccccc');
            } else { // gamepad
                 drawWithGlow(renderCtx, () => { renderCtx.fillText('SELECT:UP/DOWN | NEXT:A | BACK:B', config.canvasWidth/2, y + 230); }, '#cccccc');
                 drawWithGlow(renderCtx, () => { renderCtx.fillText('SUBMIT: A (at 3 chars)', config.canvasWidth/2, y + 250); }, '#cccccc');
            }
            drawWithGlow(renderCtx, () => { renderCtx.fillText('EMPTY or START BTN TO USE LAST NAME', config.canvasWidth/2, y + 280); }, '#cccccc');

            renderCtx.textBaseline = 'alphabetic';
        } else { // 'gameOver'
            renderCtx.textBaseline = 'middle';
            const y = 80;
            drawWithGlow(renderCtx, () => {
                renderCtx.fillStyle = '#ff3333';
                renderCtx.font = `60px ${config.fontFamily}`;
                renderCtx.fillText('GAME OVER', config.canvasWidth / 2, y);
            }, '#ff3333');
            if (newHighScoreAchieved) {
                const color = `hsl(${(frameCount * 3) % 360}, 100%, 70%)`;
                drawWithGlow(renderCtx, () => {
                    renderCtx.fillStyle = color;
                    renderCtx.font = `24px ${config.fontFamily}`;
                    renderCtx.fillText('NEW LOCAL RECORD!', config.canvasWidth / 2, y + 50);
                }, color);
            }
            drawWithGlow(renderCtx, () => {
                renderCtx.font = `30px ${config.fontFamily}`;
                renderCtx.fillStyle = theme.ui;
                renderCtx.fillText(`SCORE: ${score}`, config.canvasWidth / 2, y + 90);
            }, theme.ui);
            drawRanking(renderCtx, config.canvasWidth / 2 - 180, y + 140, theme);
            drawWithGlow(renderCtx, () => {
                renderCtx.font = `20px ${config.fontFamily}`;
                renderCtx.fillStyle = '#ffffff';
                renderCtx.fillText('Press Enter or Start to Title', config.canvasWidth / 2, config.canvasHeight - 50);
            }, '#ffffff');
            renderCtx.textBaseline = 'alphabetic';
        }
    }
    
    ctx.save();
    if (screenShake.duration > 0) {
        const intensity = screenShake.intensity * (screenShake.duration / 45);
        ctx.translate((Math.random() - 0.5) * intensity, (Math.random() - 0.5) * intensity);
    }
    if (gameState === 'gameOver' && gameOverReason === 'energy') {
        const p = grayscaleAnimation.progress;
        const filter = `grayscale(${p}) brightness(${1 - p * 0.2})`;
        canvas.style.filter = filter;
        canvas.style.webkitFilter = filter;
    } else if (canvas.style.filter !== 'none') {
        canvas.style.filter = 'none';
        canvas.style.webkitFilter = 'none';
    }
    ctx.drawImage(offscreenCanvas, 0, 0);
    ctx.restore();
    
    if (gameState === 'playing' && player.invincibleTimer > 0 && !(player.invincibleTimer < 30 && frameCount % 10 < 5)) {
        ctx.fillStyle = `rgba(255, 255, 255, 0.05)`;
        ctx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);
    }
}

function gameLoop(timestamp) {
    update(timestamp);
    draw();
    requestAnimationFrame(gameLoop);
}

const keyState = {};
window.addEventListener('keydown', e => {
    keyState[e.key] = true;
    if (e.key !== 'F12' && e.key !== 'F5') { // Prevent browser default actions
        e.preventDefault();
    }
    
    if (lastInputDevice !== 'keyboard' && !e.repeat) {
        lastInputDevice = 'keyboard';
    }

    if (!audioHandler.isInitialized) {
        audioHandler.initialize();
    }

    if (e.key.toLowerCase() === 'f') {
        toggleFullScreen();
    }
    
    if (gameState === 'nameEntry') {
        if (e.key.length === 1 && selectableChars.includes(e.key.toUpperCase()) && playerName.length < 3) {
            playerName += e.key.toUpperCase();
        } else if (e.key === 'Backspace' || e.key === 'Delete') {
            playerName = playerName.slice(0, -1);
        } else if (e.key === 'Enter') {
            if (playerName.length > 0) {
                submitAndSaveName(playerName);
            } else {
                // Use last name if exists, otherwise default
                const lastName = localStorage.getItem(config.lastPlayerNameKey) || 'AAA';
                submitAndSaveName(lastName);
            }
        }
    }
});
window.addEventListener('keyup', e => {
    keyState[e.key] = false;
});

soundToggleButton.addEventListener('click', () => {
    if (!audioHandler.isInitialized) audioHandler.initialize();
    soundToggleButton.textContent = audioHandler.toggleMute() ? 'SOUND OFF' : 'SOUND ON';
});

function toggleFullScreen() {
    const e = document.getElementById('fullscreen-root');
    if (!document.fullscreenElement) {
        e.requestFullscreen().catch(err => {
            alert(`フルスクリーンにできませんでした: ${err.message}`);
        });
    } else {
        document.exitFullscreen();
    }
}

function updateScale() {
    const r = document.getElementById('fullscreen-root');
    const w = document.getElementById('game-wrapper');
    if (document.fullscreenElement === r) {
        const totalGameHeight = document.getElementById('gameCanvas').offsetHeight + document.getElementById('instructions-container').offsetHeight;
        const scale = Math.min(r.clientWidth / (w.offsetWidth + 20), r.clientHeight / (totalGameHeight + 20));
        w.style.setProperty('--scale-factor', scale);
    } else {
        w.style.removeProperty('--scale-factor');
    }
}

window.addEventListener('fullscreenchange', updateScale);
window.addEventListener('resize', updateScale);

init();
gameLoop();

</script>
</body>
</html>
