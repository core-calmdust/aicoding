<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">

    <!-- ▼▼▼ SEO/OGP関連のメタデータをここから追加 ▼▼▼ -->
    
    <!-- 1. 基本的なメタデータ -->
    <title>CYBER PONG XTREME+ | 無料で遊べるサイバーパンク風ピンポンゲーム</title>
    <meta name="description" content="近未来的なビジュアルとBGMが特徴の、ハイスピードなピンポン（PONG）ゲーム。多彩なモードと難易度で、熱い対戦をブラウザで今すぐ体験！登録不要・インストールなしで遊べます。">
    <meta name="keywords" content="PONG, ピンポン, ゲーム, 無料, ブラウザゲーム, サイバーパンク, レトロ, アーケード, 対戦, AI">
    <link rel="canonical" href="https://core-calmdust.github.io/aicoding/pong.html">
    <link rel="icon" href="https://core-calmdust.github.io/aicoding/images/pong_favicon.ico" type="image/x-icon"> 

    <!-- 2. OGP (Open Graph Protocol) タグ -->
    <meta property="og:title" content="CYBER PONG XTREME+ | 無料ブラウザピンポンゲーム">
    <meta property="og:description" content="ハイスピードなサイバーパンク風ピンポンゲーム。多彩なモードと難易度で、熱い対戦を今すぐ体験！">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://core-calmdust.github.io/aicoding/pong.html">
    <meta property="og:image" content="https://core-calmdust.github.io/aicoding/images/pong_ogp.png">
    <meta property="og:site_name" content="CYBER PONG XTREME+">
    <meta property="og:locale" content="ja_JP">

    <!-- 3. Twitterカード タグ -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="CYBER PONG XTREME+ | 無料ブラウザピンポンゲーム">
    <meta name="twitter:description" content="ハイスピードなサイバーパンク風ピンポンゲーム。多彩なモードと難易度で、熱い対戦を今すぐ体験！">
    <meta name="twitter:image" content="https://core-calmdust.github.io/aicoding/images/pong_ogp.png"> 

    <!-- ▲▲▲ SEO/OGP関連のメタデータここまで ▲▲▲ -->
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #0d0221;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
            color: #ff00ff;
        }
        #game-wrapper {
            display: flex;
            width: 100%;
            padding: 30px;
            box-sizing: border-box;
        }
        #game-wrapper.pc-layout, #game-wrapper.mobile-portrait {
            flex-direction: column;
            max-width: 960px; 
            aspect-ratio: 960 / 710;
        }
        #game-wrapper.mobile-landscape {
            flex-direction: row;
            height: 100%;
            padding: 1vh;
        }
        #game-area {
            flex-grow: 1;
            position: relative;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0d0221;
            cursor: pointer;
            transition: box-shadow 0.05s linear, border-color 0.05s linear;
        }
        #info-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        #info-area.pc-layout, #info-area.mobile-portrait {
            width: 100%;
            padding-top: 10px;
        }
        #info-area.mobile-landscape {
            flex-direction: column;
            justify-content: center;
            align-items: stretch;
            width: 110px; 
            padding-left: 15px;
            gap: 15px;
        }
        
        html:fullscreen {
            background-color: #000;
        }
        html:fullscreen body {
            padding: 0;
        }
        html:fullscreen #game-wrapper {
            width: auto;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }
        
        html:fullscreen .info-text {
            font-size: clamp(14px, 1.8vh, 24px);
            line-height: 1.5;
        }
        
        .pulsing { border-color: #ffffff !important; box-shadow: 0 0 30px #ffffff, 0 0 40px #00f6ff, 0 0 50px #ff00ff !important; }
        .info-text { color: #00f6ff; text-shadow: 0 0 5px #00f6ff; line-height: 1.4; font-size: 12px; }
        #controls-info { text-align: right; }
        .hidden { display: none !important; }
        /* ▼▼▼ SEO: スクリーンリーダー用の非表示スタイルを追加 ▼▼▼ */
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }


        #pc-mute-btn {
            position: absolute;
            bottom: 15px;
            right: 15px;
            padding: 8px 12px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid #00f6ff;
            color: #00f6ff;
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            text-align: center;
            user-select: none;
            z-index: 10;
            border-radius: 4px;
            white-space: nowrap;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        #pc-mute-btn:hover {
            background-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 10px #00f6ff;
        }

        #mobile-ui-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
        }
        #info-area.mobile-portrait #mobile-ui-container {
             flex-direction: row;
        }

        .mobile-ui-button {
            cursor: pointer;
            padding: 8px 5px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid #00f6ff;
            border-radius: 4px;
            user-select: none;
            text-align: center;
            font-size: 10px;
        }
    </style>
     <!-- ▼▼▼ SEO: 構造化データの追加 ▼▼▼ -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "CYBER PONG XTREME+",
      "description": "近未来的なビジュアルとBGMが特徴の、ハイスピードなピンポン（PONG）ゲーム。多彩なモードと難易度で楽しめます。",
      "gamePlatform": "Web-based game",
      "applicationCategory": "Game",
      "operatingSystem": "All",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "JPY"
      }
    }
    </script>
</head>
<body>
    <!-- ▼▼▼ SEO: h1とセマンティックタグ(main, footer)を追加 ▼▼▼ -->
    <h1 class="visually-hidden">CYBER PONG XTREME+ - 無料ブラウザピンポンゲーム</h1>
    <main id="game-wrapper">
        <div id="game-area">
            <canvas id="pongCanvas" width="900" height="600" aria-label="サイバーポンゲーム画面"></canvas>
            <div id="pc-mute-btn" role="button" aria-label="サウンドのオン・オフを切り替える">SOUND OFF</div>
        </div>
        <footer id="info-area">
            <div class="info-text" id="rule-info"></div>
            <div id="mobile-ui-container">
                <div id="pause-btn" class="mobile-ui-button" role="button" aria-label="ゲームを一時停止または再開">PAUSE</div>
                <div id="mobile-mute-btn" class="mobile-ui-button" role="button" aria-label="サウンドのオン・オフを切り替える">SOUND</div>
            </div>
            <div class="info-text" id="controls-info"></div>
        </footer>
    </main>
    <!-- ▲▲▲ SEO: 変更ここまで ▲▲▲ -->

    <script>
        // JavaScript部分は変更なし
        // ================================================================= //
        // グローバル変数 & 定数
        // ================================================================= //
        
        const canvas = document.getElementById('pongCanvas'), ctx = canvas.getContext('2d');
        const gameWrapper = document.getElementById('game-wrapper');
        const infoArea = document.getElementById('info-area');
        const ruleInfo = document.getElementById('rule-info'), controlsInfo = document.getElementById('controls-info');
        const mobileUiContainer = document.getElementById('mobile-ui-container');
        const pcMuteBtn = document.getElementById('pc-mute-btn');
        const mobileMuteBtn = document.getElementById('mobile-mute-btn'), pauseBtn = document.getElementById('pause-btn');
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const WINNING_SCORE = 10;
        const MASTER_VOLUME = 0.65;
        
        const difficultyLevels = { 
            1: { name: "EASY",      speed: 8,  error: 0.4,  smashChance: 0.05 },
            2: { name: "NORMAL",    speed: 11, error: 0.2, smashChance: 0.25 },
            3: { name: "HARD",      speed: 13, error: 0.15,  smashChance: 0.50 },
            4: { name: "VERY HARD", speed: 15, error: 0.07, smashChance: 0.60 },
            5: { name: "IMPOSSIBLE",speed: 16, error: 0.04, smashChance: 0.80 }
        };
        const gameModes = { 
            1: { name: 'CLASSIC' },
            2: { name: 'ADVANCED' }, 
            3: { name: 'TURBO' } 
        };
        const colors = { bg: '#0d0221', paddle: '#00f6ff', ball: '#ff00ff', net: 'rgba(0, 246, 255, 0.3)', text: '#f0f', particle: ['#ff00ff', '#f9c80e', '#00f6ff'], monster: '#f9c80e', smash: '#f9c80e' };
        
        let gameState = 'title', isMuted = true, hue = 0, isPulsing = false;
        let selectedDifficulty = difficultyLevels[2], selectedMode = gameModes[1], difficultySelector = 2, modeSelector = 1;
        let ball, player, cpu, particles, monsters;
        let audioCtx, masterGain, bgm, titleBgm;
        const sounds = {}, keys = {};
        
        let gamepad = null, lastGamepadState = null;
        let menuInputCooldown = false, inputCooldown = false;
        let lastInputDevice = 'keyboard';
        
        let touchStartX = 0, touchStartY = 0;

        const GAMEPAD_BUTTONS = { A: 0, B: 1, X: 2, Y: 3, SELECT: 8, START: 9, DPAD_UP: 12, DPAD_DOWN: 13, DPAD_LEFT: 14, DPAD_RIGHT: 15, };
        const GAMEPAD_AXES = { LEFT_X: 0, LEFT_Y: 1, RIGHT_X: 2, RIGHT_Y: 3, };

        // ================================================================= //
        // フルスクリーン機能
        // ================================================================= //
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // ================================================================= //
        // サウンドエンジン
        // ================================================================= //
        
        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = isMuted ? 0 : MASTER_VOLUME;
            masterGain.connect(audioCtx.destination);

            sounds.hit = () => {
                const oscFM = audioCtx.createOscillator();
                oscFM.type = "sine";
                oscFM.frequency.setValueAtTime(300, audioCtx.currentTime);
                const oscCarrier = audioCtx.createOscillator();
                oscCarrier.type = "square";
                oscCarrier.frequency.setValueAtTime(450, audioCtx.currentTime);
                const gainFM = audioCtx.createGain();
                gainFM.gain.setValueAtTime(400, audioCtx.currentTime);
                const gainMaster = audioCtx.createGain();
                oscCarrier.connect(gainFM);
                gainFM.connect(oscFM.frequency);
                oscFM.connect(gainMaster);
                gainMaster.connect(masterGain);
                gainMaster.gain.setValueAtTime(0, audioCtx.currentTime);
                gainMaster.gain.linearRampToValueAtTime(0.7, audioCtx.currentTime + 0.01);
                gainMaster.gain.exponentialRampToValueAtTime(1e-4, audioCtx.currentTime + 0.15);
                oscFM.start();
                oscCarrier.start();
                oscFM.stop(audioCtx.currentTime + 0.2);
                oscCarrier.stop(audioCtx.currentTime + 0.2);
            };

            sounds.smash = () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = "sawtooth";
                osc.frequency.value = 880;
                osc.connect(gain);
                gain.connect(masterGain);
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.01);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            };

            sounds.wall = () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = "square";
                osc.frequency.value = 220;
                osc.connect(gain);
                gain.connect(masterGain);
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.01);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            };
            
            sounds.goal = () => {
                const osc1 = audioCtx.createOscillator();
                const gain1 = audioCtx.createGain();
                osc1.type = "sine";
                osc1.frequency.value = 130;
                osc1.connect(gain1);
                gain1.connect(masterGain);
                gain1.gain.setValueAtTime(0, audioCtx.currentTime);
                gain1.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.01);
                gain1.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                osc1.start();
                osc1.stop(audioCtx.currentTime + 0.5);
                const osc2 = audioCtx.createOscillator();
                const gain2 = audioCtx.createGain();
                osc2.type = "sine";
                osc2.frequency.value = 261;
                osc2.connect(gain2);
                gain2.connect(masterGain);
                gain2.gain.setValueAtTime(0, audioCtx.currentTime + 0.1);
                gain2.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.11);
                gain2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.6);
                osc2.start(audioCtx.currentTime + 0.1);
                osc2.stop(audioCtx.currentTime + 0.6);
            };
            
            sounds.win = () => {
                [60, 64, 67, 72].forEach((midiNote, index) => {
                    const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = "triangle";
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(masterGain);
                    const startTime = audioCtx.currentTime + 0.1 * index;
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.5, startTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(1e-4, startTime + 0.3);
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            };
            
            sounds.lose = () => {
                [60, 58, 55, 53].forEach((midiNote, index) => {
                    const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = "sawtooth";
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(masterGain);
                    const startTime = audioCtx.currentTime + 0.15 * index;
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.3, startTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(1e-4, startTime + 0.5);
                    osc.start(startTime);
                    osc.stop(startTime + 0.5);
                });
            };
        }
        function playSound(soundName) {
            if (audioCtx && sounds[soundName]) {
                sounds[soundName]();
            }
        }
        function toggleMute(forceState) {
            isMuted = forceState !== undefined ? forceState : !isMuted;
            if (audioCtx) {
                masterGain.gain.linearRampToValueAtTime(isMuted ? 0 : MASTER_VOLUME, audioCtx.currentTime + 0.1);
            }
            pcMuteBtn.textContent = isMuted ? "SOUND OFF" : "SOUND ON";
            mobileMuteBtn.textContent = isMuted ? "SOUND: OFF" : "SOUND: ON";
        }
        class BGM { 
            constructor(bpm = 130) {
                this.pattern = [50, 53, 57, 53, 60, 57, 53, 57];
                this.kickPattern = [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0];
                this.hatPattern = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1];
                this.interval = null;
                this.step = 0;
                this.bpm = bpm;
            }
            start() {
                if (this.interval) return;
                this.interval = setInterval(() => this.playStep(), (60 / this.bpm) * 1000 / 4);
            }
            stop() {
                clearInterval(this.interval);
                this.interval = null;
            }
            playStep() {
                if (isMuted || !audioCtx) return;
                const time = audioCtx.currentTime;
                
                if (this.step % 4 === 0) {
                    const note = this.pattern[Math.floor(this.step / 4) % this.pattern.length];
                    const freq = 440 * Math.pow(2, (note - 69) / 12);
                    const o = audioCtx.createOscillator(), g = audioCtx.createGain(), f = audioCtx.createBiquadFilter();
                    o.type = 'sawtooth';
                    o.frequency.value = freq / 2;
                    o.connect(f);
                    f.type = 'lowpass';
                    f.frequency.value = 800;
                    f.connect(g);
                    g.connect(masterGain);
                    g.gain.setValueAtTime(0, time);
                    g.gain.linearRampToValueAtTime(0.4, time + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.2);
                    o.start(time);
                    o.stop(time + 0.2);
                }
                if (this.kickPattern[this.step % this.kickPattern.length]) {
                    this.playKick(time);
                    requestAnimationFrame(this.pulseEffect);
                }
                if (this.hatPattern[this.step % this.hatPattern.length]) {
                    this.playHat(time);
                }
                this.step = (this.step + 1) % 64;
            }
            playKick(time) {
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sine';
                o.frequency.setValueAtTime(120, time);
                o.frequency.exponentialRampToValueAtTime(40, time + 0.2);
                o.connect(g);
                g.connect(masterGain);
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.8, time + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, time + 0.2);
                o.start(time);
                o.stop(time + 0.2);
            }
            playHat(time) {
                const bufferSize = audioCtx.sampleRate * 0.1;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const o = audioCtx.createBufferSource(), g = audioCtx.createGain(), f = audioCtx.createBiquadFilter();
                o.buffer = buffer;
                o.connect(f);
                f.type = 'highpass';
                f.frequency.value = 7000;
                f.connect(g);
                g.connect(masterGain);
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.2, time + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);
                o.start(time);
            }
            pulseEffect() {
                canvas.classList.add('pulsing');
                isPulsing = true;
                setTimeout(() => {
                    canvas.classList.remove('pulsing');
                    isPulsing = false;
                }, 50);
            }
        }
        class TitleBGM {
            constructor(bpm = 120) {
                this.bpm = bpm;
                this.step = 0;
                this.interval = null;
                this.kickPattern =  [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0];
                this.snarePattern = [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0];
                this.hatPattern =   [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0];
                const C2=28, D2=30, E2=32, F2=33, G2=35, A2=37;
                this.bassPattern = [A2, 0, A2, 0, A2, 0, A2, 0, G2, 0, G2, 0, G2, 0, G2, 0, F2, 0, F2, 0, F2, 0, F2, 0, G2, 0, G2, 0, G2, 0, G2, 0];
            }
            start() {
                if (this.interval) return;
                this.interval = setInterval(() => this.playStep(), (60 / this.bpm) * 1000 / 4);
            }
            stop() {
                clearInterval(this.interval);
                this.interval = null;
            }
            playStep() {
                if (isMuted || !audioCtx) return;
                const time = audioCtx.currentTime;
                const current16thStep = this.step % 16;
                const current32thStep = this.step % 32;

                if (this.kickPattern[current16thStep]) this.playKick(time);
                if (this.snarePattern[current16thStep]) this.playSnare(time);
                if (this.hatPattern[current16thStep]) this.playHat(time);
                
                const bassNote = this.bassPattern[current32thStep];
                if(bassNote > 0 && current32thStep % 2 === 0) this.playBass(time, bassNote);
                
                this.step++;
            }
            playKick(time) {
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sine';
                o.frequency.setValueAtTime(120, time);
                o.frequency.exponentialRampToValueAtTime(60, time + 0.1);
                g.gain.setValueAtTime(1, time);
                g.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                o.connect(g);
                g.connect(masterGain);
                o.start(time);
                o.stop(time + 0.3);
            }
            playSnare(time) {
                const noise = audioCtx.createBufferSource();
                const bufferSize = audioCtx.sampleRate * 0.2;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const f = audioCtx.createBiquadFilter();
                f.type = 'highpass';
                f.frequency.value = 1500;
                const g = audioCtx.createGain();
                g.gain.setValueAtTime(0.5, time);
                g.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                noise.connect(f);
                f.connect(g);
                g.connect(masterGain);
                noise.start(time);
                noise.stop(time + 0.15);
            }
            playHat(time) {
                const noise = audioCtx.createBufferSource();
                const bufferSize = audioCtx.sampleRate * 0.1;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const f = audioCtx.createBiquadFilter();
                f.type = 'highpass';
                f.frequency.value = 8000;
                const g = audioCtx.createGain();
                g.gain.setValueAtTime(0.2, time);
                g.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                noise.connect(f);
                f.connect(g);
                g.connect(masterGain);
                noise.start(time);
                noise.stop(time + 0.05);
            }
            playBass(time, note) {
                const freq = 440 * Math.pow(2, (note - 69) / 12);
                const o = audioCtx.createOscillator(), g = audioCtx.createGain(), f = audioCtx.createBiquadFilter();
                o.type = 'sawtooth';
                o.frequency.value = freq;
                f.type = 'lowpass';
                f.frequency.value = 800;
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.3, time + 0.01);
                g.gain.linearRampToValueAtTime(0, time + 0.1);
                o.connect(f);
                f.connect(g);
                g.connect(masterGain);
                o.start(time);
                o.stop(time + 0.1);
            }
        }
        
        // ================================================================= //
        // 描画エンジン
        // ================================================================= //
        const draw = {
            rect: (x, y, w, h, color, shadowColor = color) => {
                ctx.fillStyle = color;
                ctx.shadowColor = shadowColor;
                ctx.shadowBlur = 15;
                ctx.fillRect(x, y, w, h);
                ctx.shadowBlur = 0;
            },
            arc: (x, y, r, color, shadowColor = color) => {
                ctx.fillStyle = color;
                ctx.shadowColor = shadowColor;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.shadowBlur = 0;
            },
            text: (text, x, y, color, size = "50px", align = "center") => {
                ctx.fillStyle = color;
                ctx.font = `${size} 'Press Start 2P'`;
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.textAlign = align;
                ctx.fillText(text, x, y);
                ctx.shadowBlur = 0;
                ctx.textAlign = "left";
            },
            net: () => {
                const netColor = isPulsing ? '#ffffff' : colors.net;
                for (let i = 0; i <= canvas.height; i += 20) {
                    draw.rect((canvas.width - 4) / 2, i, 4, 10, netColor, netColor);
                }
            },
            grid: () => {
                ctx.strokeStyle = "rgba(0, 246, 255, 0.1)";
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                for (let j = 0; j < canvas.height; j += 20) {
                    ctx.beginPath();
                    ctx.moveTo(0, j);
                    ctx.lineTo(canvas.width, j);
                    ctx.stroke();
                }
            },
            monster: m => {
                ctx.fillStyle = colors.monster;
                ctx.shadowColor = colors.monster;
                ctx.shadowBlur = 15;
                ctx.fillRect(m.x, m.y, m.width, m.height);
                ctx.shadowBlur = 0;

                if (m.isHit) {
                    // --- ヒット時の顔 ---
                    ctx.strokeStyle = colors.bg;
                    ctx.lineWidth = 4;
                    const eyeSize = 10;
                    
                    const eye1X = m.x + 12;
                    const eye1Y = m.y + 12;
                    ctx.beginPath();
                    ctx.moveTo(eye1X - eyeSize / 2, eye1Y - eyeSize / 2);
                    ctx.lineTo(eye1X + eyeSize / 2, eye1Y + eyeSize / 2);
                    ctx.moveTo(eye1X + eyeSize / 2, eye1Y - eyeSize / 2);
                    ctx.lineTo(eye1X - eyeSize / 2, eye1Y + eyeSize / 2);
                    ctx.stroke();

                    const eye2X = m.x + 28;
                    const eye2Y = m.y + 12;
                    ctx.beginPath();
                    ctx.moveTo(eye2X - eyeSize / 2, eye2Y - eyeSize / 2);
                    ctx.lineTo(eye2X + eyeSize / 2, eye2Y + eyeSize / 2);
                    ctx.moveTo(eye2X + eyeSize / 2, eye2Y - eyeSize / 2);
                    ctx.lineTo(eye2X - eyeSize / 2, eye2Y + eyeSize / 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = colors.bg;
                    const mouthSize = 10;
                    const mouthX = m.x + m.width / 2 - mouthSize / 2;
                    const mouthY = m.y + 28 - mouthSize / 2;
                    ctx.fillRect(mouthX, mouthY, mouthSize, mouthSize);

                } else {
                    // --- 通常時の顔 ---
                    ctx.fillStyle = colors.bg;
                    ctx.fillRect(m.x + 8, m.y + 8, 8, 8);
                    ctx.fillRect(m.x + 24, m.y + 8, 8, 8);
                    ctx.fillRect(m.x + 8, m.y + 24, 24, 8);
                }
            },
            rainbowText: (text, x, y, size, align, offsetMultiplier = 20) => {
                ctx.font = `${size} 'Press Start 2P'`;
                const totalWidth = ctx.measureText(text).width;
                let currentX;
                if (align === 'center') {
                    currentX = x - totalWidth / 2;
                } else if (align === 'right') {
                    currentX = x - totalWidth;
                } else {
                    currentX = x;
                }
                text.split('').forEach((char, index) => {
                    const charColor = `hsl(${(hue + index * offsetMultiplier) % 360}, 100%, 70%)`;
                    ctx.fillStyle = charColor;
                    ctx.shadowColor = charColor;
                    ctx.shadowBlur = 15;
                    ctx.fillText(char, currentX, y);
                    currentX += ctx.measureText(char).width;
                });
                ctx.shadowBlur = 0;
            }
        };

        function createParticles(x, y, options = {}) {
            const {
                count = 20,
                colorSet = colors.particle,
                speed = 8,
                life = 60
            } = options;

            for (let i = 0; i < count; i++) {
                particles.push({
                    x,
                    y,
                    radius: 1 + Math.random() * 3,
                    vx: (Math.random() - 0.5) * speed,
                    vy: (Math.random() - 0.5) * speed,
                    life: Math.random() * life,
                    color: colorSet[Math.floor(Math.random() * colorSet.length)]
                });
            }
        }
        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.globalAlpha = p.life / 60;
                    draw.arc(p.x, p.y, p.radius, p.color);
                    ctx.globalAlpha = 1;
                }
            }
        }
        
        // ================================================================= //
        // ゲームオブジェクト & ロジック
        // ================================================================= //
        function initializeObjects() {
            const isTurbo = selectedMode.name === 'TURBO';
            const baseSpeed = isTurbo ? 11 : 9;
            const speedIncrement = isTurbo ? 0.8 : 0.6;
            const paddleSpeed = isTurbo ? 11 : 9;
            const paddleBoostSpeed = isTurbo ? 17 : 14;

            ball = { x: canvas.width / 2, y: canvas.height / 2, radius: 12, speed: baseSpeed, velocityX: baseSpeed, velocityY: baseSpeed, speedIncrement: speedIncrement, isSmashed: false };
            player = { x: 15, y: (canvas.height - 100) / 2, width: 15, height: 100, score: 0, speed: paddleSpeed, boostSpeed: paddleBoostSpeed };
            cpu = { x: canvas.width - 30, y: (canvas.height - 100) / 2, width: 15, height: 100, score: 0, isTryingSmash: null };
            particles = []; monsters = [];
            
            if (selectedMode.name === 'ADVANCED' || selectedMode.name === 'TURBO') {
                let monsterCount = 0;
                let monsterSpeed = 2;
                if (selectedMode.name === 'ADVANCED') {
                    switch (selectedDifficulty.name) {
                        case 'EASY': monsterCount = 1; break;
                        case 'NORMAL': monsterCount = 2; break;
                        case 'HARD': monsterCount = 2; break;
                        case 'VERY HARD': monsterCount = 3; break;
                        case 'IMPOSSIBLE': monsterCount = 3; monsterSpeed = 3; break;
                    } 
                } else if (selectedMode.name === 'TURBO') {
                    monsterSpeed = 3;
                    switch (selectedDifficulty.name) {
                        case 'EASY': monsterCount = 1; monsterSpeed = 2; break;
                        case 'NORMAL': monsterCount = 2; break;
                        case 'HARD': monsterCount = 2; break;
                        case 'VERY HARD': monsterCount = 3; break;
                        case 'IMPOSSIBLE': monsterCount = 4; monsterSpeed = 4; break;
                    }
                }
                for (let i = 0; i < monsterCount; i++) {
                    monsters.push({
                        x: canvas.width / 4 + Math.random() * canvas.width / 2,
                        y: 50 + Math.random() * (canvas.height - 100),
                        width: 40, height: 40,
                        vx: (Math.random() > 0.5 ? 1 : -1) * monsterSpeed,
                        vy: (Math.random() > 0.5 ? 1 : -1) * monsterSpeed,
                        isHit: false
                    });
                }
            }
        }

        function movePlayer() {
            let isBoosting = keys.Shift;
            if (gamepad && gamepad.buttons && gamepad.buttons.some(b => b.pressed)) {
                isBoosting = true;
            }
            const currentSpeed = isBoosting ? player.boostSpeed : player.speed;

            let moveUp = keys.w || keys.W || keys.ArrowUp;
            let moveDown = keys.s || keys.S || keys.ArrowDown;
            let stickY = 0;

            if (gamepad) {
                if (gamepad.buttons[GAMEPAD_BUTTONS.DPAD_UP]?.pressed) moveUp = true;
                if (gamepad.buttons[GAMEPAD_BUTTONS.DPAD_DOWN]?.pressed) moveDown = true;
                if (gamepad.axes[GAMEPAD_AXES.LEFT_Y]) stickY = gamepad.axes[GAMEPAD_AXES.LEFT_Y];
            }

            const deadzone = 0.2;
            if (stickY < -deadzone) moveUp = true;
            if (stickY > deadzone) moveDown = true;
            
            if (moveUp && player.y > 0) player.y -= currentSpeed;
            if (moveDown && player.y < canvas.height - player.height) player.y += currentSpeed;
        }

        function moveCpu() {
            let cpuSpeed = selectedDifficulty.speed;
            if (selectedMode.name === 'TURBO') cpuSpeed *= 1.1;
            let targetY = ball.y;

            if (ball.velocityX > 0 && ball.x > canvas.width / 2) {
                if (cpu.isTryingSmash === null) {
                    if (Math.random() < selectedDifficulty.smashChance) {
                        cpu.isTryingSmash = true;
                        cpu.smashTargetSide = (Math.random() > 0.5) ? 1 : -1;
                    } else {
                        cpu.isTryingSmash = false;
                    }
                }
            }

            if (cpu.isTryingSmash === true) {
                const smashOffset = (cpu.height / 2) * 0.85 * cpu.smashTargetSide;
                targetY = ball.y - smashOffset;
                cpuSpeed *= 1.2;
            } else {
                targetY += (Math.random() - 0.5) * player.height * selectedDifficulty.error;
            }

            const paddleCenter = cpu.y + cpu.height / 2;
            if (paddleCenter < targetY && cpu.y < canvas.height - cpu.height) {
                cpu.y += cpuSpeed;
            } else if (paddleCenter > targetY && cpu.y > 0) {
                cpu.y -= cpuSpeed;
            }
        }
        
        function moveMonsters() {
            monsters.forEach(m => {
                m.x += m.vx;
                m.y += m.vy;
                if (m.x <= 0 || m.x + m.width >= canvas.width) m.vx *= -1;
                if (m.y <= 0 || m.y + m.height >= canvas.height) m.vy *= -1;
            });
        }
        function collision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }
        function resetBall() {
            playSound("goal");
            ball.x = canvas.width / 2;
            ball.y = 100 + Math.random() * (canvas.height - 200);
            ball.speed = selectedMode.name === 'TURBO' ? 11 : 9;
            ball.isSmashed = false;
            ball.velocityX = ball.velocityX > 0 ? -ball.speed : ball.speed;
            ball.velocityY = ball.speed * (Math.random() > 0.5 ? 1 : -1);
            cpu.isTryingSmash = null;
        }

        // ================================================================= //
        // ゲーム状態管理関数 & 入力クールダウン
        // ================================================================= //
        function setInputCooldown(duration) {
            inputCooldown = true;
            setTimeout(() => { inputCooldown = false; }, duration);
        }

        function unlockAudio() {
            if (audioCtx) return;
            initAudio();
            toggleMute(false);
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function startGame() {
            if (inputCooldown) return;

            if (titleBgm) titleBgm.stop();
            selectedMode = gameModes[modeSelector];
            selectedDifficulty = difficultyLevels[difficultySelector];
            initializeObjects();
            gameState = 'playing';
            const bpm = selectedMode.name === 'TURBO' ? 160 : 130;
            if (bgm) bgm.stop();
            bgm = new BGM(bpm);
            bgm.start();
            
            setInputCooldown(200);
        }

        function pauseGame() {
            if (gameState !== 'playing') return;
            gameState = 'paused';
            if (bgm) bgm.stop();
        }

        function resumeGame() {
            if (gameState !== 'paused') return;
            gameState = 'playing';
            if (bgm) bgm.start();
        }

        function goToTitle() {
            if (inputCooldown) return;

            gameState = 'title';
            if (bgm) bgm.stop();
            if (!titleBgm) titleBgm = new TitleBGM();
            titleBgm.start();
            
            setInputCooldown(200);
        }
        
        // ================================================================= //
        // メインループ (update)
        // ================================================================= //
        function update() {
            hue = (hue + 1) % 360;
            if (gameState !== 'playing') return;

            ball.x += ball.velocityX;
            ball.y += ball.velocityY;
            
            movePlayer();
            moveCpu();
            if (monsters.length > 0) moveMonsters();
            
            if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
                ball.velocityY *= -1;
                if (ball.y + ball.radius > canvas.height) ball.y = canvas.height - ball.radius;
                if (ball.y - ball.radius < 0) ball.y = ball.radius;
                createParticles(ball.x, ball.y, { count: 30, speed: 6 });
                playSound('wall');
            }
            
            const currentPaddle = (ball.x < canvas.width / 2) ? player : cpu;
            const ballRect = { x: ball.x - ball.radius, y: ball.y - ball.radius, width: ball.radius * 2, height: ball.radius * 2 };
            
            if (collision(ballRect, currentPaddle)) {
                if (currentPaddle === cpu) {
                    cpu.isTryingSmash = null;
                }
                const collidePoint = (ball.y - (currentPaddle.y + currentPaddle.height / 2));
                const normalizedCollidePoint = collidePoint / (currentPaddle.height / 2);
                let angleRad = (Math.PI / 4) * normalizedCollidePoint;
                
                if (Math.abs(normalizedCollidePoint) > 0.8) {
                    ball.speed = 25;
                    ball.isSmashed = true;
                    createParticles(ball.x, ball.y, { count: 120, speed: 18, life: 80, colorSet: [colors.smash, colors.smash, colors.smash, '#ffffff', colors.ball] });
                    angleRad = Math.sign(angleRad) * (Math.PI / 3);
                    playSound('smash');
                } else {
                    if (ball.isSmashed) {
                        ball.speed = selectedMode.name === 'TURBO' ? 12 : 10;
                        ball.isSmashed = false;
                    }
                    ball.speed += ball.speedIncrement;
                    createParticles(ball.x, ball.y, { count: 60, speed: 10, colorSet: [...colors.particle, '#ffffff'] });
                    playSound('hit');
                }
                
                const direction = (ball.x < canvas.width / 2) ? 1 : -1;
                ball.velocityX = direction * ball.speed * Math.cos(angleRad);
                ball.velocityY = ball.speed * Math.sin(angleRad);

                if (direction === 1) {
                    ball.x = player.x + player.width + ball.radius;
                } else {
                    ball.x = cpu.x - ball.radius;
                }
            }
            
            if (monsters.length > 0) {
                monsters.forEach(m => {
                    if (collision(ballRect, m)) {
                        playSound('hit');
                        createParticles(ball.x, ball.y, { count: 60, speed: 10, colorSet: [...colors.particle, '#ffffff'] });
                        
                        if (!m.isHit) {
                            m.isHit = true;
                            setTimeout(() => { m.isHit = false; }, 700);
                        }
                        
                        const oX = (m.x + m.width / 2) - ball.x;
                        const oY = (m.y + m.height / 2) - ball.y;

                        if (Math.abs(oX) > Math.abs(oY)) {
                            ball.velocityX *= -1;
                            ball.x = (oX > 0) ? m.x - ball.radius : m.x + m.width + ball.radius;
                        } else {
                            ball.velocityY *= -1;
                            ball.y = (oY > 0) ? m.y - ball.radius : m.y + m.height + ball.radius;
                        }
                    }
                });
            }
            
            if (ball.x - ball.radius < 0) {
                cpu.score++;
                // ★ 変更点: CPUが得点した時のエフェクトをピンクと白に変更
                createParticles(ball.x, ball.y, { 
                    count: 200, speed: 15, life: 100, 
                    colorSet: [colors.ball, '#ffffff'] 
                });
                resetBall();
            } else if (ball.x + ball.radius > canvas.width) {
                player.score++;
                createParticles(ball.x, ball.y, { 
                    count: 200, speed: 15, life: 100, 
                    colorSet: [colors.smash, colors.paddle, '#ffffff'] 
                });
                resetBall();
            }
            
            if (player.score >= WINNING_SCORE || cpu.score >= WINNING_SCORE) {
                gameState = 'gameOver';
                bgm && bgm.stop();
                playSound(player.score >= WINNING_SCORE ? 'win' : 'lose');
            }
        }

        // ================================================================= //
        // 描画・UI更新
        // ================================================================= //
        function updateUIVisibility() {
            if (isTouchDevice) {
                pcMuteBtn.classList.add('hidden');
                mobileUiContainer.style.display = 'flex';
                pauseBtn.textContent = (gameState === 'paused') ? 'RESUME' : 'PAUSE';
            } else {
                pcMuteBtn.classList.remove('hidden');
                mobileUiContainer.style.display = 'none';
            }
        }
        
        function checkOrientation() {
            if (!isTouchDevice) {
                gameWrapper.className = 'pc-layout';
                infoArea.className = 'pc-layout';
                return;
            };
            if (window.innerHeight > window.innerWidth) {
                gameWrapper.className = 'mobile-portrait';
                infoArea.className = 'mobile-portrait';
            } else {
                gameWrapper.className = 'mobile-landscape';
                infoArea.className = 'mobile-landscape';
            }
        }

        function render() {
            updateUIVisibility();

            const frameColor = `hsl(${hue}, 100%, 70%)`;
            canvas.style.borderColor = frameColor;
            canvas.style.boxShadow = `0 0 20px ${frameColor}, 0 0 30px #ff00ff`;
            
            ctx.fillStyle = 'rgba(13, 2, 33, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            draw.grid();
            
            const useGamepadControls = lastInputDevice === 'gamepad';
            
            if (gameState === 'title') {
                ruleInfo.innerHTML = isTouchDevice ? '' : 'F: Fullscreen';
                controlsInfo.innerHTML = isTouchDevice ? '' : (useGamepadControls ? `PAD: Select | START/BUTTON: START` : `KEYS: Select | ENTER: Start`);
            } else if (gameState === 'playing' || gameState === 'gameOver' || gameState === 'paused') {
                if (isTouchDevice) {
                    ruleInfo.innerHTML = `First to ${WINNING_SCORE} wins.`;
                    controlsInfo.innerHTML = `Drag to Move | Edge Hit: Smash`;
                } else if (useGamepadControls) {
                    ruleInfo.innerHTML = `First to ${WINNING_SCORE} wins. <br> START: Pause | F: Fullscreen`;
                    controlsInfo.innerHTML = `Pad/Keys: Move | Pad BTN: Boost <br> Edge Hit: Smash`;
                } else {
                    ruleInfo.innerHTML = `First to ${WINNING_SCORE} wins. <br> P: Pause | F: Fullscreen`;
                    controlsInfo.innerHTML = `W/S or ↑↓/Mouse: Move <br> SHIFT: Boost | Edge Hit: Smash`;
                }
            } else {
                ruleInfo.innerHTML = ``;
                controlsInfo.innerHTML = ``;
            }

            if (gameState === 'playing' || gameState === 'gameOver' || gameState === 'paused') {
                draw.net();
                draw.text(player.score, canvas.width / 4, 80, colors.text);
                draw.text(cpu.score, 3 * canvas.width / 4, 80, colors.text);
                draw.rect(player.x, player.y, player.width, player.height, colors.paddle);
                draw.rect(cpu.x, cpu.y, cpu.width, cpu.height, colors.paddle);
                
                const ballColor = ball.isSmashed ? colors.smash : colors.ball;
                draw.arc(ball.x, ball.y, ball.radius, ballColor, ballColor);
                if (monsters.length > 0) monsters.forEach(m => draw.monster(m));
                
                updateAndDrawParticles();
            }

            if (gameState === 'title') {
                draw.rainbowText('CYBER PONG', canvas.width / 2, 120, "70px", "center", 25);
                draw.rainbowText('XTREME+', canvas.width / 2, 170, "30px", "center", 40);
                draw.text('Game Mode', canvas.width / 2, 240, colors.text, "30px", "center");
                Object.keys(gameModes).forEach((key, index) => {
                    const mode = gameModes[key];
                    if (key == modeSelector) {
                        draw.rainbowText(mode.name, canvas.width / 2, 290 + (index * 50), "24px", "center", 30);
                    } else {
                        draw.text(mode.name, canvas.width / 2, 290 + (index * 50), colors.paddle, "24px", "center");
                    }
                });
                draw.text('Difficulty', canvas.width / 2, 440, colors.text, "30px", "center");
                draw.rainbowText(`< ${difficultyLevels[difficultySelector].name} >`, canvas.width / 2, 490, "24px", "center", 30);
                
                let startText = '';
                if (isTouchDevice) { startText = "Tap to Start"; } 
                else if (useGamepadControls) { startText = "Press Start or Any Button to Start"; }
                else { startText = "Press Enter to Start"; }
                draw.text(startText, canvas.width / 2, 560, colors.text, "20px", "center");

            } else if (gameState === 'gameOver') {
                const message = player.score >= WINNING_SCORE ? 'YOU WIN' : 'CPU WINS';
                draw.rainbowText(message, canvas.width / 2, canvas.height / 2 - 40, "60px", "center", 25);

                let continueText = '';
                if (isTouchDevice) { continueText = "Tap to Continue"; }
                else if (useGamepadControls) { continueText = "Press Start or Button to Return"; }
                else { continueText = "Press Enter to Return"; }
                draw.text(continueText, canvas.width / 2, canvas.height / 2 + 40, colors.text, "20px", "center");

            } else if (gameState === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                draw.rainbowText('PAUSED', canvas.width / 2, canvas.height / 2 - 60, "60px", "center");
                if (isTouchDevice) {
                    ctx.fillStyle = 'rgba(0, 246, 255, 0.3)';
                    ctx.fillRect(300, 320, 300, 50); // Resume button
                    ctx.fillRect(300, 380, 300, 50); // Quit button
                    draw.text('Resume', canvas.width / 2, 355, colors.text, "20px", "center");
                    draw.text('Return to Title', canvas.width / 2, 415, colors.text, "20px", "center");
                } else {
                    const resumeKey = useGamepadControls ? 'START' : 'P';
                    const quitKey = useGamepadControls ? 'SELECT' : 'Q';
                    draw.text(`Press ${resumeKey} to Resume`, canvas.width / 2, canvas.height / 2 + 40, colors.text, "20px", "center");
                    draw.text(`Press ${quitKey} to Return to Title`, canvas.width / 2, canvas.height / 2 + 80, colors.text, "20px", "center");
                }
            }
        }

        // ================================================================= //
        // 入力処理
        // ================================================================= //
        function updateGamepadState() {
            const gp = navigator.getGamepads()[0];
            if (!gp) {
                gamepad = null;
                return;
            }
            const currentState = {
                buttons: gp.buttons.map(b => ({ pressed: b.pressed, value: b.value })),
                axes: [...gp.axes]
            };
            if (!lastGamepadState) {
                lastGamepadState = {
                    buttons: gp.buttons.map(b => ({ pressed: false, value: 0 })),
                    axes: Array(gp.axes.length).fill(0)
                };
            }
            gamepad = currentState;
        }

        function handleMenuInput(direction) {
            if (menuInputCooldown) return;
            menuInputCooldown = true;
            setTimeout(() => { menuInputCooldown = false; }, 150);

            switch(direction) {
                case 'up': modeSelector = Math.max(1, modeSelector - 1); break;
                case 'down': modeSelector = Math.min(Object.keys(gameModes).length, modeSelector + 1); break;
                case 'left': difficultySelector = Math.max(1, difficultySelector - 1); break;
                case 'right': difficultySelector = Math.min(Object.keys(difficultyLevels).length, difficultySelector + 1); break;
            }
        }

        function handleGamepadInput() {
            if (isTouchDevice) return;
            updateGamepadState();
            if (!gamepad) return;

            if (gamepad.buttons.some(b => b.pressed) || gamepad.axes.some(a => Math.abs(a) > 0.1)) {
                unlockAudio();
                lastInputDevice = 'gamepad';
            }

            const isButtonPressed = (btn) => gamepad.buttons[btn]?.pressed && !lastGamepadState.buttons[btn]?.pressed;

            if (isButtonPressed(GAMEPAD_BUTTONS.START)) {
                if (gameState === 'playing') pauseGame();
                else if (gameState === 'paused') resumeGame();
            }
            if (gameState === 'paused' && isButtonPressed(GAMEPAD_BUTTONS.SELECT)) goToTitle();
            
            if (gameState === 'gameOver' && (
                isButtonPressed(GAMEPAD_BUTTONS.A) ||
                isButtonPressed(GAMEPAD_BUTTONS.B) ||
                isButtonPressed(GAMEPAD_BUTTONS.X) ||
                isButtonPressed(GAMEPAD_BUTTONS.Y) ||
                isButtonPressed(GAMEPAD_BUTTONS.START)
            )) {
                goToTitle();
            }

            if (gameState === 'title') {
                const stickX = gamepad.axes[GAMEPAD_AXES.LEFT_X] ?? gamepad.axes[GAMEPAD_AXES.RIGHT_X];
                const stickY = gamepad.axes[GAMEPAD_AXES.LEFT_Y] ?? gamepad.axes[GAMEPAD_AXES.RIGHT_Y];
                const deadzone = 0.5;

                if (stickY < -deadzone || isButtonPressed(GAMEPAD_BUTTONS.DPAD_UP)) handleMenuInput('up');
                if (stickY > deadzone || isButtonPressed(GAMEPAD_BUTTONS.DPAD_DOWN)) handleMenuInput('down');
                if (stickX < -deadzone || isButtonPressed(GAMEPAD_BUTTONS.DPAD_LEFT)) handleMenuInput('left');
                if (stickX > deadzone || isButtonPressed(GAMEPAD_BUTTONS.DPAD_RIGHT)) handleMenuInput('right');
                
                if (isButtonPressed(GAMEPAD_BUTTONS.A) ||
                    isButtonPressed(GAMEPAD_BUTTONS.B) ||
                    isButtonPressed(GAMEPAD_BUTTONS.X) ||
                    isButtonPressed(GAMEPAD_BUTTONS.Y) ||
                    isButtonPressed(GAMEPAD_BUTTONS.START))
                {
                    startGame();
                }
            }

            lastGamepadState = {
                buttons: gamepad.buttons.map(b => ({ pressed: b.pressed, value: b.value })),
                axes: [...gamepad.axes]
            };
        }
        
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0] || e.changedTouches[0];
            return {
                x: (touch.clientX - rect.left) * (canvas.width / rect.width),
                y: (touch.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function handleCanvasTouchStart(e) {
            e.preventDefault();
            unlockAudio();

            if (gameState === 'playing') {
                handlePointerMove(e);
                return;
            }
            const pos = getTouchPos(e);
            touchStartX = pos.x;
            touchStartY = pos.y;
            
            if (gameState === 'title') {
                if (pos.x > 300 && pos.x < 600) {
                    if (pos.y > 270 && pos.y < 310) { modeSelector = 1; }
                    else if (pos.y > 320 && pos.y < 360) { modeSelector = 2; }
                    else if (pos.y > 370 && pos.y < 410) { modeSelector = 3; }
                }
                if (pos.y > 540) { startGame(); }
            } else if (gameState === 'paused') {
                if (pos.x > 300 && pos.x < 600) {
                    if (pos.y > 320 && pos.y < 370) { resumeGame(); }
                    else if (pos.y > 380 && pos.y < 430) { goToTitle(); }
                }
            } else if (gameState === 'gameOver') {
                if (pos.y > 320 && pos.y < 380) { goToTitle(); }
            }
        }
        
        function handleCanvasTouchEnd(e) {
            e.preventDefault();
            if (gameState !== 'title') return;
            
            const pos = getTouchPos(e);
            const deltaX = pos.x - touchStartX;
            const deltaY = pos.y - touchStartY;
            
            if (touchStartY > 470 && touchStartY < 510 && Math.abs(deltaX) > 50 && Math.abs(deltaY) < 50) {
                if (deltaX > 0) {
                    handleMenuInput('right');
                } else {
                    handleMenuInput('left');
                }
            }
        }

        window.addEventListener('keydown', e => {
            if(isTouchDevice) return;
            unlockAudio();
            lastInputDevice = 'keyboard';
            keys[e.key] = true;
            
            const key = e.key.toLowerCase();

            if (key === 'f') {
                toggleFullScreen();
            }
            
            if (key === 'escape') {
                if (gameState === 'playing') {
                    // ESCはフルスクリーン解除が優先されるため、
                    // fullscreenchangeイベントでゲームの一時停止を処理する
                }
            }

            if (key === 'p') {
                if (gameState === 'playing') pauseGame();
                else if (gameState === 'paused') resumeGame();
            }
            
            if (gameState === 'paused' && key === 'q') {
                goToTitle();
            }
            
            if (key === 'enter') {
                if (gameState === 'title') startGame();
                else if (gameState === 'gameOver') goToTitle();
            }
            
            if (gameState === 'title') {
                if (key === 'arrowup' || key === 'w') handleMenuInput('up');
                if (key === 'arrowdown' || key === 's') handleMenuInput('down');
                if (key === 'arrowleft' || key === 'a') handleMenuInput('left');
                if (key === 'arrowright' || key === 'd') handleMenuInput('right');
            }
        });
        
        window.addEventListener('keyup', e => {
            if(!isTouchDevice) keys[e.key] = false;
        });

        function handlePointerMove(e) {
            unlockAudio();
            lastInputDevice = isTouchDevice ? 'touch' : 'keyboard';
            if (gameState !== 'playing') return;

            const rect = canvas.getBoundingClientRect();
            const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
            const canvasY = (clientY - rect.top) * (canvas.height / rect.height);
            
            let newY = canvasY - player.height / 2;
            newY = Math.max(0, Math.min(newY, canvas.height - player.height));
            
            player.y = newY;
        }

        if (isTouchDevice) {
            canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
            canvas.addEventListener('touchend', handleCanvasTouchEnd, { passive: false });
            pauseBtn.addEventListener('touchstart', () => { if (gameState === 'playing') pauseGame(); }, { passive: false });
            mobileMuteBtn.addEventListener('touchstart', () => {
                if (gameState === 'paused') {
                    goToTitle();
                } else {
                    toggleMute();
                }
            }, { passive: false });
        } else {
            canvas.addEventListener('mousemove', handlePointerMove);
            pcMuteBtn.addEventListener('click', () => toggleMute());
        }
        
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && gameState === 'playing') {
                pauseGame();
            }
        });

        // ================================================================= //
        // メインループ実行
        // ================================================================= //
        function gameLoop() {
            if (!isTouchDevice) handleGamepadInput();
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        checkOrientation();
        window.addEventListener('orientationchange', checkOrientation);
        
        initializeObjects();
        toggleMute(true);
        goToTitle();
        gameLoop();
    </script>
</body>
</html>
