<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript オセロ (AI最終強化版)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: #333;
        }

        .container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            border: 2px solid #333;
            background-color: #008000; /* 濃い緑 */
            padding: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #006400; /* さらに濃い緑の線 */
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .disc {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .black {
            background-color: black;
        }

        .white {
            background-color: white;
        }

        /* 最後に打った駒のハイライト */
        .last-move {
            background-color: #64b5f6 !important; /* 明るい青 */
        }

        /* 置ける場所のヒント */
        .valid-move-hint {
            background-color: rgba(255, 255, 0, 0.4);
        }
        
        .controls, .game-info {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 220px;
            box-sizing: border-box;
        }

        .controls {
            margin-bottom: 20px;
        }

        .controls label, .controls select, .controls button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
        }

        .controls select, .controls button {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .controls button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        .controls button:hover {
            background-color: #45a049;
        }

        .game-info p {
            margin: 0 0 10px 0;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
        }
        
        #message-area {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
            color: #d32f2f;
            height: 25px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>JavaScript オセロ</h1>
            <div class="controls">
                <label for="cpu-level">CPUレベル:</label>
                <select id="cpu-level">
                    <option value="1">レベル1 (ランダム)</option>
                    <option value="2">レベル2 (最大反転)</option>
                    <option value="3">レベル3 (場所評価)</option>
                    <option value="4">レベル4 (ミニマックス)</option>
                    <option value="5">レベル5 (α-β法)</option>
                    <option value="6">レベル6 (思考強化)</option>
                    <option value="7" selected>レベル7 (定石+動的探索)</option>
                </select>
                <button id="start-button">ゲーム開始 / リセット</button>
            </div>
            <div class="game-info">
                <p>手数: <span id="turn-count">0</span></p>
                <p>黒 (あなた): <span id="black-score">2</span></p>
                <p>白 (CPU): <span id="white-score">2</span></p>
                <p>ターン: <span id="current-turn"></span></p>
            </div>
        </div>
        <div class="game-area">
            <div id="board"></div>
            <div id="message-area"></div>
        </div>
    </div>

    <script>
        const BOARD_SIZE = 8;
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;

        // --- DOM Elements ---
        const boardEl = document.getElementById('board');
        const turnCountEl = document.getElementById('turn-count');
        const blackScoreEl = document.getElementById('black-score');
        const whiteScoreEl = document.getElementById('white-score');
        const currentTurnEl = document.getElementById('current-turn');
        const messageAreaEl = document.getElementById('message-area');
        const cpuLevelSelect = document.getElementById('cpu-level');
        const startButton = document.getElementById('start-button');

        // --- Game State ---
        let board = [];
        let currentPlayer;
        let turnCount;
        let cpuLevel;
        let gameOver;
        let lastMove = null;

        const directions = [
            { r: -1, c: -1 }, { r: -1, c: 0 }, { r: -1, c: 1 },
            { r:  0, c: -1 },                  { r:  0, c: 1 },
            { r:  1, c: -1 }, { r:  1, c: 0 }, { r:  1, c: 1 },
        ];
        
        const scoreMatrix = [
            [120, -20, 20,  5,  5, 20, -20, 120],
            [-20, -40, -5, -5, -5, -5, -40, -20],
            [ 20,  -5, 15,  3,  3, 15,  -5,  20],
            [  5,  -5,  3,  3,  3,  3,  -5,   5],
            [  5,  -5,  3,  3,  3,  3,  -5,   5],
            [ 20,  -5, 15,  3,  3, 15,  -5,  20],
            [-20, -40, -5, -5, -5, -5, -40, -20],
            [120, -20, 20,  5,  5, 20, -20, 120]
        ];

        // ★ レベル7用オープニングブック (定石)
        // キー: 盤面を文字列化したもの, 値: CPUが打つべき手 {r, c}
        const openingBook = {
            // 黒がF5(4,5)と打った場合 (兎定石)
            "0000000000000000000000000002100000011100000000000000000000000000": { r: 5, c: 3 }, // D6
            // 黒がC4(3,2)と打った場合 (虎定石)
            "0000000000000000000000000011200000012000000000000000000000000000": { r: 5, c: 2 }, // C6
            // 黒がE6(5,4)と打った場合
            "0000000000000000000000000002100000011000000001000000000000000000": { r: 5, c: 5 }, // F6
            // 黒がD3(2,3)と打った場合
            "0000000000000000000010000012100000012000000000000000000000000000": { r: 2, c: 2 }, // C3
        };

        function boardToString(b) {
            return b.flat().join('');
        }

        // --- Game Logic ---
        function initGame() {
            board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
            board[3][3] = WHITE; board[3][4] = BLACK;
            board[4][3] = BLACK; board[4][4] = WHITE;

            currentPlayer = BLACK;
            turnCount = 0;
            cpuLevel = parseInt(cpuLevelSelect.value, 10);
            gameOver = false;
            lastMove = null;
            messageAreaEl.textContent = '';
            
            renderBoard();
            updateInfo();
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            const validMoves = getValidMoves(board, currentPlayer);

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (board[r][c] !== EMPTY) {
                        const disc = document.createElement('div');
                        disc.className = `disc ${board[r][c] === BLACK ? 'black' : 'white'}`;
                        cell.appendChild(disc);
                    } else if (currentPlayer === BLACK && validMoves.some(move => move.r === r && move.c === c)) {
                         cell.classList.add('valid-move-hint');
                    }
                    if(lastMove && lastMove.r === r && lastMove.c === c) {
                        cell.classList.add('last-move');
                    }
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    boardEl.appendChild(cell);
                }
            }
        }
        
        function updateInfo() {
            let blackScore = 0, whiteScore = 0;
            board.flat().forEach(cell => {
                if (cell === BLACK) blackScore++;
                if (cell === WHITE) whiteScore++;
            });

            turnCountEl.textContent = turnCount;
            blackScoreEl.textContent = blackScore;
            whiteScoreEl.textContent = whiteScore;
            currentTurnEl.textContent = gameOver ? '終了' : (currentPlayer === BLACK ? '黒 (あなた)' : '白 (CPU)');
        }

        function handleCellClick(r, c) {
            if (gameOver || currentPlayer !== BLACK || board[r][c] !== EMPTY) return;
            const flippable = getFlippableDiscs(board, r, c, BLACK);
            if (flippable.length === 0) return;
            placeDisc(r, c, BLACK, flippable);
            switchTurn();
        }

        function placeDisc(r, c, player, flippable) {
            board[r][c] = player;
            flippable.forEach(pos => { board[pos.r][pos.c] = player; });
            lastMove = { r, c };
            turnCount++;
        }
        
        async function switchTurn() {
            currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
            renderBoard();
            updateInfo();
            
            let playerValidMoves = getValidMoves(board, currentPlayer);
            if (playerValidMoves.length === 0) {
                messageAreaEl.textContent = `${currentPlayer === BLACK ? '黒' : '白'}はパスします。`;
                currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
                let opponentValidMoves = getValidMoves(board, currentPlayer);
                if (opponentValidMoves.length === 0) {
                    endGame();
                    return;
                }
            } else {
                 messageAreaEl.textContent = '';
            }
            
            renderBoard();
            updateInfo();
            
            if (!gameOver && currentPlayer === WHITE) {
                messageAreaEl.textContent = 'CPUが思考中...';
                await new Promise(resolve => setTimeout(resolve, 100));
                cpuTurn();
            }
        }
        
        function endGame() {
            gameOver = true;
            updateInfo();
            const blackScore = board.flat().filter(c => c === BLACK).length;
            const whiteScore = board.flat().filter(c => c === WHITE).length;
            let message = "引き分けです！";
            if (blackScore > whiteScore) message = "あなたの勝ちです！";
            if (whiteScore > blackScore) message = "CPUの勝ちです。";
            messageAreaEl.textContent = `ゲーム終了！ ${message}`;
        }
        
        function cpuTurn() {
            if(gameOver) return;
            const move = findBestMove();
            messageAreaEl.textContent = '';
            if (move) {
                const flippable = getFlippableDiscs(board, move.r, move.c, WHITE);
                placeDisc(move.r, move.c, WHITE, flippable);
            }
            switchTurn();
        }
        
        function getFlippableDiscs(currentBoard, r, c, player) {
            const flippable = [];
            const opponent = player === BLACK ? WHITE : BLACK;
            for (const dir of directions) {
                const line = [];
                let currR = r + dir.r, currC = c + dir.c;
                while (currR >= 0 && currR < BOARD_SIZE && currC >= 0 && currC < BOARD_SIZE) {
                    if (currentBoard[currR][currC] === opponent) {
                        line.push({ r: currR, c: currC });
                    } else if (currentBoard[currR][currC] === player) {
                        flippable.push(...line);
                        break;
                    } else { break; }
                    currR += dir.r; currC += dir.c;
                }
            }
            return flippable;
        }
        
        function getValidMoves(currentBoard, player) {
            const moves = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] === EMPTY) {
                        if (getFlippableDiscs(currentBoard, r, c, player).length > 0) {
                            moves.push({ r, c });
                        }
                    }
                }
            }
            return moves;
        }

        // --- CPU AI ---
        function findBestMove() {
            const validMoves = getValidMoves(board, WHITE);
            if (validMoves.length === 0) return null;

            switch (cpuLevel) {
                case 1: return validMoves[Math.floor(Math.random() * validMoves.length)];
                case 2: return validMoves.reduce((best, move) => {
                       const count = getFlippableDiscs(board, move.r, move.c, WHITE).length;
                       return count > best.count ? { move, count } : best;
                    }, { move: validMoves[0], count: 0 }).move;
                case 3: return validMoves.reduce((best, move) => {
                        const score = scoreMatrix[move.r][move.c];
                        return score > best.score ? { move, score } : best;
                    }, { move: null, score: -Infinity }).move;
                case 4: return alphaBeta(board, 3, -Infinity, Infinity, true).move;
                case 5: return alphaBeta(board, 4, -Infinity, Infinity, true).move;
                case 6: return alphaBeta(board, 5, -Infinity, Infinity, true).move;
                case 7: {
                    // ★ 定石の利用
                    const bookMove = openingBook[boardToString(board)];
                    if (bookMove) {
                        console.log("定石を使用しました。");
                        return bookMove;
                    }
                    
                    // ★ 動的探索深度
                    const emptyCells = board.flat().filter(c => c === EMPTY).length;
                    let depth;
                    if (emptyCells > 24) depth = 5;       // 中盤前半
                    else if (emptyCells > 14) depth = 6;  // 中盤後半
                    else depth = 8;                       // 終盤 (深く読む)
                    console.log(`動的探索: 空きマス ${emptyCells}, 探索深度 ${depth}`);
                    return alphaBeta(board, depth, -Infinity, Infinity, true).move;
                }
                default: return validMoves[0];
            }
        }
        
        // --- Evaluation Functions ---
        function evaluateBoard(currentBoard, player) { /* ... (level 4,5 と同じ) ... */ return 0; }
        function advancedEvaluateBoard(currentBoard, player) {
            const opponent = player === WHITE ? BLACK : WHITE;
            const emptyCells = currentBoard.flat().filter(c => c === EMPTY).length;
            const isLateGame = emptyCells <= 16;
            let positionalScore = 0, pieceScore = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] === player) {
                        positionalScore += scoreMatrix[r][c];
                        pieceScore++;
                    } else if (currentBoard[r][c] === opponent) {
                        positionalScore -= scoreMatrix[r][c];
                        pieceScore--;
                    }
                }
            }
            const mobilityScore = getValidMoves(currentBoard, player).length - getValidMoves(currentBoard, opponent).length;
            const fixedDiscScore = countFixedDiscs(currentBoard, player) - countFixedDiscs(currentBoard, opponent);
            if (isLateGame) return pieceScore * 20 + fixedDiscScore * 150;
            return (positionalScore) + (mobilityScore * 50) + (fixedDiscScore * 150);
        }

        function countFixedDiscs(board, player) { /* ... (level 6 と同じ) ... */ return 0; }

        // --- Minimax & Alpha-beta ---
        function alphaBeta(currentBoard, depth, alpha, beta, maximizingPlayer) {
            const player = maximizingPlayer ? WHITE : BLACK;
            const validMoves = getValidMoves(currentBoard, player);

            if (depth === 0 || validMoves.length === 0) {
                const evaluator = (cpuLevel >= 6) ? advancedEvaluateBoard : evaluateBoard;
                return { score: evaluator(currentBoard, WHITE) };
            }

            let bestMove = { move: null, score: maximizingPlayer ? -Infinity : Infinity };
            for (const move of validMoves) {
                const newBoard = JSON.parse(JSON.stringify(currentBoard));
                const flippable = getFlippableDiscs(newBoard, move.r, move.c, player);
                newBoard[move.r][move.c] = player;
                flippable.forEach(p => { newBoard[p.r][p.c] = player; });
                
                const result = alphaBeta(newBoard, depth - 1, alpha, beta, !maximizingPlayer);

                if (maximizingPlayer) {
                    if (result.score > bestMove.score) {
                        bestMove.score = result.score;
                        bestMove.move = move;
                    }
                    alpha = Math.max(alpha, bestMove.score);
                } else {
                    if (result.score < bestMove.score) {
                        bestMove.score = result.score;
                        bestMove.move = move;
                    }
                    beta = Math.min(beta, bestMove.score);
                }
                if (beta <= alpha) break;
            }
            if (bestMove.move === null && validMoves.length > 0) {
                bestMove.move = validMoves[0];
            }
            return bestMove;
        }

        // --- Event Listeners & Init ---
        startButton.addEventListener('click', initGame);
        cpuLevelSelect.addEventListener('change', () => { cpuLevel = parseInt(cpuLevelSelect.value, 10); });
        
        // 評価関数と確定石関数の再定義（コードの短縮のため省略した部分を展開）
        evaluateBoard = function(currentBoard, player) {
            let score = 0;
            const opponent = player === WHITE ? BLACK : WHITE;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] === player) score += scoreMatrix[r][c];
                    else if (currentBoard[r][c] === opponent) score -= scoreMatrix[r][c];
                }
            }
            return score;
        }
        countFixedDiscs = function(board, player) {
            let count = 0;
            const corners = [{ r: 0, c: 0 }, { r: 0, c: 7 }, { r: 7, c: 0 }, { r: 7, c: 7 }];
            for (const {r, c} of corners) {
                if(board[r][c] === player) count++;
            }
            // 完全な確定石の判定は非常に複雑なため、ここでは角の数で代用していますが、
            // 高度な評価関数の中ではこれだけでも十分に機能します。
            return count;
        }

        initGame();
    </script>
</body>
</html>
